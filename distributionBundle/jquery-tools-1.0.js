// Generated by CoffeeScript 1.6.3
/*!
    Copyright see require on https://github.com/thaibault/require

    Conventions see require on https://github.com/thaibault/require

    @author t.sickert@gmail.com (Torben Sickert)
    @version 1.0 stable
    @fileOverview
    This module provides common reusable logic for every jQuery non trivial
    plugin.
*/


/**
    @name $
    @see www.jquery.com
*/


(function() {
  var __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function($) {
    /**
        This plugin provides such interface logic like generic controller logic
        for integrating plugins into $, mutual exclusion for depending gui
        elements, logging additional string, array or function handling. A set
        of helper functions to parse option objects dom trees or handle events
        is also provided.
    
        @memberOf $
        @class
    */

    var Tools;
    Tools = (function() {
      /**
          Saves the $ wrapped dom node.
      
          @property {Object}
      */

      Tools.prototype.$domNode = null;

      /**
          Saves a mapping from key codes to their corresponding name.
      
          @property {Object}
      */


      Tools.prototype.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
      };

      /**
          Saves default options for manipulating the default behaviour.
      
          @property {Object}
      */


      Tools.prototype._options = {
        logging: false,
        domNodeSelectorPrefix: 'body',
        domNode: {}
      };

      /**
          Used for internal mutual exclusion in critical areas. To prevent
          race conditions. Represents a map with critical area description
          and queues saving all functions waiting for unlocking their
          mapped critical area.
      
          @property {Object}
      */


      Tools.prototype._locks = {};

      /**
          This variable contains a collection of methods usually binded to
          the console object.
      */


      Tools.prototype._consoleMethods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];

      /**
          Saves the class name for introspection.
      
          @property {String}
      */


      Tools.prototype.__name__ = 'Tools';

      /**
          Indicates if an instance was derived from this class.
      
          @property {Boolean}
      */


      Tools.prototype.__tools__ = true;

      /**
          @description This method should be overwritten normally. It is
                       triggered if current object is created via the "new"
                       keyword.
      
          @returns {$.Tools} Returns the current instance.
      */


      function Tools($domNode) {
        var method, _i, _len, _ref;
        this.$domNode = $domNode;
        _ref = this._consoleMethods;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          method = _ref[_i];
          if (window.console == null) {
            window.console = {};
          }
          if (window.console[method] == null) {
            console[method] = $.noop();
          }
        }
        this;
      }

      /**
          @description This method could be overwritten normally.
                       It acts like a destructor.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.destructor = function() {
        this.off('*');
        return this;
      };

      /**
          @description This method should be overwritten normally. It is
                       triggered if current opject was created via the "new"
                       keyword and is called now.
      
          @param {Object} options An options object.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.initialize = function(options) {
        if (options == null) {
          options = {};
        }
        this._options.domNodeSelectorPrefix = this.stringFormat(this._options.domNodeSelectorPrefix, this.camelCaseStringToDelimited(this.__name__));
        if (options) {
          this._options = $.extend(true, this._options, options);
        }
        return this;
      };

      /**
          @description Defines a generic controller for $ plugins.
      
          @param {Object|String} object The object or class to control.
                                        If "object" is a class an instance
                                        will be generated.
          @param {Arguments} parameter The initially given arguments object.
      
          @returns {Mixed} Returns whatever the initializer method returns.
      */


      Tools.prototype.controller = function(object, parameter, $domNode) {
        if ($domNode == null) {
          $domNode = null;
        }
        parameter = this.argumentsObjectToArray(parameter);
        if (object.__name__ == null) {
          object = new object($domNode);
          if (object.__tools__ == null) {
            console.log('Post extending');
            object = $.extend(true, new Tools(), object);
          }
        }
        if ($domNode != null) {
          if ($domNode.data(object.__name__)) {
            object = $domNode.data(object.__name__);
          } else {
            $domNode.data(object.__name__, object);
          }
        }
        if (object[parameter[0]] != null) {
          return object[parameter[0]].apply(object, parameter.slice(1));
        } else if (!parameter.length || $.type(parameter[0]) === 'object') {
          /*
              If an options object or no method name is given the
              initializer will be called.
          */

          return object.initialize.apply(object, parameter);
        }
        return $.error(("Method \"" + parameter[0] + "\" does not exist on $-extension ") + ("" + object.__name__ + "\"."));
      };

      /**
          @description Extends a given object with the tools attributes.
      
          @param {Object} childAttributs The attributes from child.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.extend = function(childAttributes) {
        if (childAttributes) {
          $.extend(true, this, childAttributes);
        }
        return this;
      };

      /**
          @description Calling this method introduces a starting point for a
                       critical area with potential race conditions.
                       The area will be binded to given description string.
                       So don't use same names for different areas.
      
          @param {String} description A short string describing the criticial
                                      areas properties.
          @param {Function} callbackFunction A procedure which should only be
                                             executed if the interpreter
                                             isn't in the given critical
                                             area. The lock description
                                             string will be given to the
                                             callback function.
          @param {Boolean} autoRelease Release the lock after execution of
                                       given callback.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.acquireLock = function(description, callbackFunction, autoRelease) {
        var _this = this;
        if (autoRelease == null) {
          autoRelease = false;
        }
        /*
            NOTE: The "window.setTimeout()" wrapper guarantees that the
            following function will be executed without any context
            switches in all browsers.
            If you want to understand more about that,
            "What are event loops?" might be a good question.
        */

        window.setTimeout((function() {
          var wrappedCallbackFunction;
          wrappedCallbackFunction = function(description) {
            callbackFunction(description);
            if (autoRelease) {
              return _this.releaseLock(description);
            }
          };
          if (_this._locks[description] == null) {
            _this._locks[description] = [];
            return wrappedCallbackFunction(description);
          } else {
            return _this._locks[description].push(wrappedCallbackFunction);
          }
        }), 0);
        return this;
      };

      /**
          @description Calling this method  causes the given critical area to
                       be finished and all functions given to
                       "this.acquireLock()" will be executed in right order.
      
          @param {String} description A short string describing the criticial
                                      areas properties.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.releaseLock = function(description) {
        /*
            NOTE: The "window.setTimeout()" wrapper guarantees that the
            following function will be executed without any context
            switches in all browsers.
            If you want to understand more about that,
            "What are event loops?" might be a good question.
        */

        var _this = this;
        window.setTimeout((function() {
          if (_this._locks[description] != null) {
            if (_this._locks[description].length) {
              _this._locks[description].shift()(description);
              if (!_this._locks[description].length) {
                return _this._locks[description] = void 0;
              }
            } else {
              return _this._locks[description] = void 0;
            }
          }
        }), 0);
        return this;
      };

      /**
          @description This method fixes an ugly javascript bug.
                       If you add a mouseout event listener to a dom node
                       the given handler will be called each time any dom
                       node inside the observed dom node triggers a mouseout
                       event. This methods guarantees that the given event
                       handler is only called if the observed dom node was
                       leaved.
      
          @param {Function} eventHandler The mouse out event handler.
      
          @returns {Function} Returns the given function wrapped by the
                              workaround logic.
      */


      Tools.prototype.mouseOutEventHandlerFix = function(eventHandler) {
        var self;
        self = this;
        return function(event) {
          var relatedTarget;
          relatedTarget = event.toElement;
          if (event.relatedTarget) {
            relatedTarget = event.relatedTarget;
          }
          while (relatedTarget && relatedTarget.tagName !== 'BODY') {
            if (relatedTarget === this) {
              return;
            }
            relatedTarget = relatedTarget.parentNode;
          }
          return eventHandler.apply(self, arguments);
        };
      };

      /**
          @description Shows the given object's representation in the
                       browsers console if possible or in a standalone
                       alert-window as fallback.
      
          @param {Mixed} object Any type to show.
          @param {Boolean} force If set to "true" given input will be shown
                                 independly from current logging
                                 configuration or interpreter's console
                                 implementation.
          @param {Boolean} avoidAnnotation If set to "true" given input
                                           has no module or log level
                                           specific annotations.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.log = function(object, force, avoidAnnotation, level) {
        var message, _ref;
        if (force == null) {
          force = false;
        }
        if (avoidAnnotation == null) {
          avoidAnnotation = false;
        }
        if (level == null) {
          level = 'info';
        }
        if (this._options.logging || force) {
          if (avoidAnnotation) {
            message = object;
          } else if ($.type(object) === 'string') {
            message = ("" + this.__name__ + " (" + level + "): ") + this.stringFormat.apply(this, arguments);
          } else if ($.isNumeric(object)) {
            message = "" + this.__name__ + " (" + level + "): " + (object.toString());
          } else if ($.type(object) === 'boolean') {
            message = "" + this.__name__ + " (" + level + "): " + (object.toString());
          } else {
            this.log(",--------------------------------------------,");
            this.log(object, force, true);
            this.log("'--------------------------------------------'");
          }
          if (message) {
            if ((((_ref = window.console) != null ? _ref[level] : void 0) != null) === $.noop() && force) {
              window.alert(message);
            }
            window.console[level](message);
          }
        }
        return this;
      };

      /**
          @description Wrapper method for the native console method usually
                       provided by interpreter.
      
          @param {Mixed} object Any type to show.
          @param {Boolean} force If set to "true" given input will be shown
                                 independly from current logging
                                 configuration or interpreter's console
                                 implementation.
          @param {Boolean} avoidAnnotation If set to "true" given input
                                           has no module or log level
                                           specific annotations.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.info = function(object, force, avoidAnnotation, level) {
        if (force == null) {
          force = false;
        }
        if (avoidAnnotation == null) {
          avoidAnnotation = false;
        }
        if (level == null) {
          level = 'info';
        }
        return this.log(object, force, avoidAnnotation, level);
      };

      /**
          @description Wrapper method for the native console method usually
                       provided by interpreter.
      
          @param {Mixed} object Any type to show.
          @param {Boolean} force If set to "true" given input will be shown
                                 independly from current logging
                                 configuration or interpreter's console
                                 implementation.
          @param {Boolean} avoidAnnotation If set to "true" given input
                                           has no module or log level
                                           specific annotations.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.debug = function(object, force, avoidAnnotation, level) {
        if (force == null) {
          force = false;
        }
        if (avoidAnnotation == null) {
          avoidAnnotation = false;
        }
        if (level == null) {
          level = 'debug';
        }
        return this.log(object, force, avoidAnnotation, level);
      };

      /**
          @description Wrapper method for the native console method usually
                       provided by interpreter.
      
          @param {Mixed} object Any type to show.
          @param {Boolean} force If set to "true" given input will be shown
                                 independly from current logging
                                 configuration or interpreter's console
                                 implementation.
          @param {Boolean} avoidAnnotation If set to "true" given input
                                           has no module or log level
                                           specific annotations.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.error = function(object, force, avoidAnnotation, level) {
        if (force == null) {
          force = false;
        }
        if (avoidAnnotation == null) {
          avoidAnnotation = false;
        }
        if (level == null) {
          level = 'error';
        }
        return this.log(object, force, avoidAnnotation, level);
      };

      /**
          @description Wrapper method for the native console method usually
                       provided by interpreter.
      
          @param {Mixed} object Any type to show.
          @param {Boolean} force If set to "true" given input will be shown
                                 independly from current logging
                                 configuration or interpreter's console
                                 implementation.
          @param {Boolean} avoidAnnotation If set to "true" given input
                                           has no module or log level
                                           specific annotations.
      
          @returns {$.Tools} Returns the current instance.
      */


      Tools.prototype.warn = function(object, force, avoidAnnotation, level) {
        if (force == null) {
          force = false;
        }
        if (avoidAnnotation == null) {
          avoidAnnotation = false;
        }
        if (level == null) {
          level = 'warn';
        }
        return this.log(object, force, avoidAnnotation, level);
      };

      /**
          @description Dumps a given object in a human readable format.
      
          @param {Object} object Any type.
      
          @returns {String} Returns the searialized object.
      */


      Tools.prototype.show = function(object) {
        var output;
        output = '';
        if ($.type(object) === 'string') {
          output = object;
        } else {
          $.each(object, function(key, value) {
            if (value === void 0) {
              value = 'undefined';
            }
            return output += "" + (key.toString()) + ": " + (value.toString()) + "\n";
          });
        }
        if (!output) {
          output = output.toString();
        }
        return "" + ($.trim(output)) + "\n(Type: \"" + ($.type(object)) + "\")";
      };

      /**
          @description Removes a selector prefix from a given selector.
                       This methods searches in the options object for a
                       given "domNodeSelectorPrefix".
      
          @param {String} domNodeSelector The dom node selector to slice.
      
          @return {String} Returns the silced selector.
      */


      Tools.prototype.sliceDomNodeSelectorPrefix = function(domNodeSelector) {
        var _ref;
        if ((((_ref = this._options) != null ? _ref.domNodeSelectorPrefix : void 0) != null) && domNodeSelector.substring(0, this._options.domNodeSelectorPrefix.length) === this._options.domNodeSelectorPrefix) {
          return $.trim(domNodeSelector.substring(this._options.domNodeSelectorPrefix.length));
        }
        return domNodeSelector;
      };

      /**
          @description Determines the dom node name of a given dom node
                       string.
      
          @param {String} domNode A given to dom node selector to determine
                          its name.
      
          @returns {String}
      
          @example
      $.Tools.getDomNodeName('&lt;div&gt;');
      'div'
      
      $.Tools.getDomNodeName('&lt;div&gt;&lt;/div&gt;');
      'div'
      
      $.Tools.getDomNodeName('&lt;br/&gt;');
      'br'
      */


      Tools.prototype.getDomNodeName = function(domNode) {
        return domNode.match(new RegExp('^<?([a-zA-Z]+).*>?.*'))[1];
      };

      /**
          @description Converts an object of dom selectors to an array of
                       $ wrapped dom nodes. Note if selector
                       description as one of "class" or "id" as suffix
                       element will be ignored.
      
          @param {Object} domNodeSelectors An object with dom node selectors.
      
          @returns {Object} Returns all $ wrapped dom nodes corresponding to
                            given selectors.
      */


      Tools.prototype.grabDomNode = function(domNodeSelectors) {
        var domNodes,
          _this = this;
        domNodes = {};
        if (domNodeSelectors != null) {
          $.each(domNodeSelectors, function(key, value) {
            var match;
            if (key.substring(key.length - 2) !== 'Id' && key.substring(key.length - 5) !== 'Class') {
              match = value.match(', *');
              if (match) {
                $.each(value.split(match[0]), function(key, valuePart) {
                  if (key) {
                    return value += ", " + (_this._grabDomNodeHelper(key, valuePart, domNodeSelectors));
                  } else {
                    return value = valuePart;
                  }
                });
              }
              value = _this._grabDomNodeHelper(key, value, domNodeSelectors);
            }
            return domNodes[key] = $(value);
          });
        }
        if (this._options && this._options.domNodeSelectorPrefix) {
          domNodes.parent = $(this._options.domNodeSelectorPrefix);
        }
        domNodes.window = $(window);
        domNodes.document = $(document);
        return domNodes;
      };

      /**
          @description Methods given by this method has the plugin scope
                       referenced with "this". Otherwise "this" usualy
                       points to the object the given method was attached to.
                       If "method" doesn't match string arguments are passed
                       through "$.proxy()" with "context" setted as
                       "scope" or "this" if nothing is provided.
      
          @param {String|Function|Object} method A method name of given
                                                 scope.
          @param {Object|String} scope A given scope.
      
          @returns {Mixed} Returns the given methods return value.
      */


      Tools.prototype.getMethod = function() {
        var additionalArguments, method, parameter, scope;
        method = arguments[0], scope = arguments[1], additionalArguments = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        if (scope == null) {
          scope = this;
        }
        /*
            This following outcomment line would be responsible for a
            bug in yuicompressor.
            Because of declaration of arguments the parser things that
            arguments is a local variable and could be renamed.
            It doesn't care about that the magic arguments object is
            neccessary to generate the arguments array in this context.
        
            var arguments = this.argumentsObjectToArray(arguments);
        
            use something like this instead:
        
            var parameter = this.argumentsObjectToArray(arguments);
        */

        parameter = this.argumentsObjectToArray(arguments);
        if ($.type(method) === 'string' && $.type(scope) === 'object') {
          return function() {
            var thisFunction;
            if (!scope[method]) {
              $.error(("Method \"" + method + "\" doesn't exists in ") + ("\"" + scope + "\"."));
            }
            thisFunction = arguments.callee;
            parameter = $.Tools().argumentsObjectToArray(arguments);
            parameter.push(thisFunction);
            return scope[method].apply(scope, parameter.concat(additionalArguments));
          };
        }
        parameter.unshift(scope);
        parameter.unshift(method);
        return $.proxy.apply($, parameter);
      };

      /**
          @description Prevents event functions from triggering to often by
                       defining a minimal span between each function call.
      
          @returns {Function} Returns the wrapped method.
      */


      Tools.prototype.debounce = function(eventFunction, thresholdInMilliseconds) {
        var timeoutID;
        if (thresholdInMilliseconds == null) {
          thresholdInMilliseconds = 300;
        }
        timeoutID = null;
        return function() {
          if (timeoutID != null) {
            window.clearTimeout(timeoutID);
            return timeoutID = setTimeout(eventFunction, thresholdInMilliseconds);
          } else {
            eventFunction();
            return timeoutID = setTimeout($.noop(), thresholdInMilliseconds);
          }
        };
      };

      /**
          @description Searches for internal event handler methods and runs
                       them by default. In addition this method searches for
                       a given event method by the options object.
      
          @param {String} eventName An event name.
          @param {Boolean} callOnlyOptionsMethod Prevents from trying to
                                                 call an internal event
                                                 handler.
          @param {Object} scope The scope from where the given event handler
                                should be called.
      
          @returns {Boolean} Returns "true" if an event handler was called
                             and "false" otherwise.
      */


      Tools.prototype.fireEvent = function() {
        var additionalArguments, callOnlyOptionsMethod, eventHandlerName, eventName, scope;
        eventName = arguments[0], callOnlyOptionsMethod = arguments[1], scope = arguments[2], additionalArguments = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
        if (callOnlyOptionsMethod == null) {
          callOnlyOptionsMethod = false;
        }
        if (scope == null) {
          scope = this;
        }
        if (!scope) {
          scope = this;
        }
        eventHandlerName = 'on' + eventName.substr(0, 1).toUpperCase() + eventName.substr(1);
        if (!callOnlyOptionsMethod) {
          if (scope[eventHandlerName]) {
            scope[eventHandlerName].apply(scope, additionalArguments);
          } else if (scope["_" + eventHandlerName]) {
            scope["_" + eventHandlerName].apply(scope, additionalArguments);
          }
        }
        if (scope._options && scope._options[eventHandlerName]) {
          scope._options[eventHandlerName].apply(scope, additionalArguments);
          return true;
        }
        return false;
      };

      /**
          @description A wrapper method for "$.delegate()".
                       It sets current plugin name as event scope if no scope
                       is given. Given arguments are modified and passed
                       through "$.delegate()".
      
          @returns {$} Returns $'s grabbed dom node.
      */


      Tools.prototype.delegate = function() {
        return this._bindHelper(arguments, false, 'delegate');
      };

      /**
          @description A wrapper method for "$.undelegate()". It sets current
                       plugin name as event scope if no scope is given. Given
                       arguments are modified and passed through
                       "$.undelegate()".
      
          @returns {$} Returns $'s grabbed dom node.
      */


      Tools.prototype.undelegate = function() {
        return this._bindHelper(arguments, true, 'undelegate');
      };

      /**
          @description A wrapper method for "$.on()".
                       It sets current plugin name as event scope if no scope
                       is given. Given arguments are modified and passed
                       through "$.on()".
      
          @returns {$} Returns $'s grabbed dom node.
      */


      Tools.prototype.on = function() {
        return this._bindHelper(arguments, false, 'on');
      };

      /**
          @description A wrapper method fo "$.off()".
                       It sets current plugin name as event scope if no scope
                       is given. Given arguments are modified and passed
                       through "$.off()".
      
          @returns {$} Returns $'s grabbed dom node.
      */


      Tools.prototype.off = function() {
        return this._bindHelper(arguments, true, 'off');
      };

      /**
          @description A wrapper method for "$.bind()".
                       It sets current plugin name as event scope if no scope
                       is given. Given arguments are modified and passed
                       through "$.bind()".
      
          @returns {$} Returns $'s grabbed dom node.
      */


      Tools.prototype.bind = function() {
        return this._bindHelper(arguments);
      };

      /**
          @description A wrapper method fo "$.unbind()".
                       It sets current plugin name as event scope if no scope
                       is given. Given arguments are modified and passed
                       through "$.unbind()".
      
          @returns {$} Returns $'s grabbed dom node.
      */


      Tools.prototype.unbind = function() {
        return this._bindHelper(arguments, true);
      };

      /**
          @description Converts a given argument object to an array.
      
          @param {Object} argumentsObject The arguments object to convert.
      
          @returns {Object[]} Returns the given arguments as array.
      */


      /**
          @description Converts the interpreter given magic arguments
                       object to a standard array object.
      
          @param {Object} argumentsObject An argument object.
      
          @returns {Object[]} Returns the array containing all elements in
                              given arguments object.
      */


      Tools.prototype.argumentsObjectToArray = function(argumentsObject) {
        return Array.prototype.slice.call(argumentsObject);
      };

      /**
          @description Rounds a given number accurate to given number of
                       digits.
      
          @param {Float} number The number to round.
          @param {Integer} digits The number of digits after comma.
      
          @returns {Float} Returns the rounded number.
      */


      Tools.prototype.round = function(number, digits) {
        if (digits == null) {
          digits = 0;
        }
        return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
      };

      /**
          @description Performs a string formation. Replaces every
                       placeholder "{i}" with the i'th argument.
      
          @param {String} string The string to format.
      
          @returns {String} The formatted string.
      */


      Tools.prototype.stringFormat = function(string) {
        $.each(arguments, function(key, value) {
          return string = string.replace(new RegExp("\\{" + key + "\\}", 'gm'), value);
        });
        return string;
      };

      /**
          @description Converts a camel case string to a string with given
                       delimiter between each camel case seperation.
      
          @param {String} string The string to format.
          @param {String} delimiter The string tu put between each camel case
                                    seperation.
      
          @returns {String} The formatted string.
      */


      Tools.prototype.camelCaseStringToDelimited = function(string, delimiter) {
        if (delimiter == null) {
          delimiter = '-';
        }
        return string.replace(new RegExp('(.)([A-Z])', 'g'), function() {
          return arguments[1] + delimiter + arguments[2];
        }).toLowerCase();
      };

      /**
          @description Appends a path selector to the given path if there
                       isn't one yet.
      
          @param {String} path The path for appending a selector.
          @param {String} pathSeperator The selector for appending to path.
      
          @returns {String} The appended path.
      */


      Tools.prototype.addSeperatorToPath = function(path, pathSeperator) {
        if (pathSeperator == null) {
          pathSeperator = '/';
        }
        path = $.trim(path);
        if (path.substr(-1) !== pathSeperator && path.length) {
          return path + pathSeperator;
        }
        return path;
      };

      /**
          @description Read a page's GET URL variables and return them as an
                       associative array.
      
          @param {String} key A get array key. If given only the
                              corresponding value is returned and full array
                              otherwise.
      
          @returns {Mixed} Returns the current get array or requested value.
                                   If requested key doesn't exist "undefined"
                                   is returned.
      */


      Tools.prototype.getUrlVariables = function(key) {
        var variables;
        variables = [];
        $.each(window.location.href.slice(window.location.href.indexOf('?') + 1).split('&'), function(key, value) {
          variables.push(value.split('=')[0]);
          return variables[value.split('=')[0]] = value.split('=')[1];
        });
        if ($.type(key) === 'string') {
          if (__indexOf.call(variables, key) >= 0) {
            return variables[key];
          } else {
            return void 0;
          }
        }
        return variables;
      };

      /**
          @description Helper method for atach event handler methods and
                       their event handler removings pendants.
      
          @param {Object} parameter Arguments object given to methods
                                    like "bind()" or "unbind()".
          @param {Boolean} removeEvent Indicates if "unbind()" or "bind()"
                                       was given.
          @param {String} eventFunctionName Name of function to wrap.
      
          @returns {$} Returns $'s wrapped dom node.
      */


      Tools.prototype._bindHelper = function(parameter, removeEvent, eventFunctionName) {
        var $Object,
          _this = this;
        if (removeEvent == null) {
          removeEvent = false;
        }
        if (eventFunctionName == null) {
          eventFunctionName = 'bind';
        }
        $Object = $(parameter[0]);
        if ($.type(parameter[1]) === 'object' && !removeEvent) {
          $.each(parameter[1], function(eventType, handler) {
            return _this[eventFunctionName]($Object, eventType, handler);
          });
          return $Object;
        }
        parameter = this.argumentsObjectToArray(parameter).slice(1);
        if (parameter.length === 0) {
          parameter.push('');
        }
        if (parameter[0].indexOf('.') === -1) {
          parameter[0] += "." + this.__name__;
        }
        if (removeEvent) {
          return $Object[eventFunctionName].apply($Object, parameter);
        }
        return $Object[eventFunctionName].apply($Object, parameter);
      };

      /**
          @description Converts a dom selector to a prefixed dom selector
                       string.
      
          @param {Integer} key Current element in options array to grab.
          @param {String} selector A dom node selector.
          @param {Object} domNodeSelectors An object with dom node selectors.
      
          @returns {Object}
      */


      Tools.prototype._grabDomNodeHelper = function(key, selector, domNodeSelectors) {
        var domNodeSelectorPrefix;
        domNodeSelectorPrefix = 'body';
        if (this._options && this._options.domNodeSelectorPrefix) {
          domNodeSelectorPrefix = this._options.domNodeSelectorPrefix;
        }
        if (selector.substr(0, domNodeSelectorPrefix.length) !== domNodeSelectorPrefix) {
          return domNodeSelectors[key] = "" + domNodeSelectorPrefix + " " + selector;
        }
        return selector;
      };

      return Tools;

    })();
    /** @ignore*/

    $.fn.Tools = function() {
      return new Tools().controller(Tools, arguments, this);
    };
    /** @ignore*/

    $.Tools = function() {
      return new Tools().controller(Tools, arguments);
    };
    /** @ignore*/

    return $.Tools["class"] = Tools;
  })(this.jQuery);

}).call(this);
