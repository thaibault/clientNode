(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory((function webpackLoadOptionalExternalModule() { try { return require('jquery'); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define("clientnode", ['jquery'], factory);
	else if(typeof exports === 'object')
		exports["clientnode"] = factory((function webpackLoadOptionalExternalModule() { try { return require('jquery'); } catch(e) {} }()));
	else
		root['clientnode'] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*******************!*\
  !*** multi index ***!
  \*******************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! index.js */1);


/***/ },
/* 1 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global, module) {\n// #!/usr/bin/env node\n// -*- coding: utf-8 -*-\n/** @module clientnode */\n'use strict';\n/* !\n    region header\n    [Project page](http://torben.website/clientnode)\n\n    Copyright Torben Sickert (info[\"~at~\"]torben.website) 16.12.2012\n\n    License\n    -------\n\n    This library written by Torben Sickert stand under a creative commons\n    naming 3.0 unported license.\n    See http://creativecommons.org/licenses/by/3.0/deed.de\n    endregion\n*/\n// region imports\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// endregion\n// region determine context\n\n// endregion\n// region types\nvar globalContext = exports.globalContext = function () {\n    if (typeof window === 'undefined') {\n        if (typeof global === 'undefined') return  false ? {} : module;\n        if ('window' in global) return global.window;\n        return global;\n    }\n    return window;\n}();\n/* eslint-disable no-use-before-define */\nvar $ = exports.$ = function () {\n    /* eslint-enable no-use-before-define */\n    var _$ = void 0;\n    if ('$' in globalContext && globalContext.$ !== null) _$ = globalContext.$;else {\n        var _ret = function () {\n            if (!('$' in globalContext)) try {\n                return {\n                    v: __webpack_require__(/*! jquery */ 3)\n                };\n            } catch (error) {}\n            var selector = 'document' in globalContext && 'querySelectorAll' in globalContext.document ? globalContext.document.querySelectorAll : function () {\n                return null;\n            };\n            _$ = function $(parameter) {\n                if (typeof parameter === 'string') {\n                    var $domNodes = selector.apply(globalContext.document, arguments);\n                    if ('fn' in _$) for (var _key in _$.fn) {\n                        if (_$.fn.hasOwnProperty(_key))\n                            // IgnoreTypeCheck\n                            $domNodes[_key] = _$.fn[_key].bind($domNodes);\n                    }return $domNodes;\n                }\n                /* eslint-disable no-use-before-define */\n                if (Tools.isFunction(parameter) && 'document' in globalContext)\n                    /* eslint-enable no-use-before-define */\n                    globalContext.document.addEventListener('DOMContentLoaded', parameter);\n                return parameter;\n            };\n            _$.fn = {};\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n    return _$;\n}();\nif (!('global' in $)) $.global = globalContext;\nif (!('context' in $) && 'document' in $.global) $.contest = $.global.document;\n// endregion\n// region plugins/classes\n/**\n * This plugin provides such interface logic like generic controller logic for\n * integrating plugins into $, mutual exclusion for depending gui elements,\n * logging additional string, array or function handling. A set of helper\n * functions to parse option objects dom trees or handle events is also\n * provided.\n * @property static:abbreviations - Lists all known abbreviation for proper\n * camel case to delimited and back conversion.\n * @property static:animationEndEventNames - Saves a string with all css3\n * browser specific animation end event names.\n * @property static:keyCode - Saves a mapping from key codes to their\n * corresponding name.\n * @property static:maximalSupportedInternetExplorerVersion - Saves currently\n * minimal supported internet explorer version. Saves zero if no internet\n * explorer present.\n * @property static:transitionEndEventNames - Saves a string with all css3\n * browser specific transition end event names.\n * @property static:consoleMethodNames - This variable contains a collection of\n * methods usually binded to the console object.\n * @property static:_javaScriptDependentContentHandled - Indicates whether\n * javaScript dependent content where hide or shown.\n * @property static:_name - Defines this class name to allow retrieving them\n * after name mangling.\n * @property $domNode - $-extended dom node if one was given to the constructor\n * method.\n * @property _options - Options given to the constructor.\n * @property _defaultOptions - Fallback options if not overwritten by the\n * options given to the constructor method.\n * @property _defaultOptions.logging {boolean} - Indicates whether logging\n * should be active.\n * @property _defaultOptions.domNodeSelectorPrefix {string} - Selector prefix\n * for all needed dom nodes.\n * @property _defaultOptions.domNode {Object.<string, string>} - Mapping of\n * names to needed dom nodes referenced by there selector.\n * @property _defaultOptions.domNode.hideJavaScriptEnabled {string} - Selector\n * to dom nodes which should be hidden if javaScript is available.\n * @property _defaultOptions.domNode.showJavaScriptEnabled {string} - Selector\n * to dom nodes which should be visible if javaScript is available.\n * @property _locks - Mapping of lock descriptions to there corresponding\n * callbacks.\n */\n\nvar Tools = function () {\n    // endregion\n    // region public methods\n    // / region special\n    /**\n     * This method should be overwritten normally. It is triggered if current\n     * object is created via the \"new\" keyword. The dom node selector prefix\n     * enforces to not globally select any dom nodes which aren't in the\n     * expected scope of this plugin. \"{1}\" will be automatically replaced with\n     * this plugin name suffix (\"tools\"). You don't have to use \"{1}\" but it\n     * can help you to write code which is more reconcilable with the dry\n     * concept.\n     * @param $domNode - $-extended dom node to use as reference in various\n     * methods.\n     * @param options - Options to change runtime behavior.\n     * @param defaultOptions - Default options to ensure to be present in any\n     * options instance.\n     * @param locks - Mapping of a lock description to callbacks for calling\n     * when given lock should be released.\n     * @returns Returns nothing but if invoked with \"new\" an instance of this\n     * class will be given back.\n     */\n\n    // endregion\n    // region dynamic properties\n    function Tools() {\n        var $domNode = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n        var defaultOptions = arguments.length <= 2 || arguments[2] === undefined ? {\n            logging: false, domNodeSelectorPrefix: 'body', domNode: {\n                hideJavaScriptEnabled: '.tools-hidden-on-javascript-enabled',\n                showJavaScriptEnabled: '.tools-visible-on-javascript-enabled'\n            }\n        } : arguments[2];\n        var locks = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n        _classCallCheck(this, Tools);\n\n        if ($domNode) this.$domNode = $domNode;\n        this._options = options;\n        this._defaultOptions = defaultOptions;\n        this._locks = locks;\n        // Avoid errors in browsers that lack a console.\n        if (!('console' in $.global)) $.global.console = {};\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = this.constructor.consoleMethodNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var methodName = _step.value;\n\n                if (!(methodName in $.global.console)) $.global.console[methodName] = this.constructor.noop;\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        if (!this.constructor._javaScriptDependentContentHandled && 'document' in $.global && 'filter' in $ && 'hide' in $ && 'show' in $) {\n            this.constructor._javaScriptDependentContentHandled = true;\n            $(this._defaultOptions.domNodeSelectorPrefix + ' ' + this._defaultOptions.domNode.hideJavaScriptEnabled).filter(function () {\n                return !$(this).data('javaScriptDependentContentHide');\n            }).data('javaScriptDependentContentHide', true).hide();\n            $(this._defaultOptions.domNodeSelectorPrefix + ' ' + this._defaultOptions.domNode.showJavaScriptEnabled).filter(function () {\n                return !$(this).data('javaScriptDependentContentShow');\n            }).data('javaScriptDependentContentShow', true).show();\n        }\n    }\n    /**\n     * This method could be overwritten normally. It acts like a destructor.\n     * @returns Returns the current instance.\n     */\n\n    // region static properties\n\n\n    _createClass(Tools, [{\n        key: 'destructor',\n        value: function destructor() {\n            if ('off' in $.fn) this.off('*');\n            return this;\n        }\n        /**\n         * This method should be overwritten normally. It is triggered if current\n         * object was created via the \"new\" keyword and is called now.\n         * @param options - An options object.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'initialize',\n        value: function initialize() {\n            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n            /*\n                NOTE: We have to create a new options object instance to avoid\n                changing a static options object.\n            */\n            this._options = this.constructor.extendObject(true, {}, this._defaultOptions, this._options, options);\n            /*\n                The selector prefix should be parsed after extending options\n                because the selector would be overwritten otherwise.\n            */\n            this._options.domNodeSelectorPrefix = this.constructor.stringFormat(this._options.domNodeSelectorPrefix, this.constructor.stringCamelCaseToDelimited(this.constructor._name));\n            return this;\n        }\n        // / endregion\n        // / region object orientation\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Defines a generic controller for dom node aware plugins.\n         * @param object - The object or class to control. If \"object\" is a class\n         * an instance will be generated.\n         * @param parameter - The initially given arguments object.\n         * @param $domNode - Optionally a $-extended dom node to use as reference.\n         * @returns Returns whatever the initializer method returns.\n         */\n\n    }, {\n        key: 'controller',\n        value: function controller(object, parameter) {\n            var $domNode = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            if (typeof object === 'function') {\n                object = new object($domNode);\n                if (!object instanceof Tools) object = this.constructor.extendObject(true, new Tools(), object);\n            }\n            parameter = this.constructor.arrayMake(parameter);\n            if ($domNode && 'data' in $domNode && !$domNode.data(object.constructor._name))\n                // Attach extended object to the associated dom node.\n                $domNode.data(object.constructor._name, object);\n            if (parameter[0] in object) return object[parameter[0]].apply(object, parameter.slice(1));else if (parameter.length === 0 || _typeof(parameter[0]) === 'object')\n                /*\n                    If an options object or no method name is given the initializer\n                    will be called.\n                */\n                return object.initialize.apply(object, parameter);\n            throw Error('Method \"' + parameter[0] + '\" does not exist on $-extended dom node ' + ('\"' + object.constructor._name + '\".'));\n        }\n        // / endregion\n        // / region mutual exclusion\n        /**\n         * Calling this method introduces a starting point for a critical area with\n         * potential race conditions. The area will be binded to given description\n         * string. So don't use same names for different areas.\n         * @param description - A short string describing the critical areas\n         * properties.\n         * @param callbackFunction - A procedure which should only be executed if\n         * the interpreter isn't in the given critical area. The lock description\n         * string will be given to the callback function.\n         * @param autoRelease - Release the lock after execution of given callback.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'acquireLock',\n        value: function acquireLock(description, callbackFunction) {\n            var _this = this;\n\n            var autoRelease = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n            var wrappedCallbackFunction = function wrappedCallbackFunction(description) {\n                callbackFunction(description);\n                if (autoRelease) _this.releaseLock(description);\n            };\n            if (this._locks.hasOwnProperty(description)) this._locks[description].push(wrappedCallbackFunction);else {\n                this._locks[description] = [];\n                wrappedCallbackFunction(description);\n            }\n            return this;\n        }\n        /**\n         * Calling this method  causes the given critical area to be finished and\n         * all functions given to \"this.acquireLock()\" will be executed in right\n         * order.\n         * @param description - A short string describing the critical areas\n         * properties.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'releaseLock',\n        value: function releaseLock(description) {\n            if (this._locks.hasOwnProperty(description)) if (this._locks[description].length) this._locks[description].shift()(description);else delete this._locks[description];\n            return this;\n        }\n        // / endregion\n        // / region boolean\n        /**\n         * Determines whether its argument represents a JavaScript number.\n         * @param object - Object to analyze.\n         * @returns A boolean value indicating whether given object is numeric\n         * like.\n         */\n\n    }, {\n        key: 'log',\n\n        // / endregion\n        // / region logging\n        /**\n         * Shows the given object's representation in the browsers console if\n         * possible or in a standalone alert-window as fallback.\n         * @param object - Any object to print.\n         * @param force - If set to \"true\" given input will be shown independently\n         * from current logging configuration or interpreter's console\n         * implementation.\n         * @param avoidAnnotation - If set to \"true\" given input has no module or\n         * log level specific annotations.\n         * @param level - Description of log messages importance.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n        value: function log(object) {\n            var force = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n            var avoidAnnotation = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n            var level = arguments.length <= 3 || arguments[3] === undefined ? 'info' : arguments[3];\n\n            if (this._options.logging || force || ['error', 'critical'].includes(level)) {\n                var message = void 0;\n                if (avoidAnnotation) message = object;else if (typeof object === 'string') {\n                    for (var _len = arguments.length, additionalArguments = Array(_len > 4 ? _len - 4 : 0), _key2 = 4; _key2 < _len; _key2++) {\n                        additionalArguments[_key2 - 4] = arguments[_key2];\n                    }\n\n                    additionalArguments.unshift(object);\n                    message = this.constructor._name + ' (' + level + '): ' + this.constructor.stringFormat.apply(this, additionalArguments);\n                } else if (this.constructor.isNumeric(object) || typeof object === 'boolean') message = this.constructor._name + ' (' + level + '): ' + object.toString();else {\n                    this.log(',--------------------------------------------,');\n                    this.log(object, force, true);\n                    this.log(\"'--------------------------------------------'\");\n                }\n                if (message) if (!('console' in $.global && level in $.global.console) || $.global.console[level] === this.constructor.noop) {\n                    if ('alert' in $.global) $.global.alert(message);\n                } else $.global.console[level](message);\n            }\n            return this;\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'info',\n        value: function info(object) {\n            for (var _len2 = arguments.length, additionalArguments = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {\n                additionalArguments[_key3 - 1] = arguments[_key3];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, false, false, 'info'].concat(additionalArguments));\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'debug',\n        value: function debug(object) {\n            for (var _len3 = arguments.length, additionalArguments = Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {\n                additionalArguments[_key4 - 1] = arguments[_key4];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, false, false, 'debug'].concat(additionalArguments));\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'error',\n        value: function error(object) {\n            for (var _len4 = arguments.length, additionalArguments = Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {\n                additionalArguments[_key5 - 1] = arguments[_key5];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, true, false, 'error'].concat(additionalArguments));\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'critical',\n        value: function critical(object) {\n            for (var _len5 = arguments.length, additionalArguments = Array(_len5 > 1 ? _len5 - 1 : 0), _key6 = 1; _key6 < _len5; _key6++) {\n                additionalArguments[_key6 - 1] = arguments[_key6];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, true, false, 'warn'].concat(additionalArguments));\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'warn',\n        value: function warn(object) {\n            for (var _len6 = arguments.length, additionalArguments = Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {\n                additionalArguments[_key7 - 1] = arguments[_key7];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, false, false, 'warn'].concat(additionalArguments));\n        }\n        /**\n         * Dumps a given object in a human readable format.\n         * @param object - Any object to show.\n         * @param level - Number of levels to dig into given object recursively.\n         * @param currentLevel - Maximal number of recursive function calls to\n         * represent given object.\n         * @returns Returns the serialized version of given object.\n         */\n\n    }, {\n        key: 'getText',\n\n        // / endregion\n        // / region dom node\n        /**\n         * Get text content of current element without it children's text contents.\n         * @returns The text string.\n         */\n        value: function getText() {\n            return this.$domNode.clone().children().remove().end().text();\n        }\n        /**\n         * Normalizes class name order of current dom node.\n         * @returns Current instance.\n         */\n\n    }, {\n        key: 'normalizeClassNames',\n        value: function normalizeClassNames() {\n            this.$domNode.find('*').addBack().each(function () {\n                var $thisDomNode = $(this);\n                if ($thisDomNode.attr('class')) {\n                    var sortedClassNames = $thisDomNode.attr('class').split(' ').sort() || [];\n                    $thisDomNode.attr('class', '');\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = sortedClassNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var _className = _step2.value;\n\n                            $thisDomNode.addClass(_className);\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                } else if ($thisDomNode.is('[class]')) $thisDomNode.removeAttr('class');\n            });\n            return this;\n        }\n        /**\n         * Normalizes style attributes order of current dom node.\n         * @returns Returns current instance.\n         */\n\n    }, {\n        key: 'normalizeStyles',\n        value: function normalizeStyles() {\n            var self = this;\n            this.$domNode.find('*').addBack().each(function () {\n                var $thisDomNode = $(this);\n                var serializedStyles = $thisDomNode.attr('style');\n                if (serializedStyles) {\n                    var sortedStyles = self.constructor.stringCompressStyleValue(serializedStyles).split(';').sort() || [];\n                    $thisDomNode.attr('style', '');\n                    var _iteratorNormalCompletion3 = true;\n                    var _didIteratorError3 = false;\n                    var _iteratorError3 = undefined;\n\n                    try {\n                        for (var _iterator3 = sortedStyles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                            var style = _step3.value;\n\n                            $thisDomNode.css.apply($thisDomNode, style.trim().split(':'));\n                        }\n                    } catch (err) {\n                        _didIteratorError3 = true;\n                        _iteratorError3 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                _iterator3.return();\n                            }\n                        } finally {\n                            if (_didIteratorError3) {\n                                throw _iteratorError3;\n                            }\n                        }\n                    }\n\n                    $thisDomNode.attr('style', self.constructor.stringCompressStyleValue($thisDomNode.attr('style')));\n                } else if ($thisDomNode.is('[style]')) $thisDomNode.removeAttr('style');\n            });\n            return this;\n        }\n        /**\n         * Checks whether given html or text strings are equal.\n         * @param first - First html, selector to dom node or text to compare.\n         * @param second - Second html, selector to dom node  or text to compare.\n         * @param forceHTMLString - Indicates whether given contents are\n         * interpreted as html string (otherwise an automatic detection will be\n         * triggered).\n         * @returns Returns true if both dom representations are equivalent.\n         */\n\n    }, {\n        key: 'getPositionRelativeToViewport',\n\n        /**\n         * Determines where current dom node is relative to current view port\n         * position.\n         * @param delta - Allows deltas for \"top\", \"left\", \"bottom\" and \"right\" for\n         * determining positions.\n         * @returns Returns one of \"above\", \"left\", \"below\", \"right\" or \"in\".\n         */\n        value: function getPositionRelativeToViewport() {\n            var delta = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n            delta = this.constructor.extendObject({ top: 0, left: 0, bottom: 0, right: 0 }, delta);\n            if ('window' in $.global && this.$domNode && this.$domNode.length && this.$domNode[0]) {\n                var $window = $($.global.window);\n                var rectangle = this.$domNode[0].getBoundingClientRect();\n                if (rectangle.top + delta.top < 0) return 'above';\n                if (rectangle.left + delta.left < 0) return 'left';\n                if ($window.height() < rectangle.bottom + delta.bottom) return 'below';\n                if ($window.width() < rectangle.right + delta.right) return 'right';\n            }\n            return 'in';\n        }\n        /**\n         * Generates a directive name corresponding selector string.\n         * @param directiveName - The directive name.\n         * @returns Returns generated selector.\n         */\n\n    }, {\n        key: 'removeDirective',\n\n        /**\n         * Removes a directive name corresponding class or attribute.\n         * @param directiveName - The directive name.\n         * @returns Returns current dom node.\n         */\n        value: function removeDirective(directiveName) {\n            var delimitedName = this.constructor.stringCamelCaseToDelimited(directiveName);\n            return this.$domNode.removeClass(delimitedName).removeAttr(delimitedName).removeAttr('data-' + delimitedName).removeAttr('x-' + delimitedName).removeAttr(delimitedName.replace('-', ':')).removeAttr(delimitedName.replace('-', '_'));\n        }\n        /**\n         * Determines a normalized camel case directive name representation.\n         * @param directiveName - The directive name.\n         * @returns Returns the corresponding name.\n         */\n\n    }, {\n        key: 'getDirectiveValue',\n\n        /**\n         * Determines a directive attribute value.\n         * @param directiveName - The directive name.\n         * @returns Returns the corresponding attribute value or \"null\" if no\n         * attribute value exists.\n         */\n        value: function getDirectiveValue(directiveName) {\n            var delimitedName = this.constructor.stringCamelCaseToDelimited(directiveName);\n            var _arr = [delimitedName, 'data-' + delimitedName, 'x-' + delimitedName, delimitedName.replace('-', '\\\\:')];\n            for (var _i = 0; _i < _arr.length; _i++) {\n                var _attributeName = _arr[_i];\n                var _value = this.$domNode.attr(_attributeName);\n                if (_value !== undefined) return _value;\n            }\n            return null;\n        }\n        /**\n         * Removes a selector prefix from a given selector. This methods searches\n         * in the options object for a given \"domNodeSelectorPrefix\".\n         * @param domNodeSelector - The dom node selector to slice.\n         * @returns Returns the sliced selector.\n         */\n\n    }, {\n        key: 'sliceDomNodeSelectorPrefix',\n        value: function sliceDomNodeSelectorPrefix(domNodeSelector) {\n            if ('domNodeSelectorPrefix' in this._options && domNodeSelector.startsWith(this._options.domNodeSelectorPrefix)) return domNodeSelector.substring(this._options.domNodeSelectorPrefix.length).trim();\n            return domNodeSelector;\n        }\n        /**\n         * Determines the dom node name of a given dom node string.\n         * @param domNodeSelector - A given to dom node selector to determine its\n         * name.\n         * @returns Returns The dom node name.\n         * @example\n         * // returns 'div'\n         * $.Tools.getDomNodeName('&lt;div&gt;')\n         * @example\n         * // returns 'div'\n         * $.Tools.getDomNodeName('&lt;div&gt;&lt;/div&gt;')\n         * @example\n         * // returns 'br'\n         * $.Tools.getDomNodeName('&lt;br/&gt;')\n         */\n\n    }, {\n        key: 'grabDomNode',\n\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Converts an object of dom selectors to an array of $ wrapped dom nodes.\n         * Note if selector description as one of \"class\" or \"id\" as suffix element\n         * will be ignored.\n         * @param domNodeSelectors - An object with dom node selectors.\n         * @param wrapperDomNode - A dom node to be the parent or wrapper of all\n         * retrieved dom nodes.\n         * @returns Returns All $ wrapped dom nodes corresponding to given\n         * selectors.\n         */\n        value: function grabDomNode(domNodeSelectors, wrapperDomNode) {\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            var domNodes = {};\n            if (domNodeSelectors) if (wrapperDomNode) {\n                var $wrapperDomNode = $(wrapperDomNode);\n                for (var _name in domNodeSelectors) {\n                    if (domNodeSelectors.hasOwnProperty(_name)) domNodes[_name] = $wrapperDomNode.find(domNodeSelectors[_name]);\n                }\n            } else for (var _name2 in domNodeSelectors) {\n                if (domNodeSelectors.hasOwnProperty(_name2)) {\n                    var match = domNodeSelectors[_name2].match(', *');\n                    if (match) {\n                        var _iteratorNormalCompletion4 = true;\n                        var _didIteratorError4 = false;\n                        var _iteratorError4 = undefined;\n\n                        try {\n                            for (var _iterator4 = domNodeSelectors[_name2].split(match[0])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                                var _selectorPart = _step4.value;\n\n                                domNodeSelectors[_name2] += ', ' + this.normalizeDomNodeSelector(_selectorPart);\n                            }\n                        } catch (err) {\n                            _didIteratorError4 = true;\n                            _iteratorError4 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                    _iterator4.return();\n                                }\n                            } finally {\n                                if (_didIteratorError4) {\n                                    throw _iteratorError4;\n                                }\n                            }\n                        }\n                    }domNodes[_name2] = $(this.normalizeDomNodeSelector(domNodeSelectors[_name2]));\n                }\n            }if (this._options.domNodeSelectorPrefix) domNodes.parent = $(this._options.domNodeSelectorPrefix);\n            if ('window' in $.global) domNodes.window = $($.global.window);\n            if ('document' in $.global) domNodes.document = $($.global.document);\n            return domNodes;\n        }\n        // / endregion\n        // / region scope\n        /**\n         * Overwrites all inherited variables from parent scope with \"undefined\".\n         * @param scope - A scope where inherited names will be removed.\n         * @param prefixesToIgnore - Name prefixes to ignore during deleting names\n         * in given scope.\n         * @returns The isolated scope.\n         */\n\n    }, {\n        key: 'getMethod',\n\n        // / endregion\n        // / region function\n        /**\n         * Methods given by this method has the plugin scope referenced with\n         * \"this\". Otherwise \"this\" usually points to the object the given method\n         * was attached to. If \"method\" doesn't match string arguments are passed\n         * through a wrapper function with \"context\" setted as \"scope\" or \"this\" if\n         * nothing is provided.\n         * @param method - A method name of given scope.\n         * @param scope - A given scope.\n         * @param additionalArguments - A list of additional arguments to forward\n         * to given function, when it should be called.\n         * @returns Returns the given methods return value.\n         */\n        value: function getMethod(method) {\n            for (var _len7 = arguments.length, additionalArguments = Array(_len7 > 2 ? _len7 - 2 : 0), _key8 = 2; _key8 < _len7; _key8++) {\n                additionalArguments[_key8 - 2] = arguments[_key8];\n            }\n\n            var scope = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n            /*\n                This following outcomment line would be responsible for a bug in\n                yuicompressor. Because of declaration of arguments the parser\n                things that arguments is a local variable and could be renamed. It\n                doesn't care about that the magic arguments object is necessary to\n                generate the arguments array in this context.\n                 var arguments = this.constructor.arrayMake(arguments)\n            */\n            if (!scope) scope = this;\n            if (typeof method === 'string' && (typeof scope === 'undefined' ? 'undefined' : _typeof(scope)) === 'object') return function () {\n                if (!scope[method] && typeof method === 'string') throw Error('Method \"' + method + '\" doesn\\'t exists in \"' + scope + '\".');\n                return scope[method].apply(scope, additionalArguments.concat(this.constructor.arrayMake(arguments)));\n            };\n            var self = this;\n            return function () {\n                // IgnoreTypeCheck\n                return method.apply(scope, self.constructor.arrayMake(arguments).concat(additionalArguments));\n            };\n        }\n        /**\n         * Implements the identity function.\n         * @param value - A value to return.\n         * @returns Returns the given value.\n         */\n\n    }, {\n        key: 'fireEvent',\n\n        /**\n         * Searches for internal event handler methods and runs them by default. In\n         * addition this method searches for a given event method by the options\n         * object. Additional arguments are forwarded to respective event\n         * functions.\n         * @param eventName - An event name.\n         * @param callOnlyOptionsMethod - Prevents from trying to call an internal\n         * event handler.\n         * @param scope - The scope from where the given event handler should be\n         * called.\n         * @param additionalArguments - Additional arguments to forward to\n         * corresponding event handlers.\n         * @returns - Returns \"true\" if an options event handler was called and\n         * \"false\" otherwise.\n         */\n        value: function fireEvent(eventName) {\n            var callOnlyOptionsMethod = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n            var scope = arguments.length <= 2 || arguments[2] === undefined ? this : arguments[2];\n\n            var eventHandlerName = 'on' + this.constructor.stringCapitalize(eventName);\n\n            for (var _len8 = arguments.length, additionalArguments = Array(_len8 > 3 ? _len8 - 3 : 0), _key9 = 3; _key9 < _len8; _key9++) {\n                additionalArguments[_key9 - 3] = arguments[_key9];\n            }\n\n            if (!callOnlyOptionsMethod) if (eventHandlerName in scope) scope[eventHandlerName].apply(scope, additionalArguments);else if ('_' + eventHandlerName in scope) scope['_' + eventHandlerName].apply(scope, additionalArguments);\n            if (scope._options && eventHandlerName in scope._options) {\n                scope._options[eventHandlerName].apply(scope, additionalArguments);\n                return true;\n            }\n            return false;\n        }\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * A wrapper method for \"$.on()\". It sets current plugin name as event\n         * scope if no scope is given. Given arguments are modified and passed\n         * through \"$.on()\".\n         * @returns Returns $'s grabbed dom node.\n         */\n\n    }, {\n        key: 'on',\n        value: function on() {\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            return this._bindEventHelper(arguments, false);\n        }\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * A wrapper method fo \"$.off()\". It sets current plugin name as event\n         * scope if no scope is given. Given arguments are modified and passed\n         * through \"$.off()\".\n         * @returns Returns $'s grabbed dom node.\n         */\n\n    }, {\n        key: 'off',\n        value: function off() {\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            return this._bindEventHelper(arguments, true, 'off');\n        }\n        // / endregion\n        // / region object\n        /**\n         * Determine the internal JavaScript [[Class]] of an object.\n         * @param object - Object to analyze.\n         * @returns Name of determined class.\n         */\n\n    }, {\n        key: 'normalizeDomNodeSelector',\n\n        /**\n         * Converts a dom selector to a prefixed dom selector string.\n         * @param selector - A dom node selector.\n         * @returns Returns given selector prefixed.\n         */\n        value: function normalizeDomNodeSelector(selector) {\n            var domNodeSelectorPrefix = '';\n            if (this._options.domNodeSelectorPrefix) domNodeSelectorPrefix = this._options.domNodeSelectorPrefix + ' ';\n            if (!(selector.startsWith(domNodeSelectorPrefix) || selector.trim().startsWith('<'))) selector = domNodeSelectorPrefix + selector;\n            return selector.trim();\n        }\n        // / endregion\n        // / region number\n        /**\n         * Checks if given object is java scripts native \"Number.NaN\" object.\n         * @param object - Object to Check.\n         * @returns Returns whether given value is not a number or not.\n         */\n\n    }, {\n        key: 'sendToExternalURL',\n\n        /**\n         * Send given data to a temporary created iframe.\n         * @param url - URL to send to data to.\n         * @param data - Data holding object to send data to.\n         * @param requestType - The forms action attribute value. If nothing is\n         * provided \"post\" will be used as default.\n         * @param removeAfterLoad - Indicates if created iframe should be removed\n         * right after load event.\n         * @returns Returns the dynamically created iframe.\n         */\n        value: function sendToExternalURL(url, data) {\n            var requestType = arguments.length <= 2 || arguments[2] === undefined ? 'post' : arguments[2];\n            var removeAfterLoad = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n            var $iFrameDomNode = $('<iframe>').attr('name', this.constructor._name.charAt(0).toLowerCase() + this.constructor._name.substring(1) + new Date().getTime()).hide();\n            this.$domNode.after($iFrameDomNode);\n            return this.constructor.sendToIFrame($iFrameDomNode, url, data, requestType, removeAfterLoad);\n        }\n        // / endregion\n        // endregion\n        // region protected\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Helper method for attach event handler methods and their event handler\n         * remove pendants.\n         * @param parameter - Arguments object given to methods like \"bind()\" or\n         * \"unbind()\".\n         * @param removeEvent - Indicates if \"unbind()\" or \"bind()\" was given.\n         * @param eventFunctionName - Name of function to wrap.\n         * @returns Returns $'s wrapped dom node.\n         */\n\n    }, {\n        key: '_bindEventHelper',\n        value: function _bindEventHelper(parameter) {\n            var removeEvent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n            var eventFunctionName = arguments.length <= 2 || arguments[2] === undefined ? 'on' : arguments[2];\n\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            var $domNode = $(parameter[0]);\n            if (this.constructor.determineType(parameter[1]) === 'object' && !removeEvent) {\n                for (var eventType in parameter[1]) {\n                    if (parameter[1].hasOwnProperty(eventType))\n                        // IgnoreTypeCheck\n                        this[eventFunctionName]($domNode, eventType, parameter[1][eventType]);\n                }return $domNode;\n            }\n            parameter = this.constructor.arrayMake(parameter).slice(1);\n            if (parameter.length === 0) parameter.push('');\n            if (!parameter[0].includes('.')) parameter[0] += '.' + this.constructor._name;\n            if (removeEvent) return $domNode[eventFunctionName].apply($domNode, parameter);\n            return $domNode[eventFunctionName].apply($domNode, parameter);\n        }\n        // endregion\n\n    }], [{\n        key: 'isNumeric',\n        value: function isNumeric(object) {\n            var type = Tools.determineType(object);\n            /*\n                NOTE: \"parseFloat\" \"NaNs\" numeric-cast false positives (\"\") but\n                misinterprets leading-number strings, particularly hex literals\n                (\"0x...\") subtraction forces infinities to NaN.\n            */\n            return ['number', 'string'].includes(type) && !isNaN(object - parseFloat(object));\n        }\n        /**\n         * Determine whether the argument is a window.\n         * @param object - Object to check for.\n         * @returns Boolean value indicating the result.\n         */\n\n    }, {\n        key: 'isWindow',\n        value: function isWindow(object) {\n            return ![undefined, null].includes(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && 'window' in object && object === object.window;\n        }\n        /**\n         * Checks if given object is similar to an array and can be handled like an\n         * array.\n         * @param object - Object to check behavior for.\n         * @returns A boolean value indicating whether given object is array like.\n         */\n\n    }, {\n        key: 'isArrayLike',\n        value: function isArrayLike(object) {\n            var length = void 0;\n            try {\n                length = Boolean(object) && 'length' in object && object.length;\n            } catch (error) {\n                return false;\n            }\n            var type = Tools.determineType(object);\n            if (type === 'function' || Tools.isWindow(object)) return false;\n            if (type === 'array' || length === 0) return true;\n            if (typeof length === 'number' && length > 0) try {\n                /* eslint-disable no-unused-expressions */\n                object[length - 1];\n                /* eslint-enable no-unused-expressions */\n                return true;\n            } catch (error) {}\n            return false;\n        }\n        /**\n         * Checks whether one of the given pattern matches given string.\n         * @param target - Target to check in pattern for.\n         * @param pattern - List of pattern to check for.\n         * @returns Value \"true\" if given object is matches by at leas one of the\n         * given pattern and \"false\" otherwise.\n         */\n\n    }, {\n        key: 'isAnyMatching',\n        value: function isAnyMatching(target, pattern) {\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = pattern[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var currentPattern = _step5.value;\n\n                    if (typeof currentPattern === 'string') {\n                        if (currentPattern === target) return true;\n                    } else if (currentPattern.test(target)) return true;\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            return false;\n        }\n        /**\n         * Checks whether given object is a plain native object.\n         * @param object - Object to check.\n         * @returns Value \"true\" if given object is a plain javaScript object and\n         * \"false\" otherwise.\n         */\n\n    }, {\n        key: 'isPlainObject',\n        value: function isPlainObject(object) {\n            return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && Object.getPrototypeOf(object) === Object.prototype;\n        }\n        /**\n         * Checks whether given object is a function.\n         * @param object - Object to check.\n         * @returns Value \"true\" if given object is a function and \"false\"\n         * otherwise.\n         */\n\n    }, {\n        key: 'isFunction',\n        value: function isFunction(object) {\n            return Boolean(object) && {}.toString.call(object) === '[object Function]';\n        }\n        // / endregion\n        // / region language fixes\n        /**\n         * This method fixes an ugly javaScript bug. If you add a mouseout event\n         * listener to a dom node the given handler will be called each time any\n         * dom node inside the observed dom node triggers a mouseout event. This\n         * methods guarantees that the given event handler is only called if the\n         * observed dom node was leaved.\n         * @param eventHandler - The mouse out event handler.\n         * @returns Returns the given function wrapped by the workaround logic.\n         */\n\n    }, {\n        key: 'mouseOutEventHandlerFix',\n        value: function mouseOutEventHandlerFix(eventHandler) {\n            var self = this;\n            return function (event) {\n                var relatedTarget = event.toElement;\n                if ('relatedTarget' in event) relatedTarget = event.relatedTarget;\n                while (relatedTarget && relatedTarget.tagName !== 'BODY') {\n                    if (relatedTarget === this) return;\n                    relatedTarget = relatedTarget.parentNode;\n                }\n                return eventHandler.apply(self, arguments);\n            };\n        }\n    }, {\n        key: 'show',\n        value: function show(object) {\n            var level = arguments.length <= 1 || arguments[1] === undefined ? 3 : arguments[1];\n            var currentLevel = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n            var output = '';\n            if (Tools.determineType(object) === 'object') {\n                for (var _key10 in object) {\n                    if (object.hasOwnProperty(_key10)) {\n                        output += _key10.toString() + ': ';\n                        if (currentLevel <= level) output += Tools.show(object[_key10], level, currentLevel + 1);else output += '' + object[_key10];\n                        output += '\\n';\n                    }\n                }return output.trim();\n            }\n            output = ('' + object).trim();\n            return output + ' (Type: \"' + Tools.determineType(object) + '\")';\n        }\n    }, {\n        key: 'isEquivalentDom',\n        value: function isEquivalentDom(first, second) {\n            var forceHTMLString = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n            if (first === second) return true;\n            if (first && second) {\n                var detemermineHTMLPattern = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\n                var inputs = { first: first, second: second };\n                var $domNodes = {\n                    first: $('<dummy>'), second: $('<dummy>')\n                };\n                /*\n                    NOTE: Assume that strings that start \"<\" and end with \">\" are\n                    markup and skip the more expensive regular expression check.\n                */\n                var _arr2 = ['first', 'second'];\n                for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n                    var type = _arr2[_i2];\n                    if (typeof inputs[type] === 'string' && (forceHTMLString || inputs[type].startsWith('<') && inputs[type].endsWith('>') && inputs[type].length >= 3 || detemermineHTMLPattern.test(inputs[type]))) $domNodes[type] = $('<div>' + inputs[type] + '</div>');else try {\n                        var $selectedDomNode = $(inputs[type]);\n                        if ($selectedDomNode.length) $domNodes[type] = $('<div>').append($selectedDomNode.clone());else return false;\n                    } catch (error) {\n                        return false;\n                    }\n                }if ($domNodes.first.length && $domNodes.first.length === $domNodes.second.length) {\n                    $domNodes.first = $domNodes.first.Tools('normalizeClassNames').$domNode.Tools('normalizeStyles').$domNode;\n                    $domNodes.second = $domNodes.second.Tools('normalizeClassNames').$domNode.Tools('normalizeStyles').$domNode;\n                    var index = 0;\n                    var _iteratorNormalCompletion6 = true;\n                    var _didIteratorError6 = false;\n                    var _iteratorError6 = undefined;\n\n                    try {\n                        for (var _iterator6 = $domNodes.first[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                            var _domNode = _step6.value;\n\n                            if (!_domNode.isEqualNode($domNodes.second[index])) return false;\n                        }\n                    } catch (err) {\n                        _didIteratorError6 = true;\n                        _iteratorError6 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                _iterator6.return();\n                            }\n                        } finally {\n                            if (_didIteratorError6) {\n                                throw _iteratorError6;\n                            }\n                        }\n                    }\n\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'generateDirectiveSelector',\n        value: function generateDirectiveSelector(directiveName) {\n            var delimitedName = Tools.stringCamelCaseToDelimited(directiveName);\n            return delimitedName + ', .' + delimitedName + ', [' + delimitedName + '], ' + ('[data-' + delimitedName + '], [x-' + delimitedName + ']') + (delimitedName.includes('-') ? ', [' + delimitedName.replace(/-/g, '\\\\:') + '], ' + ('[' + delimitedName.replace(/-/g, '_') + ']') : '');\n        }\n    }, {\n        key: 'getNormalizedDirectiveName',\n        value: function getNormalizedDirectiveName(directiveName) {\n            var _arr3 = ['-', ':', '_'];\n\n            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n                var delimiter = _arr3[_i3];\n                var prefixFound = false;\n                var _arr5 = ['data' + delimiter, 'x' + delimiter];\n                for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n                    var prefix = _arr5[_i5];\n                    if (directiveName.startsWith(prefix)) {\n                        directiveName = directiveName.substring(prefix.length);\n                        prefixFound = true;\n                        break;\n                    }\n                }if (prefixFound) break;\n            }\n            var _arr4 = ['-', ':', '_'];\n            for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n                var _delimiter = _arr4[_i4];\n                directiveName = Tools.stringDelimitedToCamelCase(directiveName, _delimiter);\n            }return directiveName;\n        }\n    }, {\n        key: 'getDomNodeName',\n        value: function getDomNodeName(domNodeSelector) {\n            var match = domNodeSelector.match(new RegExp('^<?([a-zA-Z]+).*>?.*'));\n            if (match) return match[1];\n            return null;\n        }\n    }, {\n        key: 'isolateScope',\n        value: function isolateScope(scope) {\n            var prefixesToIgnore = arguments.length <= 1 || arguments[1] === undefined ? ['$', '_'] : arguments[1];\n\n            for (var _name3 in scope) {\n                if (!(prefixesToIgnore.includes(_name3.charAt(0)) || ['this', 'constructor'].includes(_name3) || scope.hasOwnProperty(_name3)))\n                    /*\n                        NOTE: Delete (\"delete $scope[name]\") doesn't destroy the\n                        automatic lookup to parent scope.\n                    */\n                    scope[_name3] = undefined;\n            }return scope;\n        }\n        /**\n         * Generates a unique name in given scope (usefull for jsonp requests).\n         * @param prefix - A prefix which will be preprended to uniqe name.\n         * @param suffix - A suffix which will be preprended to uniqe name.\n         * @param scope - A scope where the name should be unique.\n         * @param initialUniqueName - An initial scope name to use if not exists.\n         * @returns The function name.\n         */\n\n    }, {\n        key: 'determineUniqueScopeName',\n        value: function determineUniqueScopeName() {\n            var prefix = arguments.length <= 0 || arguments[0] === undefined ? 'callback' : arguments[0];\n            var suffix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n            var scope = arguments.length <= 2 || arguments[2] === undefined ? $.global : arguments[2];\n            var initialUniqueName = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];\n\n            if (initialUniqueName.length && !(initialUniqueName in scope)) return initialUniqueName;\n            var uniqueName = prefix + suffix;\n            while (true) {\n                uniqueName = prefix + parseInt(Math.random() * Math.pow(10, 10), 10) + suffix;\n                if (!(uniqueName in scope)) break;\n            }\n            return uniqueName;\n        }\n    }, {\n        key: 'identity',\n        value: function identity(value) {\n            return value;\n        }\n        /**\n         * Inverted filter helper to inverse each given filter.\n         * @param filter - A function that filters an array.\n         * @returns The inverted filter.\n         */\n\n    }, {\n        key: 'invertArrayFilter',\n        value: function invertArrayFilter(filter) {\n            return function (data) {\n                if (data) {\n                    var filteredData = filter.apply(this, arguments);\n                    var result = [];\n                    /* eslint-disable curly */\n                    if (filteredData.length) {\n                        var _iteratorNormalCompletion7 = true;\n                        var _didIteratorError7 = false;\n                        var _iteratorError7 = undefined;\n\n                        try {\n                            for (var _iterator7 = data[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                                var date = _step7.value;\n\n                                if (!filteredData.includes(date)) result.push(date);\n                            }\n                        } catch (err) {\n                            _didIteratorError7 = true;\n                            _iteratorError7 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                    _iterator7.return();\n                                }\n                            } finally {\n                                if (_didIteratorError7) {\n                                    throw _iteratorError7;\n                                }\n                            }\n                        }\n                    } else\n                        /* eslint-enable curly */\n                        result = data;\n                    return result;\n                }\n                return data;\n            };\n        }\n        // / endregion\n        // / region event\n        /**\n         * Prevents event functions from triggering to often by defining a minimal\n         * span between each function call. Additional arguments given to this\n         * function will be forwarded to given event function call. The function\n         * wrapper returns null if current function will be omitted due to\n         * debounceing.\n         * @param eventFunction - The function to call debounced.\n         * @param thresholdInMilliseconds - The minimum time span between each\n         * function call.\n         * @param additionalArguments - Additional arguments to forward to given\n         * function.\n         * @returns Returns the wrapped method.\n         */\n\n    }, {\n        key: 'debounce',\n        value: function debounce(eventFunction) {\n            for (var _len9 = arguments.length, additionalArguments = Array(_len9 > 2 ? _len9 - 2 : 0), _key11 = 2; _key11 < _len9; _key11++) {\n                additionalArguments[_key11 - 2] = arguments[_key11];\n            }\n\n            var thresholdInMilliseconds = arguments.length <= 1 || arguments[1] === undefined ? 600 : arguments[1];\n\n            var lock = false;\n            var waitingCallArguments = null;\n            var timeoutID = null;\n            return function () {\n                var _this2 = this;\n\n                var parameter = Tools.arrayMake(arguments);\n                if (lock) waitingCallArguments = parameter.concat(additionalArguments || []);else {\n                    lock = true;\n                    timeoutID = setTimeout(function () {\n                        lock = false;\n                        if (waitingCallArguments) {\n                            eventFunction.apply(_this2, waitingCallArguments);\n                            waitingCallArguments = null;\n                        }\n                    }, thresholdInMilliseconds);\n                    eventFunction.apply(this, parameter.concat(additionalArguments || []));\n                }\n                return timeoutID;\n            };\n        }\n    }, {\n        key: 'determineType',\n        value: function determineType() {\n            var object = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\n            if ([undefined, null].includes(object)) return '' + object;\n            if (['object', 'function'].includes(typeof object === 'undefined' ? 'undefined' : _typeof(object)) && 'toString' in object) {\n                var stringRepresentation = Tools.classToTypeMapping.toString.call(object);\n                if (Tools.classToTypeMapping.hasOwnProperty(stringRepresentation)) return Tools.classToTypeMapping[stringRepresentation];\n            }\n            return typeof object === 'undefined' ? 'undefined' : _typeof(object);\n        }\n        /**\n         * Replaces given pattern in each value in given object recursively with\n         * given string replacement.\n         * @param object - Object to convert substrings in.\n         * @param pattern - Regular expression to replace.\n         * @param replacement - String to use as replacement for found patterns.\n         * @returns Converted object with replaced patterns.\n         */\n\n    }, {\n        key: 'convertSubstringInPlainObject',\n        value: function convertSubstringInPlainObject(object, pattern, replacement) {\n            for (var _key12 in object) {\n                if (object.hasOwnProperty(_key12)) if (Tools.isPlainObject(object[_key12])) object[_key12] = Tools.convertSubstringInPlainObject(object[_key12], pattern, replacement);else if (typeof object[_key12] === 'string') object[_key12] = object[_key12].replace(pattern, replacement);\n            }return object;\n        }\n        /**\n         * Modifies given target corresponding to given source and removes source\n         * modification infos.\n         * @param target - Object to modify.\n         * @param source - Source object to load modifications from.\n         * @param removeIndicatorKey - Indicator property name or value to mark a\n         * value to remove from object or list.\n         * @param prependIndicatorKey - Indicator property name to mark a value to\n         * prepend to target list.\n         * @param appendIndicatorKey - Indicator property name to mark a value to\n         * append to target list.\n         * @param parentSource - Source context to remove modification info from\n         * (usually only needed internally).\n         * @param parentKey - Source key in given source context to remove\n         * modification info from (usually only needed internally).\n         * @return Given target modified with given source.\n         */\n\n    }, {\n        key: 'modifyObject',\n        value: function modifyObject(target, source) {\n            var removeIndicatorKey = arguments.length <= 2 || arguments[2] === undefined ? '__remove__' : arguments[2];\n            var prependIndicatorKey = arguments.length <= 3 || arguments[3] === undefined ? '__prepend__' : arguments[3];\n            var appendIndicatorKey = arguments.length <= 4 || arguments[4] === undefined ? '__append__' : arguments[4];\n            var parentSource = arguments.length <= 5 || arguments[5] === undefined ? null : arguments[5];\n            var parentKey = arguments.length <= 6 || arguments[6] === undefined ? null : arguments[6];\n\n            if (source instanceof Map && target instanceof Map) {\n                var _iteratorNormalCompletion8 = true;\n                var _didIteratorError8 = false;\n                var _iteratorError8 = undefined;\n\n                try {\n                    for (var _iterator8 = source[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                        var _step8$value = _slicedToArray(_step8.value, 2);\n\n                        var _key13 = _step8$value[0];\n                        var _value2 = _step8$value[1];\n\n                        if (target.has(_key13)) Tools.modifyObject(target.get(_key13), _value2, removeIndicatorKey, prependIndicatorKey, appendIndicatorKey, source, _key13);\n                    }\n                } catch (err) {\n                    _didIteratorError8 = true;\n                    _iteratorError8 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                            _iterator8.return();\n                        }\n                    } finally {\n                        if (_didIteratorError8) {\n                            throw _iteratorError8;\n                        }\n                    }\n                }\n            } else if (source !== null && (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object' && target !== null && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object') {\n                for (var _key14 in source) {\n                    if (source.hasOwnProperty(_key14)) if ([removeIndicatorKey, prependIndicatorKey, appendIndicatorKey].includes(_key14)) {\n                        var _iteratorNormalCompletion9 = true;\n                        var _didIteratorError9 = false;\n                        var _iteratorError9 = undefined;\n\n                        try {\n                            for (var _iterator9 = [].concat(source[_key14])[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                                var valueToModify = _step9.value;\n\n                                if (Array.isArray(target)) {\n                                    if (_key14 === removeIndicatorKey) {\n                                        if (target.includes(valueToModify)) target.splice(target.indexOf(valueToModify), 1);\n                                    } else if (_key14 === prependIndicatorKey) target.unshift(valueToModify);else target.push(valueToModify);\n                                } else if (_key14 === removeIndicatorKey && target.hasOwnProperty(valueToModify)) delete target[valueToModify];\n                            }\n                        } catch (err) {\n                            _didIteratorError9 = true;\n                            _iteratorError9 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                                    _iterator9.return();\n                                }\n                            } finally {\n                                if (_didIteratorError9) {\n                                    throw _iteratorError9;\n                                }\n                            }\n                        }\n\n                        delete source[_key14];\n                        if (parentSource && parentKey) delete parentSource[parentKey];\n                    } else if (target !== null && target.hasOwnProperty(_key14)) Tools.modifyObject(target[_key14], source[_key14], removeIndicatorKey, prependIndicatorKey, appendIndicatorKey, source, _key14);\n                }\n            }\n            return target;\n        }\n        /**\n         * Extends given target object with given sources object. As target and\n         * sources many expandable types are allowed but target and sources have to\n         * to come from the same type.\n         * @param targetOrDeepIndicator - Maybe the target or deep indicator.\n         * @param _targetAndOrSources - Target and at least one source object.\n         * @returns Returns given target extended with all given sources.\n         */\n\n    }, {\n        key: 'extendObject',\n        value: function extendObject(targetOrDeepIndicator) {\n            for (var _len10 = arguments.length, _targetAndOrSources = Array(_len10 > 1 ? _len10 - 1 : 0), _key15 = 1; _key15 < _len10; _key15++) {\n                _targetAndOrSources[_key15 - 1] = arguments[_key15];\n            }\n\n            var index = 1;\n            var deep = false;\n            var target = void 0;\n            if (typeof targetOrDeepIndicator === 'boolean') {\n                // Handle a deep copy situation and skip deep indicator and target.\n                deep = targetOrDeepIndicator;\n                target = arguments[index];\n                index = 2;\n            } else target = targetOrDeepIndicator;\n            var mergeValue = function mergeValue(key, value, targetValue) {\n                if (value === targetValue) return targetValue;\n                // Recurse if we're merging plain objects or maps.\n                if (deep && value && (Tools.isPlainObject(value) || value instanceof Map)) {\n                    var clone = void 0;\n                    if (value instanceof Map) clone = targetValue && targetValue instanceof Map ? targetValue : new Map();else clone = targetValue && Tools.isPlainObject(targetValue) ? targetValue : {};\n                    return Tools.extendObject(deep, clone, value);\n                }\n                return value;\n            };\n            while (index < arguments.length) {\n                var source = arguments[index];\n                var targetType = typeof target === 'undefined' ? 'undefined' : _typeof(target);\n                var sourceType = typeof source === 'undefined' ? 'undefined' : _typeof(source);\n                if (target instanceof Map) targetType += ' Map';\n                if (source instanceof Map) sourceType += ' Map';\n                if (targetType === sourceType && target !== source) {\n                    if (target instanceof Map && source instanceof Map) {\n                        var _iteratorNormalCompletion10 = true;\n                        var _didIteratorError10 = false;\n                        var _iteratorError10 = undefined;\n\n                        try {\n                            for (var _iterator10 = source[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                                var _step10$value = _slicedToArray(_step10.value, 2);\n\n                                var _key16 = _step10$value[0];\n                                var _value3 = _step10$value[1];\n\n                                target.set(_key16, mergeValue(_key16, _value3, target.get(_key16)));\n                            }\n                        } catch (err) {\n                            _didIteratorError10 = true;\n                            _iteratorError10 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                                    _iterator10.return();\n                                }\n                            } finally {\n                                if (_didIteratorError10) {\n                                    throw _iteratorError10;\n                                }\n                            }\n                        }\n                    } else if (target !== null && !Array.isArray(target) && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && source !== null && !Array.isArray(source) && (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object') {\n                        for (var _key17 in source) {\n                            if (source.hasOwnProperty(_key17)) target[_key17] = mergeValue(_key17, source[_key17], target[_key17]);\n                        }\n                    } else target = source;\n                } else target = source;\n                index += 1;\n            }\n            return target;\n        }\n        /**\n         * Removes a proxies from given data structure recursivley.\n         * @param object - Object to proxy.\n         * @param seenObjects - Tracks all already processed obejcts to avoid\n         * endless loops (usually only needed for internal prupose).\n         * @returns Returns given object unwrapped from a dynamic proxy.\n         */\n\n    }, {\n        key: 'unwrapProxy',\n        value: function unwrapProxy(object) {\n            var seenObjects = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n            if (object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object') {\n                while (object.__target__) {\n                    object = object.__target__;\n                }var index = seenObjects.indexOf(object);\n                if (index !== -1) return seenObjects[index];\n                seenObjects.push(object);\n                if (Array.isArray(object)) {\n                    var _index = 0;\n                    var _iteratorNormalCompletion11 = true;\n                    var _didIteratorError11 = false;\n                    var _iteratorError11 = undefined;\n\n                    try {\n                        for (var _iterator11 = object[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                            var _value4 = _step11.value;\n\n                            object[_index] = Tools.unwrapProxy(_value4, seenObjects);\n                            _index += 1;\n                        }\n                    } catch (err) {\n                        _didIteratorError11 = true;\n                        _iteratorError11 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                                _iterator11.return();\n                            }\n                        } finally {\n                            if (_didIteratorError11) {\n                                throw _iteratorError11;\n                            }\n                        }\n                    }\n                } else if (object instanceof Map) {\n                    var _iteratorNormalCompletion12 = true;\n                    var _didIteratorError12 = false;\n                    var _iteratorError12 = undefined;\n\n                    try {\n                        for (var _iterator12 = object[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                            var _step12$value = _slicedToArray(_step12.value, 2);\n\n                            var _key18 = _step12$value[0];\n                            var _value5 = _step12$value[1];\n\n                            object.set(_key18, Tools.unwrapProxy(_value5, seenObjects));\n                        }\n                    } catch (err) {\n                        _didIteratorError12 = true;\n                        _iteratorError12 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                                _iterator12.return();\n                            }\n                        } finally {\n                            if (_didIteratorError12) {\n                                throw _iteratorError12;\n                            }\n                        }\n                    }\n                } else for (var _key19 in object) {\n                    if (object.hasOwnProperty(_key19)) object[_key19] = Tools.unwrapProxy(object[_key19], seenObjects);\n                }\n            }\n            return object;\n        }\n        /**\n         * Adds dynamic getter and setter to any given data structure such as maps.\n         * @param object - Object to proxy.\n         * @param getterWrapper - Function to wrap each property get.\n         * @param setterWrapper - Function to wrap each property set.\n         * @param getterMethodName - Method name to get a stored value by key.\n         * @param setterMethodName - Method name to set a stored value by key.\n         * @param containesMethodName - Method name to indicate if a key is stored\n         * in given data structure.\n         * @param deep - Indicates to perform a deep wrapping of specified types.\n         * performed via \"value instanceof type\".).\n         * @param typesToExtend - Types which should be extended (Checks are\n         * performed via \"value instanceof type\".).\n         * @returns Returns given object wrapped with a dynamic getter proxy.\n         */\n\n    }, {\n        key: 'addDynamicGetterAndSetter',\n        value: function addDynamicGetterAndSetter(object) {\n            var getterWrapper = arguments.length <= 1 || arguments[1] === undefined ? function (value) {\n                return value;\n            } : arguments[1];\n            var setterWrapper = arguments.length <= 2 || arguments[2] === undefined ? function (key, value) {\n                return value;\n            } : arguments[2];\n            var getterMethodName = arguments.length <= 3 || arguments[3] === undefined ? '[]' : arguments[3];\n            var setterMethodName = arguments.length <= 4 || arguments[4] === undefined ? '[]' : arguments[4];\n            var containesMethodName = arguments.length <= 5 || arguments[5] === undefined ? 'hasOwnProperty' : arguments[5];\n            var deep = arguments.length <= 6 || arguments[6] === undefined ? true : arguments[6];\n            var typesToExtend = arguments.length <= 7 || arguments[7] === undefined ? [Object] : arguments[7];\n\n            if (deep) if (object instanceof Map) {\n                var _iteratorNormalCompletion13 = true;\n                var _didIteratorError13 = false;\n                var _iteratorError13 = undefined;\n\n                try {\n                    for (var _iterator13 = object[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                        var _step13$value = _slicedToArray(_step13.value, 2);\n\n                        var _key20 = _step13$value[0];\n                        var _value6 = _step13$value[1];\n\n                        object.set(_key20, Tools.addDynamicGetterAndSetter(_value6, getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend));\n                    }\n                } catch (err) {\n                    _didIteratorError13 = true;\n                    _iteratorError13 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                            _iterator13.return();\n                        }\n                    } finally {\n                        if (_didIteratorError13) {\n                            throw _iteratorError13;\n                        }\n                    }\n                }\n            } else if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null) {\n                for (var _key21 in object) {\n                    if (object.hasOwnProperty(_key21)) object[_key21] = Tools.addDynamicGetterAndSetter(object[_key21], getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend);\n                }\n            } else if (Array.isArray(object)) {\n                var index = 0;\n                var _iteratorNormalCompletion14 = true;\n                var _didIteratorError14 = false;\n                var _iteratorError14 = undefined;\n\n                try {\n                    for (var _iterator14 = object[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                        var _value7 = _step14.value;\n\n                        object[index] = Tools.addDynamicGetterAndSetter(_value7, getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend);\n                        index += 1;\n                    }\n                } catch (err) {\n                    _didIteratorError14 = true;\n                    _iteratorError14 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                            _iterator14.return();\n                        }\n                    } finally {\n                        if (_didIteratorError14) {\n                            throw _iteratorError14;\n                        }\n                    }\n                }\n            }\n            var _iteratorNormalCompletion15 = true;\n            var _didIteratorError15 = false;\n            var _iteratorError15 = undefined;\n\n            try {\n                for (var _iterator15 = typesToExtend[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                    var type = _step15.value;\n\n                    if (object instanceof type) {\n                        if (object.__target__) return object;\n                        var handler = {};\n                        if (containesMethodName) handler.has = function (target, name) {\n                            if (containesMethodName === '[]') return name in target;\n                            return target[containesMethodName](name);\n                        };\n                        if (containesMethodName && getterMethodName) handler.get = function (target, name) {\n                            if (name === '__target__') return target;\n                            if (typeof target[name] === 'function') return target[name].bind(target);\n                            if (target[containesMethodName](name)) {\n                                if (getterMethodName === '[]') return getterWrapper(target[name]);\n                                return getterWrapper(target[getterMethodName](name));\n                            }\n                            return target[name];\n                        };\n                        if (setterMethodName) handler.set = function (target, name, value) {\n                            if (setterMethodName === '[]') target[name] = setterWrapper(name, value);else target[setterMethodName](name, setterWrapper(name, value));\n                        };\n                        // IgnoreTypeCheck\n                        return new Proxy(object, handler);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError15 = true;\n                _iteratorError15 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion15 && _iterator15.return) {\n                        _iterator15.return();\n                    }\n                } finally {\n                    if (_didIteratorError15) {\n                        throw _iteratorError15;\n                    }\n                }\n            }\n\n            return object;\n        }\n        /**\n         * Searches for nested mappings with given indicator key and resolves\n         * marked values. Additionally all objects are wrapped with a proxy to\n         * dynamically resolve nested properties.\n         * @param object - Given mapping to resolve.\n         * @param parameterDescription - Array of scope names.\n         * @param parameter - Array of values for given scope names. If there is\n         * one missing given object will be added.\n         * @param deep - Indicates whether to perform a recursive resolving.\n         * @param evaluationIndicatorKey - Indicator property name to mark a value\n         * to evaluate.\n         * @param executionIndicatorKey - Indicator property name to mark a value\n         * to evaluate.\n         * @returns Evaluated given mapping.\n         */\n\n    }, {\n        key: 'resolveDynamicDataStructure',\n        value: function resolveDynamicDataStructure(object) {\n            var parameterDescription = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n            var parameter = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n            var deep = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n            var evaluationIndicatorKey = arguments.length <= 4 || arguments[4] === undefined ? '__evaluate__' : arguments[4];\n            var executionIndicatorKey = arguments.length <= 5 || arguments[5] === undefined ? '__execute__' : arguments[5];\n\n            if (object === null || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') return object;\n            var configuration = object;\n            if (deep && configuration && !configuration.__target__) configuration = Tools.addDynamicGetterAndSetter(Tools.copyLimitedRecursively(object), function (value) {\n                return Tools.resolveDynamicDataStructure(value, parameterDescription, parameter, false, evaluationIndicatorKey, executionIndicatorKey);\n            }, function (key, value) {\n                return value;\n            }, '[]', '');\n            if (parameterDescription.length > parameter.length) parameter.push(configuration);\n            if (Array.isArray(object) && deep) {\n                var index = 0;\n                var _iteratorNormalCompletion16 = true;\n                var _didIteratorError16 = false;\n                var _iteratorError16 = undefined;\n\n                try {\n                    for (var _iterator16 = object[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                        var _value8 = _step16.value;\n\n                        object[index] = Tools.resolveDynamicDataStructure(_value8, parameterDescription, parameter, deep, evaluationIndicatorKey, executionIndicatorKey);\n                        index += 1;\n                    }\n                } catch (err) {\n                    _didIteratorError16 = true;\n                    _iteratorError16 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion16 && _iterator16.return) {\n                            _iterator16.return();\n                        }\n                    } finally {\n                        if (_didIteratorError16) {\n                            throw _iteratorError16;\n                        }\n                    }\n                }\n            } else for (var _key22 in object) {\n                if (object.hasOwnProperty(_key22)) if ([evaluationIndicatorKey, executionIndicatorKey].includes(_key22)) try {\n                    return Tools.resolveDynamicDataStructure(new (\n                    // IgnoreTypeCheck\n                    Function.prototype.bind.apply(Function, [null].concat(parameterDescription).concat((_key22 === evaluationIndicatorKey ? 'return ' : '') + object[_key22])))().apply(null, parameter), parameterDescription, parameter, false, evaluationIndicatorKey, executionIndicatorKey);\n                } catch (error) {\n                    throw Error('Error during ' + (_key22 === evaluationIndicatorKey ? 'executing' : 'evaluating') + (' \"' + object[_key22] + '\": ' + error));\n                } else if (deep) object[_key22] = Tools.resolveDynamicDataStructure(object[_key22], parameterDescription, parameter, deep, evaluationIndicatorKey, executionIndicatorKey);\n            }return object;\n        }\n        /**\n         * Converts given object into its serialized json representation by\n         * replacing circular references with a given provided value.\n         * @param object - Object to serialize.\n         * @param determineCicularReferenceValue - Callback to create a fallback\n         * value depending on given redundant value.\n         * @param numberOfSpaces - Number of spaces to use for string formatting.\n         */\n\n    }, {\n        key: 'convertCircularObjectToJSON',\n        value: function convertCircularObjectToJSON(object) {\n            var determineCicularReferenceValue = arguments.length <= 1 || arguments[1] === undefined ? function () {\n                return '__circularReference__';\n            } : arguments[1];\n            var numberOfSpaces = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n            var seenObjects = [];\n            return JSON.stringify(object, function (key, value) {\n                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {\n                    if (seenObjects.includes(value)) return determineCicularReferenceValue(key, value, seenObjects);\n                    seenObjects.push(value);\n                    return value;\n                }\n                return value;\n            }, numberOfSpaces);\n        }\n        /**\n         * Converts given plain object and all nested found objects to\n         * corresponding map.\n         * @param object - Object to convert to.\n         * @param deep - Indicates whether to perform a recursive conversion.\n         * @returns Given object as map.\n         */\n\n    }, {\n        key: 'convertPlainObjectToMap',\n        value: function convertPlainObjectToMap(object) {\n            var deep = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n            if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && Tools.isPlainObject(object)) {\n                var newObject = new Map();\n                for (var _key23 in object) {\n                    if (object.hasOwnProperty(_key23)) {\n                        if (deep) object[_key23] = Tools.convertPlainObjectToMap(object[_key23], deep);\n                        newObject.set(_key23, object[_key23]);\n                    }\n                }return newObject;\n            }\n            if (deep) if (Array.isArray(object)) {\n                var index = 0;\n                var _iteratorNormalCompletion17 = true;\n                var _didIteratorError17 = false;\n                var _iteratorError17 = undefined;\n\n                try {\n                    for (var _iterator17 = object[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n                        var _value9 = _step17.value;\n\n                        object[index] = Tools.convertPlainObjectToMap(_value9, deep);\n                        index += 1;\n                    }\n                } catch (err) {\n                    _didIteratorError17 = true;\n                    _iteratorError17 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion17 && _iterator17.return) {\n                            _iterator17.return();\n                        }\n                    } finally {\n                        if (_didIteratorError17) {\n                            throw _iteratorError17;\n                        }\n                    }\n                }\n            } else if (object instanceof Map) {\n                var _iteratorNormalCompletion18 = true;\n                var _didIteratorError18 = false;\n                var _iteratorError18 = undefined;\n\n                try {\n                    for (var _iterator18 = object[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n                        var _step18$value = _slicedToArray(_step18.value, 2);\n\n                        var _key24 = _step18$value[0];\n                        var _value10 = _step18$value[1];\n\n                        object.set(_key24, Tools.convertPlainObjectToMap(_value10, deep));\n                    }\n                } catch (err) {\n                    _didIteratorError18 = true;\n                    _iteratorError18 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion18 && _iterator18.return) {\n                            _iterator18.return();\n                        }\n                    } finally {\n                        if (_didIteratorError18) {\n                            throw _iteratorError18;\n                        }\n                    }\n                }\n            }\n            return object;\n        }\n        /**\n         * Converts given map and all nested found maps objects to corresponding\n         * object.\n         * @param object - Map to convert to.\n         * @param deep - Indicates whether to perform a recursive conversion.\n         * @returns Given map as object.\n         */\n\n    }, {\n        key: 'convertMapToPlainObject',\n        value: function convertMapToPlainObject(object) {\n            var deep = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n            if (object instanceof Map) {\n                var newObject = {};\n                var _iteratorNormalCompletion19 = true;\n                var _didIteratorError19 = false;\n                var _iteratorError19 = undefined;\n\n                try {\n                    for (var _iterator19 = object[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n                        var _step19$value = _slicedToArray(_step19.value, 2);\n\n                        var _key25 = _step19$value[0];\n                        var _value11 = _step19$value[1];\n\n                        if (deep) _value11 = Tools.convertMapToPlainObject(_value11, deep);\n                        newObject['' + _key25] = _value11;\n                    }\n                } catch (err) {\n                    _didIteratorError19 = true;\n                    _iteratorError19 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion19 && _iterator19.return) {\n                            _iterator19.return();\n                        }\n                    } finally {\n                        if (_didIteratorError19) {\n                            throw _iteratorError19;\n                        }\n                    }\n                }\n\n                return newObject;\n            }\n            if (deep) if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && Tools.isPlainObject(object)) {\n                for (var _key26 in object) {\n                    if (object.hasOwnProperty(_key26)) object[_key26] = Tools.convertMapToPlainObject(object[_key26], deep);\n                }\n            } else if (Array.isArray(object)) {\n                var index = 0;\n                var _iteratorNormalCompletion20 = true;\n                var _didIteratorError20 = false;\n                var _iteratorError20 = undefined;\n\n                try {\n                    for (var _iterator20 = object[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n                        var _value12 = _step20.value;\n\n                        object[index] = Tools.convertMapToPlainObject(_value12, deep);\n                        index += 1;\n                    }\n                } catch (err) {\n                    _didIteratorError20 = true;\n                    _iteratorError20 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion20 && _iterator20.return) {\n                            _iterator20.return();\n                        }\n                    } finally {\n                        if (_didIteratorError20) {\n                            throw _iteratorError20;\n                        }\n                    }\n                }\n            }\n            return object;\n        }\n        /**\n         * Iterates given objects own properties in sorted fashion. For\n         * each key value pair given iterator function will be called with\n         * value and key as arguments.\n         * @param object - Object to iterate.\n         * @param iterator - Function to execute for each key value pair. Value\n         * will be the first and key will be the second argument.\n         * @param context - The \"this\" binding for given iterator function.\n         * @returns List of given sorted keys.\n         */\n\n    }, {\n        key: 'forEachSorted',\n        value: function forEachSorted(object, iterator, context) {\n            var keys = Tools.sort(object);\n            var _iteratorNormalCompletion21 = true;\n            var _didIteratorError21 = false;\n            var _iteratorError21 = undefined;\n\n            try {\n                for (var _iterator21 = keys[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n                    var _key27 = _step21.value;\n\n                    if (object instanceof Map) iterator.call(context, object.get(_key27), _key27);else if (Array.isArray(object) || object instanceof Object) iterator.call(context, object[_key27], _key27);\n                }\n            } catch (err) {\n                _didIteratorError21 = true;\n                _iteratorError21 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion21 && _iterator21.return) {\n                        _iterator21.return();\n                    }\n                } finally {\n                    if (_didIteratorError21) {\n                        throw _iteratorError21;\n                    }\n                }\n            }\n\n            return keys;\n        }\n        /**\n         * Sort given objects keys.\n         * @param object - Object which keys should be sorted.\n         * @returns Sorted list of given keys.\n         */\n\n    }, {\n        key: 'sort',\n        value: function sort(object) {\n            var keys = [];\n            if (Array.isArray(object)) for (var index = 0; index < object.length; index++) {\n                keys.push(index);\n            } else if (object instanceof Map) {\n                var _iteratorNormalCompletion22 = true;\n                var _didIteratorError22 = false;\n                var _iteratorError22 = undefined;\n\n                try {\n                    for (var _iterator22 = object[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n                        var _keyValuePair = _step22.value;\n\n                        keys.push(_keyValuePair[0]);\n                    }\n                } catch (err) {\n                    _didIteratorError22 = true;\n                    _iteratorError22 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion22 && _iterator22.return) {\n                            _iterator22.return();\n                        }\n                    } finally {\n                        if (_didIteratorError22) {\n                            throw _iteratorError22;\n                        }\n                    }\n                }\n            } else if (object instanceof Object) for (var _key28 in object) {\n                if (object.hasOwnProperty(_key28)) keys.push(_key28);\n            }return keys.sort();\n        }\n        /**\n         * Returns true if given items are equal for given property list. If\n         * property list isn't set all properties will be checked. All keys which\n         * starts with one of the exception prefixes will be omitted.\n         * @param firstValue - First object to compare.\n         * @param secondValue - Second object to compare.\n         * @param properties - Property names to check. Check all if \"null\" is\n         * selected (default).\n         * @param deep - Recursion depth negative values means infinitely deep\n         * (default).\n         * @param exceptionPrefixes - Property prefixes which indicates properties\n         * to ignore.\n         * @param ignoreFunctions - Indicates whether functions have to be\n         * identical to interpret is as equal. If set to \"true\" two functions will\n         * be assumed to be equal (default).\n         * @returns Value \"true\" if both objects are equal and \"false\" otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(firstValue, secondValue) {\n            var properties = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n            var deep = arguments.length <= 3 || arguments[3] === undefined ? -1 : arguments[3];\n            var exceptionPrefixes = arguments.length <= 4 || arguments[4] === undefined ? ['$', '_'] : arguments[4];\n            var ignoreFunctions = arguments.length <= 5 || arguments[5] === undefined ? true : arguments[5];\n\n            if (ignoreFunctions && Tools.isFunction(firstValue) && Tools.isFunction(secondValue) || firstValue === secondValue || Tools.numberIsNotANumber(firstValue) && Tools.numberIsNotANumber(secondValue) || firstValue instanceof RegExp && secondValue instanceof RegExp && firstValue.toString() === secondValue.toString() || firstValue instanceof Date && secondValue instanceof Date && (isNaN(firstValue.getTime()) && isNaN(secondValue.getTime()) || !isNaN(firstValue.getTime()) && !isNaN(secondValue.getTime()) && firstValue.getTime() === secondValue.getTime())) return true;\n            if (Tools.isPlainObject(firstValue) && Tools.isPlainObject(secondValue) && !(firstValue instanceof RegExp || secondValue instanceof RegExp) || Array.isArray(firstValue) && Array.isArray(secondValue) && firstValue.length === secondValue.length) {\n                var _arr6 = [[firstValue, secondValue], [secondValue, firstValue]];\n\n                for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n                    var _arr6$_i = _slicedToArray(_arr6[_i6], 2);\n\n                    var first = _arr6$_i[0];\n                    var second = _arr6$_i[1];\n\n                    var firstIsArray = Array.isArray(first);\n                    if (firstIsArray && !Array.isArray(second) || first.length !== second.length) return false;\n                    var equal = true;\n                    if (firstIsArray) {\n                        var index = 0;\n                        var _iteratorNormalCompletion23 = true;\n                        var _didIteratorError23 = false;\n                        var _iteratorError23 = undefined;\n\n                        try {\n                            for (var _iterator23 = first[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {\n                                var _value13 = _step23.value;\n\n                                if (deep !== 0 && !Tools.equals(_value13, second[index], properties, deep - 1, exceptionPrefixes)) equal = false;\n                                index += 1;\n                            }\n                        } catch (err) {\n                            _didIteratorError23 = true;\n                            _iteratorError23 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion23 && _iterator23.return) {\n                                    _iterator23.return();\n                                }\n                            } finally {\n                                if (_didIteratorError23) {\n                                    throw _iteratorError23;\n                                }\n                            }\n                        }\n                    } else for (var _key29 in first) {\n                        if (first.hasOwnProperty(_key29)) {\n                            if (!equal || properties && !properties.includes(_key29)) break;\n                            var doBreak = false;\n                            var _iteratorNormalCompletion24 = true;\n                            var _didIteratorError24 = false;\n                            var _iteratorError24 = undefined;\n\n                            try {\n                                for (var _iterator24 = exceptionPrefixes[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {\n                                    var exceptionPrefix = _step24.value;\n\n                                    if (_key29.toString().startsWith(exceptionPrefix)) {\n                                        doBreak = true;\n                                        break;\n                                    }\n                                }\n                            } catch (err) {\n                                _didIteratorError24 = true;\n                                _iteratorError24 = err;\n                            } finally {\n                                try {\n                                    if (!_iteratorNormalCompletion24 && _iterator24.return) {\n                                        _iterator24.return();\n                                    }\n                                } finally {\n                                    if (_didIteratorError24) {\n                                        throw _iteratorError24;\n                                    }\n                                }\n                            }\n\n                            if (doBreak) break;\n                            if (deep !== 0 && !Tools.equals(first[_key29], second[_key29], properties, deep - 1, exceptionPrefixes)) equal = false;\n                        }\n                    }if (!equal) return false;\n                }\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Copies given object (of any type) into optionally given destination.\n         * @param source - Object to copy.\n         * @param recursionLimit - Specifies how deep we should traverse into given\n         * object recursively.\n         * @param destination - Target to copy source to.\n         * @param stackSource - Internally used to avoid traversing loops.\n         * @param stackDestination - Internally used to avoid traversing loops and\n         * referencing them correctly.\n         * @param recursionLevel - Internally used to track current recursion\n         * level in given source data structure.\n         * @returns Value \"true\" if both objects are equal and \"false\" otherwise.\n         */\n\n    }, {\n        key: 'copyLimitedRecursively',\n        value: function copyLimitedRecursively(source) {\n            var recursionLimit = arguments.length <= 1 || arguments[1] === undefined ? -1 : arguments[1];\n            var destination = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n            var stackSource = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];\n            var stackDestination = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];\n            var recursionLevel = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n\n            if (destination) {\n                if (source === destination) throw Error(\"Can't copy because source and destination are identical.\");\n                if (recursionLimit !== -1 && recursionLimit < recursionLevel) return null;\n                if (![undefined, null].includes(source) && (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object') {\n                    var index = stackSource.indexOf(source);\n                    if (index !== -1) return stackDestination[index];\n                    stackSource.push(source);\n                    stackDestination.push(destination);\n                }\n                var copyValue = function copyValue(value) {\n                    var result = Tools.copyLimitedRecursively(value, recursionLimit, null, stackSource, stackDestination, recursionLevel + 1);\n                    if (![undefined, null].includes(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n                        stackSource.push(value);\n                        stackDestination.push(result);\n                    }\n                    return result;\n                };\n                if (Array.isArray(source)) {\n                    var _iteratorNormalCompletion25 = true;\n                    var _didIteratorError25 = false;\n                    var _iteratorError25 = undefined;\n\n                    try {\n                        for (var _iterator25 = source[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {\n                            var _item = _step25.value;\n\n                            destination.push(copyValue(_item));\n                        }\n                    } catch (err) {\n                        _didIteratorError25 = true;\n                        _iteratorError25 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion25 && _iterator25.return) {\n                                _iterator25.return();\n                            }\n                        } finally {\n                            if (_didIteratorError25) {\n                                throw _iteratorError25;\n                            }\n                        }\n                    }\n                }if (source instanceof Map) {\n                    var _iteratorNormalCompletion26 = true;\n                    var _didIteratorError26 = false;\n                    var _iteratorError26 = undefined;\n\n                    try {\n                        for (var _iterator26 = source[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {\n                            var _step26$value = _slicedToArray(_step26.value, 2);\n\n                            var _key30 = _step26$value[0];\n                            var _value14 = _step26$value[1];\n\n                            destination.set(_key30, copyValue(_value14));\n                        }\n                    } catch (err) {\n                        _didIteratorError26 = true;\n                        _iteratorError26 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion26 && _iterator26.return) {\n                                _iterator26.return();\n                            }\n                        } finally {\n                            if (_didIteratorError26) {\n                                throw _iteratorError26;\n                            }\n                        }\n                    }\n                } else for (var _key31 in source) {\n                    if (source.hasOwnProperty(_key31)) destination[_key31] = copyValue(source[_key31]);\n                }\n            } else if (source) {\n                if (Array.isArray(source)) return Tools.copyLimitedRecursively(source, recursionLimit, [], stackSource, stackDestination, recursionLevel);\n                if (source instanceof Map) return Tools.copyLimitedRecursively(source, recursionLimit, new Map(), stackSource, stackDestination, recursionLevel);\n                if (Tools.determineType(source) === 'date') return new Date(source.getTime());\n                if (Tools.determineType(source) === 'regexp') {\n                    destination = new RegExp(source.source, source.toString().match(/[^\\/]*$/)[0]);\n                    destination.lastIndex = source.lastIndex;\n                    return destination;\n                }\n                if (![undefined, null].includes(source) && (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object') return Tools.copyLimitedRecursively(source, recursionLimit, {}, stackSource, stackDestination, recursionLevel);\n            }\n            return destination || source;\n        }\n        // / endregion\n        // / region array\n        /**\n         * Merge the contents of two arrays together into the first array.\n         * @param target - Target array.\n         * @param source - Source array.\n         * @returns Target array with merged given source one.\n         */\n\n    }, {\n        key: 'arrayMerge',\n        value: function arrayMerge(target, source) {\n            var length = Number(source.length);\n            var sourceIndex = 0;\n            var targetIndex = target.length;\n            for (; sourceIndex < length; sourceIndex++) {\n                target[targetIndex++] = source[sourceIndex];\n            }target.length = targetIndex;\n            return target;\n        }\n        /**\n         * Converts given object into an array.\n         * @param object - Target to convert.\n         * @returns Generated array.\n         */\n\n    }, {\n        key: 'arrayMake',\n        value: function arrayMake(object) {\n            var result = [];\n            if (![null, undefined].includes(result)) if (Tools.isArrayLike(Object(object))) Tools.arrayMerge(result, typeof object === 'string' ? [object] : object);else result.push(object);\n            return result;\n        }\n        /**\n         * Makes all values in given iterable unique by removing duplicates (The\n         * first occurrences will be left).\n         * @param data - Array like object.\n         * @returns Sliced version of given object.\n         */\n\n    }, {\n        key: 'arrayUnique',\n        value: function arrayUnique(data) {\n            var result = [];\n            var _iteratorNormalCompletion27 = true;\n            var _didIteratorError27 = false;\n            var _iteratorError27 = undefined;\n\n            try {\n                for (var _iterator27 = data[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {\n                    var _value15 = _step27.value;\n\n                    if (!result.includes(_value15)) result.push(_value15);\n                }\n            } catch (err) {\n                _didIteratorError27 = true;\n                _iteratorError27 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion27 && _iterator27.return) {\n                        _iterator27.return();\n                    }\n                } finally {\n                    if (_didIteratorError27) {\n                        throw _iteratorError27;\n                    }\n                }\n            }\n\n            return result;\n        }\n        /**\n         * Summarizes given property of given item list.\n         * @param data - Array of objects with given property name.\n         * @param propertyName - Property name to summarize.\n         * @param defaultValue - Value to return if property values doesn't match.\n         * @returns Summarized array.\n         */\n\n    }, {\n        key: 'arrayAggregatePropertyIfEqual',\n        value: function arrayAggregatePropertyIfEqual(data, propertyName) {\n            var defaultValue = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n\n            var result = defaultValue;\n            if (data && data.length && data[0].hasOwnProperty(propertyName)) {\n                result = data[0][propertyName];\n                var _iteratorNormalCompletion28 = true;\n                var _didIteratorError28 = false;\n                var _iteratorError28 = undefined;\n\n                try {\n                    for (var _iterator28 = data[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {\n                        var item = _step28.value;\n\n                        if (item[propertyName] !== result) return defaultValue;\n                    }\n                } catch (err) {\n                    _didIteratorError28 = true;\n                    _iteratorError28 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion28 && _iterator28.return) {\n                            _iterator28.return();\n                        }\n                    } finally {\n                        if (_didIteratorError28) {\n                            throw _iteratorError28;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n        /**\n         * Deletes every item witch has only empty attributes for given property\n         * names. If given property names are empty each attribute will be\n         * considered. The empty string, \"null\" and \"undefined\" will be interpreted\n         * as empty.\n         * @param data - Data to filter.\n         * @param propertyNames - Properties to consider.\n         * @returns Given data without empty items.\n         */\n\n    }, {\n        key: 'arrayDeleteEmptyItems',\n        value: function arrayDeleteEmptyItems(data) {\n            var propertyNames = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n            if (!data) return data;\n            var result = [];\n            var _iteratorNormalCompletion29 = true;\n            var _didIteratorError29 = false;\n            var _iteratorError29 = undefined;\n\n            try {\n                for (var _iterator29 = data[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {\n                    var item = _step29.value;\n\n                    var empty = true;\n                    for (var propertyName in item) {\n                        if (item.hasOwnProperty(propertyName)) if (!['', null, undefined].includes(item[propertyName]) && (!propertyNames.length || propertyNames.includes(propertyName))) {\n                            empty = false;\n                            break;\n                        }\n                    }if (!empty) result.push(item);\n                }\n            } catch (err) {\n                _didIteratorError29 = true;\n                _iteratorError29 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion29 && _iterator29.return) {\n                        _iterator29.return();\n                    }\n                } finally {\n                    if (_didIteratorError29) {\n                        throw _iteratorError29;\n                    }\n                }\n            }\n\n            return result;\n        }\n        /**\n         * Extracts all properties from all items wich occur in given property\n         * names.\n         * @param data - Data where each item should be sliced.\n         * @param propertyNames - Property names to extract.\n         * @returns Data with sliced items.\n         */\n\n    }, {\n        key: 'arrayExtract',\n        value: function arrayExtract(data, propertyNames) {\n            var result = [];\n            var _iteratorNormalCompletion30 = true;\n            var _didIteratorError30 = false;\n            var _iteratorError30 = undefined;\n\n            try {\n                for (var _iterator30 = data[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {\n                    var item = _step30.value;\n\n                    var newItem = {};\n                    var _iteratorNormalCompletion31 = true;\n                    var _didIteratorError31 = false;\n                    var _iteratorError31 = undefined;\n\n                    try {\n                        for (var _iterator31 = propertyNames[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {\n                            var propertyName = _step31.value;\n\n                            if (item.hasOwnProperty(propertyName)) newItem[propertyName] = item[propertyName];\n                        }\n                    } catch (err) {\n                        _didIteratorError31 = true;\n                        _iteratorError31 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion31 && _iterator31.return) {\n                                _iterator31.return();\n                            }\n                        } finally {\n                            if (_didIteratorError31) {\n                                throw _iteratorError31;\n                            }\n                        }\n                    }\n\n                    result.push(newItem);\n                }\n            } catch (err) {\n                _didIteratorError30 = true;\n                _iteratorError30 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion30 && _iterator30.return) {\n                        _iterator30.return();\n                    }\n                } finally {\n                    if (_didIteratorError30) {\n                        throw _iteratorError30;\n                    }\n                }\n            }\n\n            return result;\n        }\n        /**\n         * Extracts all values which matches given regular expression.\n         * @param data - Data to filter.\n         * @param regularExpression - Pattern to match for.\n         * @returns Filtered data.\n         */\n\n    }, {\n        key: 'arrayExtractIfMatches',\n        value: function arrayExtractIfMatches(data, regularExpression) {\n            var result = [];\n            var _iteratorNormalCompletion32 = true;\n            var _didIteratorError32 = false;\n            var _iteratorError32 = undefined;\n\n            try {\n                for (var _iterator32 = data[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {\n                    var _value16 = _step32.value;\n\n                    if ((typeof regularExpression === 'string' ? new RegExp(regularExpression) : regularExpression).test(_value16)) result.push(_value16);\n                }\n            } catch (err) {\n                _didIteratorError32 = true;\n                _iteratorError32 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion32 && _iterator32.return) {\n                        _iterator32.return();\n                    }\n                } finally {\n                    if (_didIteratorError32) {\n                        throw _iteratorError32;\n                    }\n                }\n            }\n\n            return result;\n        }\n        /**\n         * Filters given data if given property is set or not.\n         * @param data - Data to filter.\n         * @param propertyName - Property name to check for existence.\n         * @returns Given data without the items which doesn't have specified\n         * property.\n         */\n\n    }, {\n        key: 'arrayExtractIfPropertyExists',\n        value: function arrayExtractIfPropertyExists(data, propertyName) {\n            if (data && propertyName) {\n                var result = [];\n                var _iteratorNormalCompletion33 = true;\n                var _didIteratorError33 = false;\n                var _iteratorError33 = undefined;\n\n                try {\n                    for (var _iterator33 = data[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {\n                        var item = _step33.value;\n\n                        var exists = false;\n                        for (var _key32 in item) {\n                            if (_key32 === propertyName && item.hasOwnProperty(_key32) && ![undefined, null].includes(item[_key32])) {\n                                exists = true;\n                                break;\n                            }\n                        }if (exists) result.push(item);\n                    }\n                } catch (err) {\n                    _didIteratorError33 = true;\n                    _iteratorError33 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion33 && _iterator33.return) {\n                            _iterator33.return();\n                        }\n                    } finally {\n                        if (_didIteratorError33) {\n                            throw _iteratorError33;\n                        }\n                    }\n                }\n\n                return result;\n            }\n            return data;\n        }\n        /**\n         * Extract given data where specified property value matches given\n         * patterns.\n         * @param data - Data to filter.\n         * @param propertyPattern - Mapping of property names to pattern.\n         * @returns Filtered data.\n         */\n\n    }, {\n        key: 'arrayExtractIfPropertyMatches',\n        value: function arrayExtractIfPropertyMatches(data, propertyPattern) {\n            if (data && propertyPattern) {\n                var result = [];\n                var _iteratorNormalCompletion34 = true;\n                var _didIteratorError34 = false;\n                var _iteratorError34 = undefined;\n\n                try {\n                    for (var _iterator34 = data[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {\n                        var item = _step34.value;\n\n                        var matches = true;\n                        for (var propertyName in propertyPattern) {\n                            if (!(propertyPattern[propertyName] instanceof RegExp ? propertyPattern[propertyName] : new RegExp(propertyPattern[propertyName])).test(item[propertyName])) {\n                                matches = false;\n                                break;\n                            }\n                        }if (matches) result.push(item);\n                    }\n                } catch (err) {\n                    _didIteratorError34 = true;\n                    _iteratorError34 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion34 && _iterator34.return) {\n                            _iterator34.return();\n                        }\n                    } finally {\n                        if (_didIteratorError34) {\n                            throw _iteratorError34;\n                        }\n                    }\n                }\n\n                return result;\n            }\n            return data;\n        }\n        /**\n         * Determines all objects which exists in \"firstSet\" and in \"secondSet\".\n         * Object key which will be compared are given by \"keys\". If an empty array\n         * is given each key will be compared. If an object is given corresponding\n         * initial data key will be mapped to referenced new data key.\n         * @param firstSet - Referenced data to check for.\n         * @param secondSet - Data to check for existence.\n         * @param keys - Keys to define equality.\n         * @param strict - The strict parameter indicates whether \"null\" and\n         * \"undefined\" should be interpreted as equal (takes only effect if given\n         * keys aren't empty).\n         * @returns Data which does exit in given initial data.\n         */\n\n    }, {\n        key: 'arrayIntersect',\n        value: function arrayIntersect(firstSet, secondSet) {\n            var keys = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n            var strict = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n            var containingData = [];\n            var _iteratorNormalCompletion35 = true;\n            var _didIteratorError35 = false;\n            var _iteratorError35 = undefined;\n\n            try {\n                var _loop = function _loop() {\n                    var initialItem = _step35.value;\n\n                    if (Tools.isPlainObject(initialItem)) {\n                        var _iteratorNormalCompletion36 = true;\n                        var _didIteratorError36 = false;\n                        var _iteratorError36 = undefined;\n\n                        try {\n                            var _loop2 = function _loop2() {\n                                var newItem = _step36.value;\n\n                                var exists = true;\n                                var iterateGivenKeys = void 0;\n                                var keysAreAnArray = Array.isArray(keys);\n                                if (Tools.isPlainObject(keys) || keysAreAnArray && keys.length) iterateGivenKeys = true;else {\n                                    iterateGivenKeys = false;\n                                    keys = initialItem;\n                                }\n                                var handle = function handle(firstSetKey, secondSetKey) {\n                                    if (keysAreAnArray && iterateGivenKeys) firstSetKey = secondSetKey;else if (!iterateGivenKeys) secondSetKey = firstSetKey;\n                                    if (newItem[secondSetKey] !== initialItem[firstSetKey] && (strict || !([null, undefined].includes(newItem[secondSetKey]) && [null, undefined].includes(initialItem[firstSetKey])))) {\n                                        exists = false;\n                                        return false;\n                                    }\n                                };\n                                if (Array.isArray(keys)) {\n                                    var index = 0;\n                                    var _iteratorNormalCompletion37 = true;\n                                    var _didIteratorError37 = false;\n                                    var _iteratorError37 = undefined;\n\n                                    try {\n                                        for (var _iterator37 = keys[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {\n                                            var _key33 = _step37.value;\n\n                                            if (handle(index, _key33) === false) break;\n                                            index += 1;\n                                        }\n                                    } catch (err) {\n                                        _didIteratorError37 = true;\n                                        _iteratorError37 = err;\n                                    } finally {\n                                        try {\n                                            if (!_iteratorNormalCompletion37 && _iterator37.return) {\n                                                _iterator37.return();\n                                            }\n                                        } finally {\n                                            if (_didIteratorError37) {\n                                                throw _iteratorError37;\n                                            }\n                                        }\n                                    }\n                                } else for (var _key34 in keys) {\n                                    if (keys.hasOwnProperty(_key34)) if (handle(_key34, keys[_key34]) === false) break;\n                                }if (exists) {\n                                    containingData.push(initialItem);\n                                    return 'break';\n                                }\n                            };\n\n                            for (var _iterator36 = secondSet[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {\n                                var _ret3 = _loop2();\n\n                                if (_ret3 === 'break') break;\n                            }\n                        } catch (err) {\n                            _didIteratorError36 = true;\n                            _iteratorError36 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion36 && _iterator36.return) {\n                                    _iterator36.return();\n                                }\n                            } finally {\n                                if (_didIteratorError36) {\n                                    throw _iteratorError36;\n                                }\n                            }\n                        }\n                    } else if (secondSet.includes(initialItem)) containingData.push(initialItem);\n                };\n\n                for (var _iterator35 = firstSet[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {\n                    _loop();\n                }\n            } catch (err) {\n                _didIteratorError35 = true;\n                _iteratorError35 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion35 && _iterator35.return) {\n                        _iterator35.return();\n                    }\n                } finally {\n                    if (_didIteratorError35) {\n                        throw _iteratorError35;\n                    }\n                }\n            }\n\n            return containingData;\n        }\n        /**\n         * Creates a list of items within given range.\n         * @param range - Array of lower and upper bounds. If only one value is\n         * given lower bound will be assumed to be zero. Both integers have to be\n         * positive and will be contained in the resulting array.\n         * @param step - Space between two consecutive values.\n         * @returns Produced array of integers.\n         */\n\n    }, {\n        key: 'arrayMakeRange',\n        value: function arrayMakeRange(range) {\n            var step = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n\n            var index = void 0;\n            var higherBound = void 0;\n            if (range.length === 1) {\n                index = 0;\n                higherBound = parseInt(range[0], 10);\n            } else if (range.length === 2) {\n                index = parseInt(range[0], 10);\n                higherBound = parseInt(range[1], 10);\n            } else return range;\n            var result = [index];\n            while (index <= higherBound - step) {\n                index += step;\n                result.push(index);\n            }\n            return result;\n        }\n        /**\n         * Sums up given property of given item list.\n         * @param data - The objects with specified property to sum up.\n         * @param propertyName - Property name to sum up its value.\n         * @returns The aggregated value.\n         */\n\n    }, {\n        key: 'arraySumUpProperty',\n        value: function arraySumUpProperty(data, propertyName) {\n            var result = 0;\n            if (Array.isArray(data) && data.length) {\n                var _iteratorNormalCompletion38 = true;\n                var _didIteratorError38 = false;\n                var _iteratorError38 = undefined;\n\n                try {\n                    for (var _iterator38 = data[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {\n                        var _item2 = _step38.value;\n\n                        if (_item2.hasOwnProperty(propertyName)) result += parseFloat(_item2[propertyName] || 0);\n                    }\n                } catch (err) {\n                    _didIteratorError38 = true;\n                    _iteratorError38 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion38 && _iterator38.return) {\n                            _iterator38.return();\n                        }\n                    } finally {\n                        if (_didIteratorError38) {\n                            throw _iteratorError38;\n                        }\n                    }\n                }\n            }return result;\n        }\n        /**\n         * Adds an item to another item as array connection (many to one).\n         * @param item - Item where the item should be appended to.\n         * @param target - Target to add to given item.\n         * @param name - Name of the target connection.\n         * @param checkIfExists - Indicates if duplicates are allowed in resulting\n         * list (will result in linear runtime instead of constant one).\n         * @returns Item with the appended target.\n         */\n\n    }, {\n        key: 'arrayAppendAdd',\n        value: function arrayAppendAdd(item, target, name) {\n            var checkIfExists = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n            if (item.hasOwnProperty(name)) {\n                if (!(checkIfExists && item[name].includes(target))) item[name].push(target);\n            } else item[name] = [target];\n            return item;\n        }\n        /**\n         * Removes given target on given list.\n         * @param list - Array to splice.\n         * @param target - Target to remove from given list.\n         * @param strict - Indicates whether to fire an exception if given target\n         * doesn't exists given list.\n         * @returns Item with the appended target.\n         */\n\n    }, {\n        key: 'arrayRemove',\n        value: function arrayRemove(list, target) {\n            var strict = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n            if (Array.isArray(list)) {\n                var index = list.indexOf(target);\n                if (index === -1) {\n                    if (strict) throw Error(\"Given target doesn't exists in given list.\");\n                } else\n                    /* eslint-disable max-statements-per-line */\n                    list.splice(index, 1);\n                /* eslint-enable max-statements-per-line */\n            } else if (strict) throw Error(\"Given target isn't an array.\");\n            return list;\n        }\n        // / endregion\n        // / region string\n        // // region url handling\n        /**\n         * Translates given string into the regular expression validated\n         * representation.\n         * @param value - String to convert.\n         * @param excludeSymbols - Symbols not to escape.\n         * @returns Converted string.\n         */\n\n    }, {\n        key: 'stringConvertToValidRegularExpression',\n        value: function stringConvertToValidRegularExpression(value) {\n            var excludeSymbols = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n            // NOTE: This is only for performance improvements.\n            if (value.length === 1 && !Tools.specialRegexSequences.includes(value)) return value;\n            // The escape sequence must also be escaped; but at first.\n            if (!excludeSymbols.includes('\\\\')) value.replace(/\\\\/g, '\\\\\\\\');\n            var _iteratorNormalCompletion39 = true;\n            var _didIteratorError39 = false;\n            var _iteratorError39 = undefined;\n\n            try {\n                for (var _iterator39 = Tools.specialRegexSequences[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {\n                    var replace = _step39.value;\n\n                    if (!excludeSymbols.includes(replace)) value = value.replace(new RegExp('\\\\' + replace, 'g'), '\\\\' + replace);\n                }\n            } catch (err) {\n                _didIteratorError39 = true;\n                _iteratorError39 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion39 && _iterator39.return) {\n                        _iterator39.return();\n                    }\n                } finally {\n                    if (_didIteratorError39) {\n                        throw _iteratorError39;\n                    }\n                }\n            }\n\n            return value;\n        }\n        /**\n         * Translates given name into a valid javaScript one.\n         * @param name - Name to convert.\n         * @param allowedSymbols - String of symbols which should be allowed within\n         * a variable name (not the first character).\n         * @returns Converted name is returned.\n         */\n\n    }, {\n        key: 'stringConvertToValidVariableName',\n        value: function stringConvertToValidVariableName(name) {\n            var allowedSymbols = arguments.length <= 1 || arguments[1] === undefined ? '0-9a-zA-Z_$' : arguments[1];\n\n            return name.toString().replace(/^[^a-zA-Z_$]+/, '').replace(new RegExp('[^' + allowedSymbols + ']+([a-zA-Z0-9])', 'g'), function (fullMatch, firstLetter) {\n                return firstLetter.toUpperCase();\n            });\n        }\n        /**\n         * This method is intended for encoding *key* or *value* parts of query\n         * component. We need a custom method because \"encodeURIComponent()\" is too\n         * aggressive and encodes stuff that doesn't have to be encoded per\n         * \"http://tools.ietf.org/html/rfc3986:\".\n         * @param url - URL to encode.\n         * @param encodeSpaces - Indicates whether given url should encode\n         * whitespaces as \"+\" or \"%20\".\n         * @returns Encoded given url.\n         */\n\n    }, {\n        key: 'stringEncodeURIComponent',\n        value: function stringEncodeURIComponent(url, encodeSpaces) {\n            return encodeURIComponent(url).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, encodeSpaces ? '%20' : '+');\n        }\n        /**\n         * Appends a path selector to the given path if there isn't one yet.\n         * @param path - The path for appending a selector.\n         * @param pathSeparator - The selector for appending to path.\n         * @returns The appended path.\n         */\n\n    }, {\n        key: 'stringAddSeparatorToPath',\n        value: function stringAddSeparatorToPath(path) {\n            var pathSeparator = arguments.length <= 1 || arguments[1] === undefined ? '/' : arguments[1];\n\n            path = path.trim();\n            if (path.substr(-1) !== pathSeparator && path.length) return path + pathSeparator;\n            return path;\n        }\n        /**\n         * Checks if given path has given path prefix.\n         * @param prefix - Path prefix to search for.\n         * @param path - Path to search in.\n         * @param separator - Delimiter to use in path (default is the posix\n         * conform slash).\n         * @returns Value \"true\" if given prefix occur and \"false\" otherwise.\n         */\n\n    }, {\n        key: 'stringHasPathPrefix',\n        value: function stringHasPathPrefix() {\n            var prefix = arguments.length <= 0 || arguments[0] === undefined ? '/admin' : arguments[0];\n            var path = arguments.length <= 1 || arguments[1] === undefined ? 'location' in $.global && $.global.location.pathname || '' : arguments[1];\n            var separator = arguments.length <= 2 || arguments[2] === undefined ? '/' : arguments[2];\n\n            if (typeof prefix === 'string') {\n                if (!prefix.endsWith(separator)) prefix += separator;\n                return path === prefix.substring(0, prefix.length - separator.length) || path.startsWith(prefix);\n            }\n            return false;\n        }\n        /**\n         * Extracts domain name from given url. If no explicit domain name given\n         * current domain name will be assumed. If no parameter given current\n         * domain name will be determined.\n         * @param url - The url to extract domain from.\n         * @param fallback - The fallback host name if no one exits in given url\n         * (default is current hostname).\n         * @returns Extracted domain.\n         */\n\n    }, {\n        key: 'stringGetDomainName',\n        value: function stringGetDomainName() {\n            var url = arguments.length <= 0 || arguments[0] === undefined ? 'location' in $.global && $.global.location.href || '' : arguments[0];\n            var fallback = arguments.length <= 1 || arguments[1] === undefined ? 'location' in $.global && $.global.location.hostname || '' : arguments[1];\n\n            var result = /^([a-z]*:?\\/\\/)?([^/]+?)(?::[0-9]+)?(?:\\/.*|$)/i.exec(url);\n            if (result && result.length > 2 && result[1] && result[2]) return result[2];\n            return fallback;\n        }\n        /**\n         * Extracts port number from given url. If no explicit port number given\n         * and no fallback is defined current port number will be assumed for local\n         * links. For external links 80 will be assumed for http protocol or 443\n         * for https.\n         * @param url - The url to extract port from.\n         * @param fallback - Fallback port number if no explicit one was found.\n         * Default is derived from current protocol name.\n         * @param parameter - Additional parameter for checking if given url is an\n         * internal url. Given url and this parameter will be forwarded to the\n         * \"stringIsInternalURL()\" method.\n         * @returns Extracted port number.\n         */\n\n    }, {\n        key: 'stringGetPortNumber',\n        value: function stringGetPortNumber() {\n            var url = arguments.length <= 0 || arguments[0] === undefined ? 'location' in $.global && $.global.location.href || '' : arguments[0];\n            var fallback = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n            var parameter = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\n            var result = /^(?:[a-z]*:?\\/\\/[^/]+?)?(?:[^/]+?):([0-9]+)/i.exec(url);\n            if (result && result.length > 1) return parseInt(result[1], 10);\n            if (fallback !== null) return fallback;\n            if (Tools.stringIsInternalURL.apply(this, [url].concat(parameter)) && 'location' in $.global && $.global.location.port && parseInt($.global.location.port, 10)) return parseInt($.global.location.port, 10);\n            return Tools.stringGetProtocolName(url) === 'https' ? 443 : 80;\n        }\n        /**\n         * Extracts protocol name from given url. If no explicit url is given,\n         * current protocol will be assumed. If no parameter given current protocol\n         * number will be determined.\n         * @param url - The url to extract protocol from.\n         * @param fallback - Fallback port to use if no protocol exists in given\n         * url (default is current protocol).\n         * returns Extracted protocol.\n         */\n\n    }, {\n        key: 'stringGetProtocolName',\n        value: function stringGetProtocolName() {\n            var url = arguments.length <= 0 || arguments[0] === undefined ? 'location' in $.global && $.global.location.href || '' : arguments[0];\n            var fallback = arguments.length <= 1 || arguments[1] === undefined ? 'location' in $.global && $.global.location.protocol.substring(0, $.global.location.protocol.length - 1) || '' : arguments[1];\n\n            var result = /^([a-z]+):\\/\\//i.exec(url);\n            if (result && result.length > 1 && result[1]) return result[1];\n            return fallback;\n        }\n        /**\n         * Read a page's GET URL variables and return them as an associative array\n         * and preserves ordering.\n         * @param keyToGet - If key given the corresponding value is returned and\n         * full object otherwise.\n         * @param givenInput - An alternative input to the url search parameter. If\n         * \"#\" is given the complete current hash tag will be interpreted as url\n         * and search parameter will be extracted from there. If \"&\" is given\n         * classical search parameter and hash parameter will be taken in account.\n         * If a search string is given this will be analyzed. The default is to\n         * take given search part into account.\n         * @param subDelimiter - Defines which sequence indicates the start of\n         * parameter in a hash part of the url.\n         * @param hashedPathIndicator - If defined and given hash starts with this\n         * indicator given hash will be interpreted as path containing search and\n         * hash parts.\n         * @param givenSearch - Search part to take into account defaults to\n         * current url search part.\n         * @param givenHash - Hash part to take into account defaults to current\n         * url hash part.\n         * @returns Returns the current get array or requested value. If requested\n         * key doesn't exist \"undefined\" is returned.\n         */\n\n    }, {\n        key: 'stringGetURLVariable',\n        value: function stringGetURLVariable(keyToGet, givenInput) {\n            var subDelimiter = arguments.length <= 2 || arguments[2] === undefined ? '$' : arguments[2];\n            var hashedPathIndicator = arguments.length <= 3 || arguments[3] === undefined ? '!' : arguments[3];\n            var givenSearch = arguments[4];\n            var givenHash = arguments.length <= 5 || arguments[5] === undefined ? 'location' in $.global && $.global.location.hash || '' : arguments[5];\n\n            // region set search and hash\n            var hash = givenHash ? givenHash : '#';\n            var search = '';\n            if (givenSearch) search = givenSearch;else if (hashedPathIndicator && hash.startsWith(hashedPathIndicator)) {\n                var subHashStartIndex = hash.indexOf('#');\n                var pathAndSearch = void 0;\n                if (subHashStartIndex === -1) {\n                    pathAndSearch = hash.substring(hashedPathIndicator.length);\n                    hash = '';\n                } else {\n                    pathAndSearch = hash.substring(hashedPathIndicator.length, subHashStartIndex);\n                    hash = hash.substring(subHashStartIndex);\n                }\n                var subSearchStartIndex = pathAndSearch.indexOf('?');\n                if (subSearchStartIndex !== -1) search = pathAndSearch.substring(subSearchStartIndex);\n            } else if ('location' in $.global) search = $.global.location.search || '';\n            var input = givenInput ? givenInput : search;\n            // endregion\n            // region determine data from search and hash if specified\n            var both = input === '&';\n            if (both || input === '#') {\n                var decodedHash = '';\n                try {\n                    decodedHash = decodeURIComponent(hash);\n                } catch (error) {}\n                var subDelimiterIndex = decodedHash.indexOf(subDelimiter);\n                if (subDelimiterIndex === -1) input = '';else {\n                    input = decodedHash.substring(subDelimiterIndex);\n                    if (input.startsWith(subDelimiter)) input = input.substring(subDelimiter.length);\n                }\n            } else if (input.startsWith('?')) input = input.substring('?'.length);\n            var data = input ? input.split('&') : [];\n            search = search.substring('?'.length);\n            if (both && search) data = data.concat(search.split('&'));\n            // endregion\n            // region construct data structure\n            var variables = [];\n            var _iteratorNormalCompletion40 = true;\n            var _didIteratorError40 = false;\n            var _iteratorError40 = undefined;\n\n            try {\n                for (var _iterator40 = data[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {\n                    var _value17 = _step40.value;\n\n                    var keyValuePair = _value17.split('=');\n                    var _key35 = void 0;\n                    try {\n                        _key35 = decodeURIComponent(keyValuePair[0]);\n                    } catch (error) {\n                        _key35 = '';\n                    }\n                    try {\n                        _value17 = decodeURIComponent(keyValuePair[1]);\n                    } catch (error) {\n                        _value17 = '';\n                    }\n                    variables.push(_key35);\n                    // IgnoreTypeCheck\n                    variables[_key35] = _value17;\n                }\n                // endregion\n            } catch (err) {\n                _didIteratorError40 = true;\n                _iteratorError40 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion40 && _iterator40.return) {\n                        _iterator40.return();\n                    }\n                } finally {\n                    if (_didIteratorError40) {\n                        throw _iteratorError40;\n                    }\n                }\n            }\n\n            if (keyToGet)\n                // IgnoreTypeCheck\n                return variables[keyToGet];\n            return variables;\n        }\n        /**\n         * Checks if given url points to another domain than second given url. If\n         * no second given url provided current url will be assumed.\n         * @param firstURL - URL to check against second url.\n         * @param secondURL - URL to check against first url.\n         * @returns Returns \"true\" if given first url has same domain as given\n         * second (or current).\n         */\n\n    }, {\n        key: 'stringIsInternalURL',\n        value: function stringIsInternalURL(firstURL) {\n            var secondURL = arguments.length <= 1 || arguments[1] === undefined ? 'location' in $.global && $.global.location.href || '' : arguments[1];\n\n            var explicitDomainName = Tools.stringGetDomainName(firstURL, false);\n            var explicitProtocolName = Tools.stringGetProtocolName(firstURL, false);\n            var explicitPortNumber = Tools.stringGetPortNumber(firstURL, false);\n            return (!explicitDomainName || explicitDomainName === Tools.stringGetDomainName(secondURL)) && (!explicitProtocolName || explicitProtocolName === Tools.stringGetProtocolName(secondURL)) && (!explicitPortNumber || explicitPortNumber === Tools.stringGetPortNumber(secondURL));\n        }\n        /**\n         * Normalized given website url.\n         * @param url - Uniform resource locator to normalize.\n         * @returns Normalized result.\n         */\n\n    }, {\n        key: 'stringNormalizeURL',\n        value: function stringNormalizeURL(url) {\n            if (url) {\n                url = url.replace(/^:?\\/+/, '').replace(/\\/+$/, '').trim();\n                if (url.startsWith('http')) return url;\n                return 'http://' + url;\n            }\n            return '';\n        }\n        /**\n         * Represents given website url.\n         * @param url - Uniform resource locator to represent.\n         * @returns Represented result.\n         */\n\n    }, {\n        key: 'stringRepresentURL',\n        value: function stringRepresentURL(url) {\n            if (typeof url === 'string') return url.replace(/^(https?)?:?\\/+/, '').replace(/\\/+$/, '').trim();\n            return '';\n        }\n        // // endregion\n        /**\n         * Compresses given style attribute value.\n         * @param styleValue - Style value to compress.\n         * @returns The compressed value.\n         */\n\n    }, {\n        key: 'stringCompressStyleValue',\n        value: function stringCompressStyleValue(styleValue) {\n            return styleValue.replace(/ *([:;]) */g, '$1').replace(/ +/g, ' ').replace(/^;+/, '').replace(/;+$/, '').trim();\n        }\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Converts a camel cased string to its delimited string version.\n         * @param string - The string to format.\n         * @param delimiter - Delimiter string\n         * @param abbreviations - Collection of shortcut words to represent upper\n         * cased.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringCamelCaseToDelimited',\n        value: function stringCamelCaseToDelimited(string) {\n            var delimiter = arguments.length <= 1 || arguments[1] === undefined ? '-' : arguments[1];\n            var abbreviations = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            if (!abbreviations) abbreviations = Tools.abbreviations;\n            var escapedDelimiter = Tools.stringGetRegularExpressionValidated(delimiter);\n            if (abbreviations.length) {\n                var abbreviationPattern = '';\n                var _iteratorNormalCompletion41 = true;\n                var _didIteratorError41 = false;\n                var _iteratorError41 = undefined;\n\n                try {\n                    for (var _iterator41 = abbreviations[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {\n                        var abbreviation = _step41.value;\n\n                        if (abbreviationPattern) abbreviationPattern += '|';\n                        abbreviationPattern += abbreviation.toUpperCase();\n                    }\n                } catch (err) {\n                    _didIteratorError41 = true;\n                    _iteratorError41 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion41 && _iterator41.return) {\n                            _iterator41.return();\n                        }\n                    } finally {\n                        if (_didIteratorError41) {\n                            throw _iteratorError41;\n                        }\n                    }\n                }\n\n                string = string.replace(new RegExp('(' + abbreviationPattern + ')(' + abbreviationPattern + ')', 'g'), '$1' + delimiter + '$2');\n            }\n            string = string.replace(new RegExp('([^' + escapedDelimiter + '])([A-Z][a-z]+)', 'g'), '$1' + delimiter + '$2');\n            return string.replace(new RegExp('([a-z0-9])([A-Z])', 'g'), '$1' + delimiter + '$2').toLowerCase();\n        }\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Converts a string to its capitalize representation.\n         * @param string - The string to format.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringCapitalize',\n        value: function stringCapitalize(string) {\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            return string.charAt(0).toUpperCase() + string.substring(1);\n        }\n        /**\n         * Converts a delimited string to its camel case representation.\n         * @param string - The string to format.\n         * @param delimiter - Delimiter string to use.\n         * @param abbreviations - Collection of shortcut words to represent upper\n         * cased.\n         * @param preserveWrongFormattedAbbreviations - If set to \"True\" wrong\n         * formatted camel case abbreviations will be ignored.\n         * @param removeMultipleDelimiter - Indicates whether a series of delimiter\n         * should be consolidated.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringDelimitedToCamelCase',\n        value: function stringDelimitedToCamelCase(string) {\n            var delimiter = arguments.length <= 1 || arguments[1] === undefined ? '-' : arguments[1];\n            var abbreviations = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n            var preserveWrongFormattedAbbreviations = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n            var removeMultipleDelimiter = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n\n            var escapedDelimiter = Tools.stringGetRegularExpressionValidated(delimiter);\n            if (!abbreviations) abbreviations = Tools.abbreviations;\n            var abbreviationPattern = void 0;\n            if (preserveWrongFormattedAbbreviations) abbreviationPattern = abbreviations.join('|');else {\n                abbreviationPattern = '';\n                var _iteratorNormalCompletion42 = true;\n                var _didIteratorError42 = false;\n                var _iteratorError42 = undefined;\n\n                try {\n                    for (var _iterator42 = abbreviations[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {\n                        var abbreviation = _step42.value;\n\n                        if (abbreviationPattern) abbreviationPattern += '|';\n                        abbreviationPattern += Tools.stringCapitalize(abbreviation) + '|' + abbreviation;\n                    }\n                } catch (err) {\n                    _didIteratorError42 = true;\n                    _iteratorError42 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion42 && _iterator42.return) {\n                            _iterator42.return();\n                        }\n                    } finally {\n                        if (_didIteratorError42) {\n                            throw _iteratorError42;\n                        }\n                    }\n                }\n            }\n            var stringStartsWithDelimiter = false;\n            if (string.startsWith(delimiter)) {\n                string = string.substring(delimiter.length);\n                stringStartsWithDelimiter = true;\n            }\n            string = string.replace(new RegExp('(' + escapedDelimiter + ')(' + abbreviationPattern + ')' + ('(' + escapedDelimiter + '|$)'), 'g'), function (fullMatch, before, abbreviation, after) {\n                return before + abbreviation.toUpperCase() + after;\n            });\n            if (removeMultipleDelimiter) escapedDelimiter = '(?:' + escapedDelimiter + ')+';\n            string = string.replace(new RegExp(escapedDelimiter + '([a-zA-Z0-9])', 'g'), function (fullMatch, firstLetter) {\n                return firstLetter.toUpperCase();\n            });\n            if (stringStartsWithDelimiter) string = delimiter + string;\n            return string;\n        }\n        /**\n         * Performs a string formation. Replaces every placeholder \"{i}\" with the\n         * i'th argument.\n         * @param string - The string to format.\n         * @param additionalArguments - Additional arguments are interpreted as\n         * replacements for string formating.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringFormat',\n        value: function stringFormat(string) {\n            for (var _len11 = arguments.length, additionalArguments = Array(_len11 > 1 ? _len11 - 1 : 0), _key36 = 1; _key36 < _len11; _key36++) {\n                additionalArguments[_key36 - 1] = arguments[_key36];\n            }\n\n            additionalArguments.unshift(string);\n            var index = 0;\n            var _iteratorNormalCompletion43 = true;\n            var _didIteratorError43 = false;\n            var _iteratorError43 = undefined;\n\n            try {\n                for (var _iterator43 = additionalArguments[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {\n                    var _value18 = _step43.value;\n\n                    string = string.replace(new RegExp('\\\\{' + index + '\\\\}', 'gm'), '' + _value18);\n                    index += 1;\n                }\n            } catch (err) {\n                _didIteratorError43 = true;\n                _iteratorError43 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion43 && _iterator43.return) {\n                        _iterator43.return();\n                    }\n                } finally {\n                    if (_didIteratorError43) {\n                        throw _iteratorError43;\n                    }\n                }\n            }\n\n            return string;\n        }\n        /**\n         * Validates the current string for using in a regular expression pattern.\n         * Special regular expression chars will be escaped.\n         * @param string - The string to format.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringGetRegularExpressionValidated',\n        value: function stringGetRegularExpressionValidated(string) {\n            return string.replace(/([\\\\|.*$^+[\\]()?\\-{}])/g, '\\\\$1');\n        }\n        /**\n         * Converts a string to its lower case representation.\n         * @param string - The string to format.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringLowerCase',\n        value: function stringLowerCase(string) {\n            return string.charAt(0).toLowerCase() + string.substring(1);\n        }\n        /**\n         * Wraps given mark strings in given target with given marker.\n         * @param target - String to search for marker.\n         * @param mark - String to search in target for.\n         * @param marker - HTML template string to mark.\n         * @param caseSensitive - Indicates whether case takes a role during\n         * searching.\n         * @returns Processed result.\n         */\n\n    }, {\n        key: 'stringMark',\n        value: function stringMark(target, mark) {\n            var marker = arguments.length <= 2 || arguments[2] === undefined ? '<span class=\"tools-mark\">{1}</span>' : arguments[2];\n            var caseSensitive = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n            if (target && mark) {\n                target = target.trim();\n                mark = mark.trim();\n                var offset = 0;\n                var searchTarget = target;\n                if (!caseSensitive) searchTarget = searchTarget.toLowerCase();\n                if (!caseSensitive) mark = mark.toLowerCase();\n                while (true) {\n                    var index = searchTarget.indexOf(mark, offset);\n                    if (index === -1) break;else {\n                        target = target.substring(0, index) + Tools.stringFormat(marker, target.substr(index, mark.length)) + target.substring(index + mark.length);\n                        if (!caseSensitive) searchTarget = target.toLowerCase();\n                        offset = index + (marker.length - '{1}'.length) + mark.length;\n                    }\n                }\n            }\n            return target;\n        }\n        /**\n         * Implements the md5 hash algorithm.\n         * @param value - Value to calculate md5 hash for.\n         * @param onlyAscii - Set to true if given input has ascii characters only\n         * to get more performance.\n         * @returns Calculated md5 hash value.\n         */\n\n    }, {\n        key: 'stringMD5',\n        value: function stringMD5(value) {\n            var onlyAscii = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n            var hexCharacters = '0123456789abcdef'.split('');\n            // region sub helper\n            /**\n             * This function is much faster, so if possible we use it. Some IEs\n             * are the only ones I know of that need the idiotic second function,\n             * generated by an if clause in the end.\n             * @param first - First operand to add.\n             * @param second - Second operant to add.\n             * @returns The sum of both given operands.\n            */\n            var unsignedModule2PowerOf32Addition = function unsignedModule2PowerOf32Addition(first, second) {\n                return first + second & 0xFFFFFFFF;\n            };\n            // / region primary functions needed for the algorithm\n            /*\n             * Implements the basic operation for each round of the algorithm.\n             */\n            var cmn = function cmn(q, a, b, x, s, t) {\n                a = unsignedModule2PowerOf32Addition(unsignedModule2PowerOf32Addition(a, q), unsignedModule2PowerOf32Addition(x, t));\n                return unsignedModule2PowerOf32Addition(a << s | a >>> 32 - s, b);\n            };\n            /**\n             * First algorithm part.\n             * @param a - Operand.\n             * @param b - Operand.\n             * @param c - Operand.\n             * @param d - Operand.\n             * @param x - Operand.\n             * @param s - Operand.\n             * @param t - Operand.\n             * @returns Result.\n             */\n            var ff = function ff(a, b, c, d, x, s, t) {\n                return cmn(b & c | ~b & d, a, b, x, s, t);\n            };\n            /**\n             * Second algorithm part.\n             * @param a - Operand.\n             * @param b - Operand.\n             * @param c - Operand.\n             * @param d - Operand.\n             * @param x - Operand.\n             * @param s - Operand.\n             * @param t - Operand.\n             * @returns Result.\n             */\n            var gg = function gg(a, b, c, d, x, s, t) {\n                return cmn(b & d | c & ~d, a, b, x, s, t);\n            };\n            /**\n             * Third algorithm part.\n             * @param a - Operand.\n             * @param b - Operand.\n             * @param c - Operand.\n             * @param d - Operand.\n             * @param x - Operand.\n             * @param s - Operand.\n             * @param t - Operand.\n             * @returns Result.\n             */\n            var hh = function hh(a, b, c, d, x, s, t) {\n                return cmn(b ^ c ^ d, a, b, x, s, t);\n            };\n            /**\n             * Fourth algorithm part.\n             * @param a - Operand.\n             * @param b - Operand.\n             * @param c - Operand.\n             * @param d - Operand.\n             * @param x - Operand.\n             * @param s - Operand.\n             * @param t - Operand.\n             * @returns Result.\n             */\n            var ii = function ii(a, b, c, d, x, s, t) {\n                return cmn(c ^ (b | ~d), a, b, x, s, t);\n            };\n            /**\n             * Performs all 16 needed steps.\n             * @param state - Current state.\n             * @param blocks - Blocks to cycle through.\n             * @returns Returns given state.\n             */\n            var cycle = function cycle(state, blocks) {\n                var a = state[0];\n                var b = state[1];\n                var c = state[2];\n                var d = state[3];\n                // region round 1\n                a = ff(a, b, c, d, blocks[0], 7, -680876936);\n                d = ff(d, a, b, c, blocks[1], 12, -389564586);\n                c = ff(c, d, a, b, blocks[2], 17, 606105819);\n                b = ff(b, c, d, a, blocks[3], 22, -1044525330);\n\n                a = ff(a, b, c, d, blocks[4], 7, -176418897);\n                d = ff(d, a, b, c, blocks[5], 12, 1200080426);\n                c = ff(c, d, a, b, blocks[6], 17, -1473231341);\n                b = ff(b, c, d, a, blocks[7], 22, -45705983);\n\n                a = ff(a, b, c, d, blocks[8], 7, 1770035416);\n                d = ff(d, a, b, c, blocks[9], 12, -1958414417);\n                c = ff(c, d, a, b, blocks[10], 17, -42063);\n                b = ff(b, c, d, a, blocks[11], 22, -1990404162);\n\n                a = ff(a, b, c, d, blocks[12], 7, 1804603682);\n                d = ff(d, a, b, c, blocks[13], 12, -40341101);\n                c = ff(c, d, a, b, blocks[14], 17, -1502002290);\n                b = ff(b, c, d, a, blocks[15], 22, 1236535329);\n                // endregion\n                // region round 2\n                a = gg(a, b, c, d, blocks[1], 5, -165796510);\n                d = gg(d, a, b, c, blocks[6], 9, -1069501632);\n                c = gg(c, d, a, b, blocks[11], 14, 643717713);\n                b = gg(b, c, d, a, blocks[0], 20, -373897302);\n\n                a = gg(a, b, c, d, blocks[5], 5, -701558691);\n                d = gg(d, a, b, c, blocks[10], 9, 38016083);\n                c = gg(c, d, a, b, blocks[15], 14, -660478335);\n                b = gg(b, c, d, a, blocks[4], 20, -405537848);\n\n                a = gg(a, b, c, d, blocks[9], 5, 568446438);\n                d = gg(d, a, b, c, blocks[14], 9, -1019803690);\n                c = gg(c, d, a, b, blocks[3], 14, -187363961);\n                b = gg(b, c, d, a, blocks[8], 20, 1163531501);\n\n                a = gg(a, b, c, d, blocks[13], 5, -1444681467);\n                d = gg(d, a, b, c, blocks[2], 9, -51403784);\n                c = gg(c, d, a, b, blocks[7], 14, 1735328473);\n                b = gg(b, c, d, a, blocks[12], 20, -1926607734);\n                // endregion\n                // region round 3\n                a = hh(a, b, c, d, blocks[5], 4, -378558);\n                d = hh(d, a, b, c, blocks[8], 11, -2022574463);\n                c = hh(c, d, a, b, blocks[11], 16, 1839030562);\n                b = hh(b, c, d, a, blocks[14], 23, -35309556);\n\n                a = hh(a, b, c, d, blocks[1], 4, -1530992060);\n                d = hh(d, a, b, c, blocks[4], 11, 1272893353);\n                c = hh(c, d, a, b, blocks[7], 16, -155497632);\n                b = hh(b, c, d, a, blocks[10], 23, -1094730640);\n\n                a = hh(a, b, c, d, blocks[13], 4, 681279174);\n                d = hh(d, a, b, c, blocks[0], 11, -358537222);\n                c = hh(c, d, a, b, blocks[3], 16, -722521979);\n                b = hh(b, c, d, a, blocks[6], 23, 76029189);\n\n                a = hh(a, b, c, d, blocks[9], 4, -640364487);\n                d = hh(d, a, b, c, blocks[12], 11, -421815835);\n                c = hh(c, d, a, b, blocks[15], 16, 530742520);\n                b = hh(b, c, d, a, blocks[2], 23, -995338651);\n                // endregion\n                // region round 4\n                a = ii(a, b, c, d, blocks[0], 6, -198630844);\n                d = ii(d, a, b, c, blocks[7], 10, 1126891415);\n                c = ii(c, d, a, b, blocks[14], 15, -1416354905);\n                b = ii(b, c, d, a, blocks[5], 21, -57434055);\n\n                a = ii(a, b, c, d, blocks[12], 6, 1700485571);\n                d = ii(d, a, b, c, blocks[3], 10, -1894986606);\n                c = ii(c, d, a, b, blocks[10], 15, -1051523);\n                b = ii(b, c, d, a, blocks[1], 21, -2054922799);\n\n                a = ii(a, b, c, d, blocks[8], 6, 1873313359);\n                d = ii(d, a, b, c, blocks[15], 10, -30611744);\n                c = ii(c, d, a, b, blocks[6], 15, -1560198380);\n                b = ii(b, c, d, a, blocks[13], 21, 1309151649);\n\n                a = ii(a, b, c, d, blocks[4], 6, -145523070);\n                d = ii(d, a, b, c, blocks[11], 10, -1120210379);\n                c = ii(c, d, a, b, blocks[2], 15, 718787259);\n                b = ii(b, c, d, a, blocks[9], 21, -343485551);\n                // endregion\n                state[0] = unsignedModule2PowerOf32Addition(a, state[0]);\n                state[1] = unsignedModule2PowerOf32Addition(b, state[1]);\n                state[2] = unsignedModule2PowerOf32Addition(c, state[2]);\n                state[3] = unsignedModule2PowerOf32Addition(d, state[3]);\n                return state;\n            };\n            // / endregion\n            /**\n             * Converts given character to its corresponding hex code\n             * representation.\n             * @param character - Character to convert.\n             * @returns Converted hex code string.\n             */\n            var convertCharactorToHexCode = function convertCharactorToHexCode(character) {\n                var hexString = '';\n                for (var round = 0; round < 4; round++) {\n                    hexString += hexCharacters[character >> round * 8 + 4 & 0x0F] + hexCharacters[character >> round * 8 & 0x0F];\n                }return hexString;\n            };\n            /**\n             * Converts given byte array to its corresponding hex code as string.\n             * @param value - Array of characters to convert.\n             * @returns Converted hex code.\n             */\n            var convertToHexCode = function convertToHexCode(value) {\n                for (var index = 0; index < value.length; index++) {\n                    value[index] = convertCharactorToHexCode(value[index]);\n                }return value.join('');\n            };\n            /**\n             * There needs to be support for unicode here, unless we pretend that\n             * we can redefine the md5 algorithm for multi-byte characters\n             * (perhaps by adding every four 16-bit characters and shortening the\n             * sum to 32 bits). Otherwise I suggest performing md5 as if every\n             * character was two bytes--e.g., 0040 0025 = @%--but then how will an\n             * ordinary md5 sum be matched? There is no way to standardize text\n             * to something like utf-8 before transformation; speed cost is\n             * utterly prohibitive. The JavaScript standard itself needs to look\n             * at this: it should start providing access to strings as preformed\n             * utf-8 8-bit unsigned value arrays.\n             * @param value - Value to process with each block.\n             * @returns Converted byte array.\n             */\n            var handleBlock = function handleBlock(value) {\n                var blocks = [];\n                for (var blockNumber = 0; blockNumber < 64; blockNumber += 4) {\n                    blocks[blockNumber >> 2] = value.charCodeAt(blockNumber) + (value.charCodeAt(blockNumber + 1) << 8) + (value.charCodeAt(blockNumber + 2) << 16) + (value.charCodeAt(blockNumber + 3) << 24);\n                }return blocks;\n            };\n            // endregion\n            /**\n             * Triggers the main algorithm to calculate the md5 representation of\n             * given value.\n             * @param value - String to convert to its md5 representation.\n             * @returns Array of blocks.\n             */\n            var main = function main(value) {\n                var length = value.length;\n                var state = [1732584193, -271733879, -1732584194, 271733878];\n                var blockNumber = void 0;\n                for (blockNumber = 64; blockNumber <= value.length; blockNumber += 64) {\n                    cycle(state, handleBlock(value.substring(blockNumber - 64, blockNumber)));\n                }value = value.substring(blockNumber - 64);\n                var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n                for (blockNumber = 0; blockNumber < value.length; blockNumber++) {\n                    tail[blockNumber >> 2] |= value.charCodeAt(blockNumber) << (blockNumber % 4 << 3);\n                }tail[blockNumber >> 2] |= 0x80 << (blockNumber % 4 << 3);\n                if (blockNumber > 55) {\n                    cycle(state, tail);\n                    for (var index = 0; index < 16; index++) {\n                        tail[index] = 0;\n                    }\n                }\n                tail[14] = length * 8;\n                cycle(state, tail);\n                return state;\n            };\n            // region final call\n            if (convertToHexCode(main('hello')) !== '5d41402abc4b2a76b9719d911017c592')\n                /**\n                 * This function is much faster, so if possible we use it. Some IEs\n                 * are the only ones I know of that need the idiotic second\n                 * function, generated by an if clause in the end.\n                 * @private\n                 * @param first - First operand to add.\n                 * @param second - Second operant to add.\n                 * @returns The sum of both given operands.\n                */\n                unsignedModule2PowerOf32Addition = function unsignedModule2PowerOf32Addition(first, second) {\n                    var lsw = (first & 0xFFFF) + (second & 0xFFFF);\n                    var msw = (first >> 16) + (second >> 16) + (lsw >> 16);\n                    return msw << 16 | lsw & 0xFFFF;\n                };\n            // IgnoreTypeCheck\n            return convertToHexCode(main(onlyAscii ? value : unescape(encodeURIComponent(value))));\n            // endregion\n        }\n        /**\n         * Normalizes given phone number for automatic dialing mechanisms.\n         * @param phoneNumber - Number to normalize.\n         * @returns Normalized number.\n         */\n\n    }, {\n        key: 'stringNormalizePhoneNumber',\n        value: function stringNormalizePhoneNumber(phoneNumber) {\n            if (typeof phoneNumber === 'string' || typeof phoneNumber === 'number') return ('' + phoneNumber).replace(/[^0-9]*\\+/, '00').replace(/[^0-9]+/g, '');\n            return '';\n        }\n        /**\n         * Represents given phone number. NOTE: Currently only support german phone\n         * numbers.\n         * @param phoneNumber - Number to format.\n         * @returns Formatted number.\n         */\n\n    }, {\n        key: 'stringRepresentPhoneNumber',\n        value: function stringRepresentPhoneNumber(phoneNumber) {\n            if (['number', 'string'].includes(Tools.determineType(phoneNumber)) && phoneNumber) {\n                // Represent country code and leading area code zero.\n                phoneNumber = ('' + phoneNumber).replace(/^(00|\\+)([0-9]+)-([0-9-]+)$/, '+$2 (0) $3');\n                // Add German country code if not exists.\n                phoneNumber = phoneNumber.replace(/^0([1-9][0-9-]+)$/, '+49 (0) $1');\n                // Separate area code from base number.\n                phoneNumber = phoneNumber.replace(/^([^-]+)-([0-9-]+)$/, '$1 / $2');\n                // Partition base number in one triple and tuples or tuples only.\n                return phoneNumber.replace(/^(.*?)([0-9]+)(-?[0-9]*)$/, function (match, prefix, number, suffix) {\n                    return prefix + (number.length % 2 === 0 ? number.replace(/([0-9]{2})/g, '$1 ') : number.replace(/^([0-9]{3})([0-9]+)$/, function (match, triple, rest) {\n                        return triple + ' ' + rest.replace(/([0-9]{2})/g, '$1 ').trim();\n                    }) + suffix).trim();\n                }).trim();\n            }\n            return '';\n        }\n        /**\n         * Decodes all html symbols in text nodes in given html string.\n         * @param htmlString - HTML string to decode.\n         * @returns Decoded html string.\n         */\n\n    }, {\n        key: 'stringDecodeHTMLEntities',\n        value: function stringDecodeHTMLEntities(htmlString) {\n            if ('document' in $.global) {\n                var textareaDomNode = $.global.document.createElement('textarea');\n                textareaDomNode.innerHTML = htmlString;\n                return textareaDomNode.value;\n            }\n            return null;\n        }\n    }, {\n        key: 'numberIsNotANumber',\n        value: function numberIsNotANumber(object) {\n            return Tools.determineType(object) === 'number' && isNaN(object);\n        }\n        /**\n         * Rounds a given number accurate to given number of digits.\n         * @param number - The number to round.\n         * @param digits - The number of digits after comma.\n         * @returns Returns the rounded number.\n         */\n\n    }, {\n        key: 'numberRound',\n        value: function numberRound(number) {\n            var digits = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n            return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);\n        }\n        // / endregion\n        // / region data transfer\n        /**\n         * Send given data to a given iframe.\n         * @param target - Name of the target iframe or the target iframe itself.\n         * @param url - URL to send to data to.\n         * @param data - Data holding object to send data to.\n         * @param requestType - The forms action attribute value. If nothing is\n         * provided \"post\" will be used as default.\n         * @param removeAfterLoad - Indicates if created iframe should be removed\n         * right after load event. Only works if an iframe object is given instead\n         * of a simple target name.\n         * @returns Returns the given target.\n         */\n\n    }, {\n        key: 'sendToIFrame',\n        value: function sendToIFrame(target, url, data) {\n            var requestType = arguments.length <= 3 || arguments[3] === undefined ? 'post' : arguments[3];\n            var removeAfterLoad = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n\n            var targetName = typeof target === 'string' ? target : target.attr('name');\n            var $formDomNode = $('<form>').attr({\n                action: url,\n                method: requestType,\n                target: targetName\n            });\n            for (var _name4 in data) {\n                if (data.hasOwnProperty(_name4)) $formDomNode.append($('<input>').attr({\n                    type: 'hidden',\n                    name: _name4,\n                    value: data[_name4]\n                }));\n            }$formDomNode.submit().remove();\n            if (removeAfterLoad && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && 'on' in target)\n                // IgnoreTypeCheck\n                target.on('load', function () {\n                    return target.remove();\n                });\n            return targetName;\n        }\n    }]);\n\n    return Tools;\n}();\n// endregion\n// region handle $ extending\n\n\nTools.abbreviations = ['html', 'id', 'url', 'us', 'de', 'api', 'href'];\nTools.animationEndEventNames = 'animationend webkitAnimationEnd ' + 'oAnimationEnd MSAnimationEnd';\nTools.classToTypeMapping = {\n    '[object Array]': 'array',\n    '[object Boolean]': 'boolean',\n    '[object Date]': 'date',\n    '[object Error]': 'error',\n    '[object Function]': 'function',\n    '[object Number]': 'number',\n    '[object Object]': 'object',\n    '[object RegExp]': 'regexp',\n    '[object String]': 'string'\n};\nTools.keyCode = {\n    BACKSPACE: 8,\n    COMMA: 188,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    LEFT: 37,\n    NUMPAD_ADD: 107,\n    NUMPAD_DECIMAL: 110,\n    NUMPAD_DIVIDE: 111,\n    NUMPAD_ENTER: 108,\n    NUMPAD_MULTIPLY: 106,\n    NUMPAD_SUBTRACT: 109,\n    PAGE_DOWN: 34,\n    PAGE_UP: 33,\n    PERIOD: 190,\n    RIGHT: 39,\n    SPACE: 32,\n    TAB: 9,\n    UP: 38\n};\n\nTools.maximalSupportedInternetExplorerVersion = function () {\n    if (!('document' in $.global)) return 0;\n    var div = $.global.document.createElement('div');\n    var version = void 0;\n    for (version = 0; version < 10; version++) {\n        /*\n            NOTE: We split html comment sequences to avoid wrong\n            interpretation if this code is embedded in markup.\n            NOTE: Internet Explorer 9 and lower sometimes doesn't\n            understand conditional comments wich doesn't starts with a\n            whitespace. If the conditional markup isn't in a commend.\n            Otherwise there shouldn't be any whitespace!\n        */\n        /* eslint-disable no-useless-concat */\n        div.innerHTML = '<!' + ('--[if gt IE ' + version + ']><i></i><![e') + 'ndif]-' + '->';\n        /* eslint-enable no-useless-concat */\n        if (div.getElementsByTagName('i').length === 0) break;\n    }\n    // Try special detection for internet explorer 10 and 11.\n    if (version === 0 && 'navigator' in $.global) if ($.global.navigator.appVersion.includes('MSIE 10')) return 10;else if ($.global.navigator.userAgent.includes('Trident') && $.global.navigator.userAgent.includes('rv:11')) return 11;\n    return version;\n}();\n\nTools.noop = 'noop' in $ ? $.noop : function () {};\nTools.specialRegexSequences = ['-', '[', ']', '(', ')', '^', '$', '*', '+', '.', '{', '}'];\nTools.transitionEndEventNames = 'transitionend ' + 'webkitTransitionEnd oTransitionEnd MSTransitionEnd';\nTools.consoleMethodNames = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];\nTools._javaScriptDependentContentHandled = false;\nTools._name = 'Tools';\nexports.default = Tools;\nif ('fn' in $) $.fn.Tools = function () {\n    return new Tools().controller(Tools, arguments, this);\n};\n$.Tools = function () {\n    return new Tools().controller(Tools, arguments);\n};\n$.Tools.class = Tools;\n// / region prop fix for comments and text nodes\nif ('fn' in $) {\n    (function () {\n        var nativePropFunction = $.fn.prop;\n        /**\n         * JQuery's native prop implementation ignores properties for text nodes,\n         * comments and attribute nodes.\n         * @param key - Name of property to retrieve from current dom node.\n         * @param value - Value to set for given property by name.\n         * @returns Returns value if used as getter or current dom node if used as\n         * setter.\n         */\n        $.fn.prop = function (key, value) {\n            if (arguments.length < 3 && this.length && ['#text', '#comment'].includes(this[0].nodeName) && key in this[0]) {\n                if (arguments.length === 1) return this[0][key];\n                if (arguments.length === 2) {\n                    this[0][key] = value;\n                    return this;\n                }\n            }\n            return nativePropFunction.apply(this, arguments);\n        };\n    })();\n}\n// / endregion\n// endregion\n// region vim modline\n// vim: set tabstop=4 shiftwidth=4 expandtab:\n// vim: foldmethod=marker foldmarker=region,endregion:\n// endregion\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/webpack/buildin/module.js */ 2)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9pbmRleC5qcz8xNjg3Iiwid2VicGFjazovLy8/ZDQxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLy8gIyEvdXNyL2Jpbi9lbnYgbm9kZVxuLy8gLSotIGNvZGluZzogdXRmLTggLSotXG4vKiogQG1vZHVsZSBjbGllbnRub2RlICovXG4ndXNlIHN0cmljdCdcbi8qICFcbiAgICByZWdpb24gaGVhZGVyXG4gICAgW1Byb2plY3QgcGFnZV0oaHR0cDovL3RvcmJlbi53ZWJzaXRlL2NsaWVudG5vZGUpXG5cbiAgICBDb3B5cmlnaHQgVG9yYmVuIFNpY2tlcnQgKGluZm9bXCJ+YXR+XCJddG9yYmVuLndlYnNpdGUpIDE2LjEyLjIwMTJcblxuICAgIExpY2Vuc2VcbiAgICAtLS0tLS0tXG5cbiAgICBUaGlzIGxpYnJhcnkgd3JpdHRlbiBieSBUb3JiZW4gU2lja2VydCBzdGFuZCB1bmRlciBhIGNyZWF0aXZlIGNvbW1vbnNcbiAgICBuYW1pbmcgMy4wIHVucG9ydGVkIGxpY2Vuc2UuXG4gICAgU2VlIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LzMuMC9kZWVkLmRlXG4gICAgZW5kcmVnaW9uXG4qL1xuLy8gcmVnaW9uIGltcG9ydHNcbmltcG9ydCB0eXBlIHtEb21Ob2RlLCBQbGFpbk9iamVjdH0gZnJvbSAnd2Vib3B0aW1pemVyL3R5cGUnXG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiB0eXBlc1xuZXhwb3J0IHR5cGUgR2V0dGVyRnVuY3Rpb24gPSAoa2V5T3JWYWx1ZTphbnkpID0+IGFueVxuZXhwb3J0IHR5cGUgU2V0dGVyRnVuY3Rpb24gPSAoa2V5OmFueSwgdmFsdWU6YW55KSA9PiBhbnlcbmV4cG9ydCB0eXBlIFBvc2l0aW9uID0ge1xuICAgIHRvcD86bnVtYmVyO1xuICAgIGxlZnQ/Om51bWJlcjtcbiAgICByaWdodD86bnVtYmVyO1xuICAgIGJvdHRvbT86bnVtYmVyO1xufVxuZXhwb3J0IHR5cGUgUmVsYXRpdmVQb3NpdGlvbiA9ICdpbid8J2Fib3ZlJ3wnbGVmdCd8J2JlbG93J3wncmlnaHQnXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICAgIGRvbU5vZGVTZWxlY3RvclByZWZpeDpzdHJpbmc7XG4gICAgW2tleTpzdHJpbmddOmFueTtcbn1cbmV4cG9ydCB0eXBlIExvY2tDYWxsYmFja0Z1bmN0aW9uID0gKGRlc2NyaXB0aW9uOnN0cmluZykgPT4gdm9pZFxuZXhwb3J0IHR5cGUgJERvbU5vZGUgPSB7XG4gICAgW2tleTpudW1iZXJ8c3RyaW5nXTpEb21Ob2RlO1xuICAgIGFkZENsYXNzKGNsYXNzTmFtZTpzdHJpbmcpOiREb21Ob2RlO1xuICAgIGFkZEJhY2soKTokRG9tTm9kZTtcbiAgICBhZnRlcihkb21Ob2RlOmFueSk6JERvbU5vZGU7XG4gICAgYXBwZW5kKGRvbU5vZGU6YW55KTokRG9tTm9kZTtcbiAgICBhdHRyKGF0dHJpYnV0ZU5hbWU6c3RyaW5nfHtba2V5OnN0cmluZ106c3RyaW5nfSwgdmFsdWU6YW55KTphbnk7XG4gICAgZGF0YShrZXk6c3RyaW5nLCB2YWx1ZTphbnkpOmFueTtcbiAgICBlYWNoKCk6JERvbU5vZGU7XG4gICAgZmluZChmaWx0ZXI6YW55KTokRG9tTm9kZTtcbiAgICBoZWlnaHQoKTpudW1iZXI7XG4gICAgaXMoc2VsZWN0b3I6c3RyaW5nKTpib29sZWFuO1xuICAgIHJlbW92ZSgpOiREb21Ob2RlO1xuICAgIHJlbW92ZUF0dHIoYXR0cmlidXRlTmFtZTpzdHJpbmcpOiREb21Ob2RlO1xuICAgIHJlbW92ZUNsYXNzKGNsYXNzTmFtZTpzdHJpbmd8QXJyYXk8c3RyaW5nPik6JERvbU5vZGU7XG4gICAgc3VibWl0KCk6JERvbU5vZGU7XG4gICAgd2lkdGgoKTpudW1iZXI7XG4gICAgVG9vbHMoZnVuY3Rpb25OYW1lOnN0cmluZywgLi4uYWRkaXRpb25hbEFyZ3VtZW50czpBcnJheTxhbnk+KTphbnk7XG59XG5leHBvcnQgdHlwZSAkRGVmZXJyZWQ8VHlwZT4gPSB7XG4gICAgYWx3YXlzOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICByZXNvbHZlOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBkb25lOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBmYWlsOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBpc1JlamVjdGVkOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBpc1Jlc29sdmVkOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBub3RpZnk6KCkgPT4gJERlZmVycmVkPFR5cGU+O1xuICAgIG5vdGlmeVdpdGg6KCkgPT4gJERlZmVycmVkPFR5cGU+O1xuICAgIHByb2dyZXNzOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBwcm9taXNlOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICByZWplY3Q6KCkgPT4gJERlZmVycmVkPFR5cGU+O1xuICAgIHJlamVjdFdpdGg6KCkgPT4gJERlZmVycmVkPFR5cGU+O1xuICAgIHJlc29sdmVXaXRoOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBzdGF0ZTooKSA9PiAkRGVmZXJyZWQ8VHlwZT47XG4gICAgdGhlbjooKSA9PiAkRGVmZXJyZWQ8VHlwZT47XG59XG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiBkZXRlcm1pbmUgY29udGV4dFxuZXhwb3J0IGNvbnN0IGdsb2JhbENvbnRleHQ6T2JqZWN0ID0gKCgpOk9iamVjdCA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpID8ge30gOiBtb2R1bGVcbiAgICAgICAgaWYgKCd3aW5kb3cnIGluIGdsb2JhbClcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWwud2luZG93XG4gICAgICAgIHJldHVybiBnbG9iYWxcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvd1xufSkoKVxuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbmV4cG9ydCBjb25zdCAkID0gKCgpOmFueSA9PiB7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4gICAgbGV0ICQ6YW55XG4gICAgaWYgKCckJyBpbiBnbG9iYWxDb250ZXh0ICYmIGdsb2JhbENvbnRleHQuJCAhPT0gbnVsbClcbiAgICAgICAgJCA9IGdsb2JhbENvbnRleHQuJFxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoISgnJCcgaW4gZ2xvYmFsQ29udGV4dCkpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1aXJlKCdqcXVlcnknKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yOmFueSA9IChcbiAgICAgICAgICAgICdkb2N1bWVudCcgaW4gZ2xvYmFsQ29udGV4dCAmJlxuICAgICAgICAgICAgJ3F1ZXJ5U2VsZWN0b3JBbGwnIGluIGdsb2JhbENvbnRleHQuZG9jdW1lbnRcbiAgICAgICAgKSA/IGdsb2JhbENvbnRleHQuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCA6ICgpOm51bGwgPT4gbnVsbFxuICAgICAgICAkID0gZnVuY3Rpb24ocGFyYW1ldGVyOmFueSk6YW55IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRkb21Ob2RlczpBcnJheTxhbnk+ID0gc2VsZWN0b3IuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbENvbnRleHQuZG9jdW1lbnQsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICBpZiAoJ2ZuJyBpbiAkKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gJC5mbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmZuLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGRvbU5vZGVzW2tleV0gPSAkLmZuW2tleV0uYmluZCgkZG9tTm9kZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRkb21Ob2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbiAgICAgICAgICAgIGlmIChUb29scy5pc0Z1bmN0aW9uKHBhcmFtZXRlcikgJiYgJ2RvY3VtZW50JyBpbiBnbG9iYWxDb250ZXh0KVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuICAgICAgICAgICAgICAgIGdsb2JhbENvbnRleHQuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgJ0RPTUNvbnRlbnRMb2FkZWQnLCBwYXJhbWV0ZXIpXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyXG4gICAgICAgIH1cbiAgICAgICAgJC5mbiA9IHt9XG4gICAgfVxuICAgIHJldHVybiAkXG59KSgpXG5pZiAoISgnZ2xvYmFsJyBpbiAkKSlcbiAgICAkLmdsb2JhbCA9IGdsb2JhbENvbnRleHRcbmlmICghKCdjb250ZXh0JyBpbiAkKSAmJiAnZG9jdW1lbnQnIGluICQuZ2xvYmFsKVxuICAgICQuY29udGVzdCA9ICQuZ2xvYmFsLmRvY3VtZW50XG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiBwbHVnaW5zL2NsYXNzZXNcbi8qKlxuICogVGhpcyBwbHVnaW4gcHJvdmlkZXMgc3VjaCBpbnRlcmZhY2UgbG9naWMgbGlrZSBnZW5lcmljIGNvbnRyb2xsZXIgbG9naWMgZm9yXG4gKiBpbnRlZ3JhdGluZyBwbHVnaW5zIGludG8gJCwgbXV0dWFsIGV4Y2x1c2lvbiBmb3IgZGVwZW5kaW5nIGd1aSBlbGVtZW50cyxcbiAqIGxvZ2dpbmcgYWRkaXRpb25hbCBzdHJpbmcsIGFycmF5IG9yIGZ1bmN0aW9uIGhhbmRsaW5nLiBBIHNldCBvZiBoZWxwZXJcbiAqIGZ1bmN0aW9ucyB0byBwYXJzZSBvcHRpb24gb2JqZWN0cyBkb20gdHJlZXMgb3IgaGFuZGxlIGV2ZW50cyBpcyBhbHNvXG4gKiBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6YWJicmV2aWF0aW9ucyAtIExpc3RzIGFsbCBrbm93biBhYmJyZXZpYXRpb24gZm9yIHByb3BlclxuICogY2FtZWwgY2FzZSB0byBkZWxpbWl0ZWQgYW5kIGJhY2sgY29udmVyc2lvbi5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6YW5pbWF0aW9uRW5kRXZlbnROYW1lcyAtIFNhdmVzIGEgc3RyaW5nIHdpdGggYWxsIGNzczNcbiAqIGJyb3dzZXIgc3BlY2lmaWMgYW5pbWF0aW9uIGVuZCBldmVudCBuYW1lcy5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6a2V5Q29kZSAtIFNhdmVzIGEgbWFwcGluZyBmcm9tIGtleSBjb2RlcyB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBuYW1lLlxuICogQHByb3BlcnR5IHN0YXRpYzptYXhpbWFsU3VwcG9ydGVkSW50ZXJuZXRFeHBsb3JlclZlcnNpb24gLSBTYXZlcyBjdXJyZW50bHlcbiAqIG1pbmltYWwgc3VwcG9ydGVkIGludGVybmV0IGV4cGxvcmVyIHZlcnNpb24uIFNhdmVzIHplcm8gaWYgbm8gaW50ZXJuZXRcbiAqIGV4cGxvcmVyIHByZXNlbnQuXG4gKiBAcHJvcGVydHkgc3RhdGljOnRyYW5zaXRpb25FbmRFdmVudE5hbWVzIC0gU2F2ZXMgYSBzdHJpbmcgd2l0aCBhbGwgY3NzM1xuICogYnJvd3NlciBzcGVjaWZpYyB0cmFuc2l0aW9uIGVuZCBldmVudCBuYW1lcy5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6Y29uc29sZU1ldGhvZE5hbWVzIC0gVGhpcyB2YXJpYWJsZSBjb250YWlucyBhIGNvbGxlY3Rpb24gb2ZcbiAqIG1ldGhvZHMgdXN1YWxseSBiaW5kZWQgdG8gdGhlIGNvbnNvbGUgb2JqZWN0LlxuICogQHByb3BlcnR5IHN0YXRpYzpfamF2YVNjcmlwdERlcGVuZGVudENvbnRlbnRIYW5kbGVkIC0gSW5kaWNhdGVzIHdoZXRoZXJcbiAqIGphdmFTY3JpcHQgZGVwZW5kZW50IGNvbnRlbnQgd2hlcmUgaGlkZSBvciBzaG93bi5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6X25hbWUgLSBEZWZpbmVzIHRoaXMgY2xhc3MgbmFtZSB0byBhbGxvdyByZXRyaWV2aW5nIHRoZW1cbiAqIGFmdGVyIG5hbWUgbWFuZ2xpbmcuXG4gKiBAcHJvcGVydHkgJGRvbU5vZGUgLSAkLWV4dGVuZGVkIGRvbSBub2RlIGlmIG9uZSB3YXMgZ2l2ZW4gdG8gdGhlIGNvbnN0cnVjdG9yXG4gKiBtZXRob2QuXG4gKiBAcHJvcGVydHkgX29wdGlvbnMgLSBPcHRpb25zIGdpdmVuIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEBwcm9wZXJ0eSBfZGVmYXVsdE9wdGlvbnMgLSBGYWxsYmFjayBvcHRpb25zIGlmIG5vdCBvdmVyd3JpdHRlbiBieSB0aGVcbiAqIG9wdGlvbnMgZ2l2ZW4gdG8gdGhlIGNvbnN0cnVjdG9yIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSBfZGVmYXVsdE9wdGlvbnMubG9nZ2luZyB7Ym9vbGVhbn0gLSBJbmRpY2F0ZXMgd2hldGhlciBsb2dnaW5nXG4gKiBzaG91bGQgYmUgYWN0aXZlLlxuICogQHByb3BlcnR5IF9kZWZhdWx0T3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXgge3N0cmluZ30gLSBTZWxlY3RvciBwcmVmaXhcbiAqIGZvciBhbGwgbmVlZGVkIGRvbSBub2Rlcy5cbiAqIEBwcm9wZXJ0eSBfZGVmYXVsdE9wdGlvbnMuZG9tTm9kZSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IC0gTWFwcGluZyBvZlxuICogbmFtZXMgdG8gbmVlZGVkIGRvbSBub2RlcyByZWZlcmVuY2VkIGJ5IHRoZXJlIHNlbGVjdG9yLlxuICogQHByb3BlcnR5IF9kZWZhdWx0T3B0aW9ucy5kb21Ob2RlLmhpZGVKYXZhU2NyaXB0RW5hYmxlZCB7c3RyaW5nfSAtIFNlbGVjdG9yXG4gKiB0byBkb20gbm9kZXMgd2hpY2ggc2hvdWxkIGJlIGhpZGRlbiBpZiBqYXZhU2NyaXB0IGlzIGF2YWlsYWJsZS5cbiAqIEBwcm9wZXJ0eSBfZGVmYXVsdE9wdGlvbnMuZG9tTm9kZS5zaG93SmF2YVNjcmlwdEVuYWJsZWQge3N0cmluZ30gLSBTZWxlY3RvclxuICogdG8gZG9tIG5vZGVzIHdoaWNoIHNob3VsZCBiZSB2aXNpYmxlIGlmIGphdmFTY3JpcHQgaXMgYXZhaWxhYmxlLlxuICogQHByb3BlcnR5IF9sb2NrcyAtIE1hcHBpbmcgb2YgbG9jayBkZXNjcmlwdGlvbnMgdG8gdGhlcmUgY29ycmVzcG9uZGluZ1xuICogY2FsbGJhY2tzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29scyB7XG4gICAgLy8gcmVnaW9uIHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgc3RhdGljIGFiYnJldmlhdGlvbnM6QXJyYXk8c3RyaW5nPiA9IFtcbiAgICAgICAgJ2h0bWwnLCAnaWQnLCAndXJsJywgJ3VzJywgJ2RlJywgJ2FwaScsICdocmVmJ11cbiAgICBzdGF0aWMgYW5pbWF0aW9uRW5kRXZlbnROYW1lczpzdHJpbmcgPSAnYW5pbWF0aW9uZW5kIHdlYmtpdEFuaW1hdGlvbkVuZCAnICtcbiAgICAgICAgJ29BbmltYXRpb25FbmQgTVNBbmltYXRpb25FbmQnXG4gICAgc3RhdGljIGNsYXNzVG9UeXBlTWFwcGluZzp7W2tleTpzdHJpbmddOnN0cmluZ30gPSB7XG4gICAgICAgICdbb2JqZWN0IEFycmF5XSc6ICdhcnJheScsXG4gICAgICAgICdbb2JqZWN0IEJvb2xlYW5dJzogJ2Jvb2xlYW4nLFxuICAgICAgICAnW29iamVjdCBEYXRlXSc6ICdkYXRlJyxcbiAgICAgICAgJ1tvYmplY3QgRXJyb3JdJzogJ2Vycm9yJyxcbiAgICAgICAgJ1tvYmplY3QgRnVuY3Rpb25dJzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgJ1tvYmplY3QgTnVtYmVyXSc6ICdudW1iZXInLFxuICAgICAgICAnW29iamVjdCBPYmplY3RdJzogJ29iamVjdCcsXG4gICAgICAgICdbb2JqZWN0IFJlZ0V4cF0nOiAncmVnZXhwJyxcbiAgICAgICAgJ1tvYmplY3QgU3RyaW5nXSc6ICdzdHJpbmcnXG4gICAgfVxuICAgIHN0YXRpYyBrZXlDb2RlOntba2V5OnN0cmluZ106bnVtYmVyfSA9IHtcbiAgICAgICAgQkFDS1NQQUNFOiA4LFxuICAgICAgICBDT01NQTogMTg4LFxuICAgICAgICBERUxFVEU6IDQ2LFxuICAgICAgICBET1dOOiA0MCxcbiAgICAgICAgRU5EOiAzNSxcbiAgICAgICAgRU5URVI6IDEzLFxuICAgICAgICBFU0NBUEU6IDI3LFxuICAgICAgICBIT01FOiAzNixcbiAgICAgICAgTEVGVDogMzcsXG4gICAgICAgIE5VTVBBRF9BREQ6IDEwNyxcbiAgICAgICAgTlVNUEFEX0RFQ0lNQUw6IDExMCxcbiAgICAgICAgTlVNUEFEX0RJVklERTogMTExLFxuICAgICAgICBOVU1QQURfRU5URVI6IDEwOCxcbiAgICAgICAgTlVNUEFEX01VTFRJUExZOiAxMDYsXG4gICAgICAgIE5VTVBBRF9TVUJUUkFDVDogMTA5LFxuICAgICAgICBQQUdFX0RPV046IDM0LFxuICAgICAgICBQQUdFX1VQOiAzMyxcbiAgICAgICAgUEVSSU9EOiAxOTAsXG4gICAgICAgIFJJR0hUOiAzOSxcbiAgICAgICAgU1BBQ0U6IDMyLFxuICAgICAgICBUQUI6IDksXG4gICAgICAgIFVQOiAzOFxuICAgIH1cbiAgICBzdGF0aWMgbWF4aW1hbFN1cHBvcnRlZEludGVybmV0RXhwbG9yZXJWZXJzaW9uOm51bWJlciA9ICgoKTpudW1iZXIgPT4ge1xuICAgICAgICBpZiAoISgnZG9jdW1lbnQnIGluICQuZ2xvYmFsKSlcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIGNvbnN0IGRpdiA9ICQuZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGxldCB2ZXJzaW9uOm51bWJlclxuICAgICAgICBmb3IgKHZlcnNpb24gPSAwOyB2ZXJzaW9uIDwgMTA7IHZlcnNpb24rKykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBOT1RFOiBXZSBzcGxpdCBodG1sIGNvbW1lbnQgc2VxdWVuY2VzIHRvIGF2b2lkIHdyb25nXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0YXRpb24gaWYgdGhpcyBjb2RlIGlzIGVtYmVkZGVkIGluIG1hcmt1cC5cbiAgICAgICAgICAgICAgICBOT1RFOiBJbnRlcm5ldCBFeHBsb3JlciA5IGFuZCBsb3dlciBzb21ldGltZXMgZG9lc24ndFxuICAgICAgICAgICAgICAgIHVuZGVyc3RhbmQgY29uZGl0aW9uYWwgY29tbWVudHMgd2ljaCBkb2Vzbid0IHN0YXJ0cyB3aXRoIGFcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlLiBJZiB0aGUgY29uZGl0aW9uYWwgbWFya3VwIGlzbid0IGluIGEgY29tbWVuZC5cbiAgICAgICAgICAgICAgICBPdGhlcndpc2UgdGhlcmUgc2hvdWxkbid0IGJlIGFueSB3aGl0ZXNwYWNlIVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtY29uY2F0ICovXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gKFxuICAgICAgICAgICAgICAgICc8IScgKyBgLS1baWYgZ3QgSUUgJHt2ZXJzaW9ufV0+PGk+PC9pPjwhW2VgICsgJ25kaWZdLScgKyAnLT4nKVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11c2VsZXNzLWNvbmNhdCAqL1xuICAgICAgICAgICAgaWYgKGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBzcGVjaWFsIGRldGVjdGlvbiBmb3IgaW50ZXJuZXQgZXhwbG9yZXIgMTAgYW5kIDExLlxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCAmJiAnbmF2aWdhdG9yJyBpbiAkLmdsb2JhbClcbiAgICAgICAgICAgIGlmICgkLmdsb2JhbC5uYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmNsdWRlcygnTVNJRSAxMCcpKVxuICAgICAgICAgICAgICAgIHJldHVybiAxMFxuICAgICAgICAgICAgZWxzZSBpZiAoJC5nbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgICAnVHJpZGVudCdcbiAgICAgICAgICAgICkgJiYgJC5nbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygncnY6MTEnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMTFcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICB9KSgpXG4gICAgc3RhdGljIG5vb3AgPSAoJ25vb3AnIGluICQpID8gJC5ub29wIDogKCk6dm9pZCA9PiB7fVxuICAgIHN0YXRpYyBzcGVjaWFsUmVnZXhTZXF1ZW5jZXM6QXJyYXk8c3RyaW5nPiA9IFtcbiAgICAgICAgJy0nLCAnWycsICddJywgJygnLCAnKScsICdeJywgJyQnLCAnKicsICcrJywgJy4nLCAneycsICd9J11cbiAgICBzdGF0aWMgdHJhbnNpdGlvbkVuZEV2ZW50TmFtZXM6c3RyaW5nID0gJ3RyYW5zaXRpb25lbmQgJyArXG4gICAgICAgICd3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIE1TVHJhbnNpdGlvbkVuZCdcbiAgICBzdGF0aWMgY29uc29sZU1ldGhvZE5hbWVzOkFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICdhc3NlcnQnLFxuICAgICAgICAnY2xlYXInLFxuICAgICAgICAnY291bnQnLFxuICAgICAgICAnZGVidWcnLFxuICAgICAgICAnZGlyJyxcbiAgICAgICAgJ2RpcnhtbCcsXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgICdleGNlcHRpb24nLFxuICAgICAgICAnZ3JvdXAnLFxuICAgICAgICAnZ3JvdXBDb2xsYXBzZWQnLFxuICAgICAgICAnZ3JvdXBFbmQnLFxuICAgICAgICAnaW5mbycsXG4gICAgICAgICdsb2cnLFxuICAgICAgICAnbWFya1RpbWVsaW5lJyxcbiAgICAgICAgJ3Byb2ZpbGUnLFxuICAgICAgICAncHJvZmlsZUVuZCcsXG4gICAgICAgICd0YWJsZScsXG4gICAgICAgICd0aW1lJyxcbiAgICAgICAgJ3RpbWVFbmQnLFxuICAgICAgICAndGltZVN0YW1wJyxcbiAgICAgICAgJ3RyYWNlJyxcbiAgICAgICAgJ3dhcm4nXG4gICAgXVxuICAgIHN0YXRpYyBfamF2YVNjcmlwdERlcGVuZGVudENvbnRlbnRIYW5kbGVkOmJvb2xlYW4gPSBmYWxzZVxuICAgIHN0YXRpYyBfbmFtZTpzdHJpbmcgPSAnVG9vbHMnXG4gICAgLy8gZW5kcmVnaW9uXG4gICAgLy8gcmVnaW9uIGR5bmFtaWMgcHJvcGVydGllc1xuICAgICRkb21Ob2RlOiREb21Ob2RlXG4gICAgX29wdGlvbnM6T3B0aW9uc1xuICAgIF9kZWZhdWx0T3B0aW9uczpQbGFpbk9iamVjdFxuICAgIF9sb2Nrczp7W2tleTpzdHJpbmddOkFycmF5PExvY2tDYWxsYmFja0Z1bmN0aW9uPn07XG4gICAgLy8gZW5kcmVnaW9uXG4gICAgLy8gcmVnaW9uIHB1YmxpYyBtZXRob2RzXG4gICAgLy8gLyByZWdpb24gc3BlY2lhbFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBub3JtYWxseS4gSXQgaXMgdHJpZ2dlcmVkIGlmIGN1cnJlbnRcbiAgICAgKiBvYmplY3QgaXMgY3JlYXRlZCB2aWEgdGhlIFwibmV3XCIga2V5d29yZC4gVGhlIGRvbSBub2RlIHNlbGVjdG9yIHByZWZpeFxuICAgICAqIGVuZm9yY2VzIHRvIG5vdCBnbG9iYWxseSBzZWxlY3QgYW55IGRvbSBub2RlcyB3aGljaCBhcmVuJ3QgaW4gdGhlXG4gICAgICogZXhwZWN0ZWQgc2NvcGUgb2YgdGhpcyBwbHVnaW4uIFwiezF9XCIgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHdpdGhcbiAgICAgKiB0aGlzIHBsdWdpbiBuYW1lIHN1ZmZpeCAoXCJ0b29sc1wiKS4gWW91IGRvbid0IGhhdmUgdG8gdXNlIFwiezF9XCIgYnV0IGl0XG4gICAgICogY2FuIGhlbHAgeW91IHRvIHdyaXRlIGNvZGUgd2hpY2ggaXMgbW9yZSByZWNvbmNpbGFibGUgd2l0aCB0aGUgZHJ5XG4gICAgICogY29uY2VwdC5cbiAgICAgKiBAcGFyYW0gJGRvbU5vZGUgLSAkLWV4dGVuZGVkIGRvbSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UgaW4gdmFyaW91c1xuICAgICAqIG1ldGhvZHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNoYW5nZSBydW50aW1lIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0T3B0aW9ucyAtIERlZmF1bHQgb3B0aW9ucyB0byBlbnN1cmUgdG8gYmUgcHJlc2VudCBpbiBhbnlcbiAgICAgKiBvcHRpb25zIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBsb2NrcyAtIE1hcHBpbmcgb2YgYSBsb2NrIGRlc2NyaXB0aW9uIHRvIGNhbGxiYWNrcyBmb3IgY2FsbGluZ1xuICAgICAqIHdoZW4gZ2l2ZW4gbG9jayBzaG91bGQgYmUgcmVsZWFzZWQuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBub3RoaW5nIGJ1dCBpZiBpbnZva2VkIHdpdGggXCJuZXdcIiBhbiBpbnN0YW5jZSBvZiB0aGlzXG4gICAgICogY2xhc3Mgd2lsbCBiZSBnaXZlbiBiYWNrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAkZG9tTm9kZTo/JERvbU5vZGUgPSBudWxsLCBvcHRpb25zOk9iamVjdCA9IHt9LFxuICAgICAgICBkZWZhdWx0T3B0aW9uczpQbGFpbk9iamVjdCA9IHtcbiAgICAgICAgICAgIGxvZ2dpbmc6IGZhbHNlLCBkb21Ob2RlU2VsZWN0b3JQcmVmaXg6ICdib2R5JywgZG9tTm9kZToge1xuICAgICAgICAgICAgICAgIGhpZGVKYXZhU2NyaXB0RW5hYmxlZDogJy50b29scy1oaWRkZW4tb24tamF2YXNjcmlwdC1lbmFibGVkJyxcbiAgICAgICAgICAgICAgICBzaG93SmF2YVNjcmlwdEVuYWJsZWQ6ICcudG9vbHMtdmlzaWJsZS1vbi1qYXZhc2NyaXB0LWVuYWJsZWQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGxvY2tzOntba2V5OnN0cmluZ106QXJyYXk8TG9ja0NhbGxiYWNrRnVuY3Rpb24+fSA9IHt9XG4gICAgKTp2b2lkIHtcbiAgICAgICAgaWYgKCRkb21Ob2RlKVxuICAgICAgICAgICAgdGhpcy4kZG9tTm9kZSA9ICRkb21Ob2RlXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNcbiAgICAgICAgdGhpcy5fbG9ja3MgPSBsb2Nrc1xuICAgICAgICAvLyBBdm9pZCBlcnJvcnMgaW4gYnJvd3NlcnMgdGhhdCBsYWNrIGEgY29uc29sZS5cbiAgICAgICAgaWYgKCEoJ2NvbnNvbGUnIGluICQuZ2xvYmFsKSlcbiAgICAgICAgICAgICQuZ2xvYmFsLmNvbnNvbGUgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWU6c3RyaW5nIG9mIHRoaXMuY29uc3RydWN0b3IuY29uc29sZU1ldGhvZE5hbWVzKVxuICAgICAgICAgICAgaWYgKCEobWV0aG9kTmFtZSBpbiAkLmdsb2JhbC5jb25zb2xlKSlcbiAgICAgICAgICAgICAgICAkLmdsb2JhbC5jb25zb2xlW21ldGhvZE5hbWVdID0gdGhpcy5jb25zdHJ1Y3Rvci5ub29wXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF0aGlzLmNvbnN0cnVjdG9yLl9qYXZhU2NyaXB0RGVwZW5kZW50Q29udGVudEhhbmRsZWQgJiZcbiAgICAgICAgICAgICdkb2N1bWVudCcgaW4gJC5nbG9iYWwgJiYgJ2ZpbHRlcicgaW4gJCAmJiAnaGlkZScgaW4gJCAmJlxuICAgICAgICAgICAgJ3Nob3cnIGluICRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9qYXZhU2NyaXB0RGVwZW5kZW50Q29udGVudEhhbmRsZWQgPSB0cnVlXG4gICAgICAgICAgICAkKFxuICAgICAgICAgICAgICAgIGAke3RoaXMuX2RlZmF1bHRPcHRpb25zLmRvbU5vZGVTZWxlY3RvclByZWZpeH0gYCArXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMuZG9tTm9kZS5oaWRlSmF2YVNjcmlwdEVuYWJsZWRcbiAgICAgICAgICAgICkuZmlsdGVyKGZ1bmN0aW9uKCk6Ym9vbGVhbiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEkKHRoaXMpLmRhdGEoJ2phdmFTY3JpcHREZXBlbmRlbnRDb250ZW50SGlkZScpXG4gICAgICAgICAgICB9KS5kYXRhKCdqYXZhU2NyaXB0RGVwZW5kZW50Q29udGVudEhpZGUnLCB0cnVlKS5oaWRlKClcbiAgICAgICAgICAgICQoXG4gICAgICAgICAgICAgICAgYCR7dGhpcy5fZGVmYXVsdE9wdGlvbnMuZG9tTm9kZVNlbGVjdG9yUHJlZml4fSBgICtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0T3B0aW9ucy5kb21Ob2RlLnNob3dKYXZhU2NyaXB0RW5hYmxlZFxuICAgICAgICAgICAgKS5maWx0ZXIoZnVuY3Rpb24oKTpib29sZWFuIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISQodGhpcykuZGF0YSgnamF2YVNjcmlwdERlcGVuZGVudENvbnRlbnRTaG93JylcbiAgICAgICAgICAgIH0pLmRhdGEoJ2phdmFTY3JpcHREZXBlbmRlbnRDb250ZW50U2hvdycsIHRydWUpLnNob3coKVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNvdWxkIGJlIG92ZXJ3cml0dGVuIG5vcm1hbGx5LiBJdCBhY3RzIGxpa2UgYSBkZXN0cnVjdG9yLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGVzdHJ1Y3RvcigpOlRvb2xzIHtcbiAgICAgICAgaWYgKCdvZmYnIGluICQuZm4pXG4gICAgICAgICAgICB0aGlzLm9mZignKicpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBub3JtYWxseS4gSXQgaXMgdHJpZ2dlcmVkIGlmIGN1cnJlbnRcbiAgICAgKiBvYmplY3Qgd2FzIGNyZWF0ZWQgdmlhIHRoZSBcIm5ld1wiIGtleXdvcmQgYW5kIGlzIGNhbGxlZCBub3cuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGluaXRpYWxpemUob3B0aW9uczpQbGFpbk9iamVjdCA9IHt9KTpUb29scyB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICBOT1RFOiBXZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCBpbnN0YW5jZSB0byBhdm9pZFxuICAgICAgICAgICAgY2hhbmdpbmcgYSBzdGF0aWMgb3B0aW9ucyBvYmplY3QuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLmNvbnN0cnVjdG9yLmV4dGVuZE9iamVjdChcbiAgICAgICAgICAgIHRydWUsIHt9LCB0aGlzLl9kZWZhdWx0T3B0aW9ucywgdGhpcy5fb3B0aW9ucywgb3B0aW9ucylcbiAgICAgICAgLypcbiAgICAgICAgICAgIFRoZSBzZWxlY3RvciBwcmVmaXggc2hvdWxkIGJlIHBhcnNlZCBhZnRlciBleHRlbmRpbmcgb3B0aW9uc1xuICAgICAgICAgICAgYmVjYXVzZSB0aGUgc2VsZWN0b3Igd291bGQgYmUgb3ZlcndyaXR0ZW4gb3RoZXJ3aXNlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcHRpb25zLmRvbU5vZGVTZWxlY3RvclByZWZpeCA9IHRoaXMuY29uc3RydWN0b3Iuc3RyaW5nRm9ybWF0KFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXgsXG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN0cmluZ0NhbWVsQ2FzZVRvRGVsaW1pdGVkKHRoaXMuY29uc3RydWN0b3IuX25hbWUpKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIG9iamVjdCBvcmllbnRhdGlvblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb24tY29tcGxldGUtc2VudGVuY2UgKi9cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgZ2VuZXJpYyBjb250cm9sbGVyIGZvciBkb20gbm9kZSBhd2FyZSBwbHVnaW5zLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IG9yIGNsYXNzIHRvIGNvbnRyb2wuIElmIFwib2JqZWN0XCIgaXMgYSBjbGFzc1xuICAgICAqIGFuIGluc3RhbmNlIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXIgLSBUaGUgaW5pdGlhbGx5IGdpdmVuIGFyZ3VtZW50cyBvYmplY3QuXG4gICAgICogQHBhcmFtICRkb21Ob2RlIC0gT3B0aW9uYWxseSBhICQtZXh0ZW5kZWQgZG9tIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHdoYXRldmVyIHRoZSBpbml0aWFsaXplciBtZXRob2QgcmV0dXJucy5cbiAgICAgKi9cbiAgICBjb250cm9sbGVyKFxuICAgICAgICBvYmplY3Q6T2JqZWN0LCBwYXJhbWV0ZXI6QXJyYXk8YW55PiwgJGRvbU5vZGU6PyREb21Ob2RlID0gbnVsbFxuICAgICk6YW55IHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb24tY29tcGxldGUtc2VudGVuY2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG5ldyBvYmplY3QoJGRvbU5vZGUpXG4gICAgICAgICAgICBpZiAoIW9iamVjdCBpbnN0YW5jZW9mIFRvb2xzKVxuICAgICAgICAgICAgICAgIG9iamVjdCA9IHRoaXMuY29uc3RydWN0b3IuZXh0ZW5kT2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICB0cnVlLCBuZXcgVG9vbHMoKSwgb2JqZWN0KVxuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlciA9IHRoaXMuY29uc3RydWN0b3IuYXJyYXlNYWtlKHBhcmFtZXRlcilcbiAgICAgICAgaWYgKCRkb21Ob2RlICYmICdkYXRhJyBpbiAkZG9tTm9kZSAmJiAhJGRvbU5vZGUuZGF0YShcbiAgICAgICAgICAgIG9iamVjdC5jb25zdHJ1Y3Rvci5fbmFtZVxuICAgICAgICApKVxuICAgICAgICAgICAgLy8gQXR0YWNoIGV4dGVuZGVkIG9iamVjdCB0byB0aGUgYXNzb2NpYXRlZCBkb20gbm9kZS5cbiAgICAgICAgICAgICRkb21Ob2RlLmRhdGEob2JqZWN0LmNvbnN0cnVjdG9yLl9uYW1lLCBvYmplY3QpXG4gICAgICAgIGlmIChwYXJhbWV0ZXJbMF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtwYXJhbWV0ZXJbMF1dLmFwcGx5KG9iamVjdCwgcGFyYW1ldGVyLnNsaWNlKDEpKVxuICAgICAgICBlbHNlIGlmIChwYXJhbWV0ZXIubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBwYXJhbWV0ZXJbMF0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBJZiBhbiBvcHRpb25zIG9iamVjdCBvciBubyBtZXRob2QgbmFtZSBpcyBnaXZlbiB0aGUgaW5pdGlhbGl6ZXJcbiAgICAgICAgICAgICAgICB3aWxsIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0LmluaXRpYWxpemUuYXBwbHkob2JqZWN0LCBwYXJhbWV0ZXIpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYE1ldGhvZCBcIiR7cGFyYW1ldGVyWzBdfVwiIGRvZXMgbm90IGV4aXN0IG9uICQtZXh0ZW5kZWQgZG9tIG5vZGUgYCArXG4gICAgICAgICAgICBgXCIke29iamVjdC5jb25zdHJ1Y3Rvci5fbmFtZX1cIi5gKVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIG11dHVhbCBleGNsdXNpb25cbiAgICAvKipcbiAgICAgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIGludHJvZHVjZXMgYSBzdGFydGluZyBwb2ludCBmb3IgYSBjcml0aWNhbCBhcmVhIHdpdGhcbiAgICAgKiBwb3RlbnRpYWwgcmFjZSBjb25kaXRpb25zLiBUaGUgYXJlYSB3aWxsIGJlIGJpbmRlZCB0byBnaXZlbiBkZXNjcmlwdGlvblxuICAgICAqIHN0cmluZy4gU28gZG9uJ3QgdXNlIHNhbWUgbmFtZXMgZm9yIGRpZmZlcmVudCBhcmVhcy5cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gLSBBIHNob3J0IHN0cmluZyBkZXNjcmliaW5nIHRoZSBjcml0aWNhbCBhcmVhc1xuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrRnVuY3Rpb24gLSBBIHByb2NlZHVyZSB3aGljaCBzaG91bGQgb25seSBiZSBleGVjdXRlZCBpZlxuICAgICAqIHRoZSBpbnRlcnByZXRlciBpc24ndCBpbiB0aGUgZ2l2ZW4gY3JpdGljYWwgYXJlYS4gVGhlIGxvY2sgZGVzY3JpcHRpb25cbiAgICAgKiBzdHJpbmcgd2lsbCBiZSBnaXZlbiB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGF1dG9SZWxlYXNlIC0gUmVsZWFzZSB0aGUgbG9jayBhZnRlciBleGVjdXRpb24gb2YgZ2l2ZW4gY2FsbGJhY2suXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBhY3F1aXJlTG9jayhcbiAgICAgICAgZGVzY3JpcHRpb246c3RyaW5nLCBjYWxsYmFja0Z1bmN0aW9uOkxvY2tDYWxsYmFja0Z1bmN0aW9uLFxuICAgICAgICBhdXRvUmVsZWFzZTpib29sZWFuID0gZmFsc2VcbiAgICApOlRvb2xzIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrRnVuY3Rpb246TG9ja0NhbGxiYWNrRnVuY3Rpb24gPSAoXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjpzdHJpbmdcbiAgICAgICAgKTp2b2lkID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrRnVuY3Rpb24oZGVzY3JpcHRpb24pXG4gICAgICAgICAgICBpZiAoYXV0b1JlbGVhc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlTG9jayhkZXNjcmlwdGlvbilcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbG9ja3MuaGFzT3duUHJvcGVydHkoZGVzY3JpcHRpb24pKVxuICAgICAgICAgICAgdGhpcy5fbG9ja3NbZGVzY3JpcHRpb25dLnB1c2god3JhcHBlZENhbGxiYWNrRnVuY3Rpb24pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbG9ja3NbZGVzY3JpcHRpb25dID0gW11cbiAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFja0Z1bmN0aW9uKGRlc2NyaXB0aW9uKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxpbmcgdGhpcyBtZXRob2QgIGNhdXNlcyB0aGUgZ2l2ZW4gY3JpdGljYWwgYXJlYSB0byBiZSBmaW5pc2hlZCBhbmRcbiAgICAgKiBhbGwgZnVuY3Rpb25zIGdpdmVuIHRvIFwidGhpcy5hY3F1aXJlTG9jaygpXCIgd2lsbCBiZSBleGVjdXRlZCBpbiByaWdodFxuICAgICAqIG9yZGVyLlxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiAtIEEgc2hvcnQgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGNyaXRpY2FsIGFyZWFzXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbGVhc2VMb2NrKGRlc2NyaXB0aW9uOnN0cmluZyk6VG9vbHMge1xuICAgICAgICBpZiAodGhpcy5fbG9ja3MuaGFzT3duUHJvcGVydHkoZGVzY3JpcHRpb24pKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2tzW2Rlc2NyaXB0aW9uXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9ja3NbZGVzY3JpcHRpb25dLnNoaWZ0KCkoZGVzY3JpcHRpb24pXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvY2tzW2Rlc2NyaXB0aW9uXVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgaXRzIGFyZ3VtZW50IHJlcHJlc2VudHMgYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGFuYWx5emUuXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgbnVtZXJpY1xuICAgICAqIGxpa2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzTnVtZXJpYyhvYmplY3Q6YW55KTpib29sZWFuIHtcbiAgICAgICAgY29uc3QgdHlwZTpzdHJpbmcgPSBUb29scy5kZXRlcm1pbmVUeXBlKG9iamVjdClcbiAgICAgICAgLypcbiAgICAgICAgICAgIE5PVEU6IFwicGFyc2VGbG9hdFwiIFwiTmFOc1wiIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpIGJ1dFxuICAgICAgICAgICAgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzXG4gICAgICAgICAgICAoXCIweC4uLlwiKSBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU4uXG4gICAgICAgICovXG4gICAgICAgIHJldHVybiBbJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlKSAmJiAhaXNOYU4oXG4gICAgICAgICAgICBvYmplY3QgLSBwYXJzZUZsb2F0KG9iamVjdCkpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhIHdpbmRvdy5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNXaW5kb3cob2JqZWN0OmFueSk6Ym9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAhW3VuZGVmaW5lZCwgbnVsbF0uaW5jbHVkZXMob2JqZWN0KSAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgJ3dpbmRvdycgaW4gb2JqZWN0ICYmXG4gICAgICAgICAgICBvYmplY3QgPT09IG9iamVjdC53aW5kb3cpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiBvYmplY3QgaXMgc2ltaWxhciB0byBhbiBhcnJheSBhbmQgY2FuIGJlIGhhbmRsZWQgbGlrZSBhblxuICAgICAqIGFycmF5LlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgYmVoYXZpb3IgZm9yLlxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGFycmF5IGxpa2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzQXJyYXlMaWtlKG9iamVjdDphbnkpOmJvb2xlYW4ge1xuICAgICAgICBsZXQgbGVuZ3RoOm51bWJlcnxib29sZWFuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZW5ndGggPSBCb29sZWFuKFxuICAgICAgICAgICAgICAgIG9iamVjdFxuICAgICAgICAgICAgKSAmJiAnbGVuZ3RoJyBpbiBvYmplY3QgJiYgb2JqZWN0Lmxlbmd0aFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZTpzdHJpbmcgPSBUb29scy5kZXRlcm1pbmVUeXBlKG9iamVjdClcbiAgICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicgfHwgVG9vbHMuaXNXaW5kb3cob2JqZWN0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2FycmF5JyB8fCBsZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgICAgICAgICAgICAgb2JqZWN0W2xlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvbmUgb2YgdGhlIGdpdmVuIHBhdHRlcm4gbWF0Y2hlcyBnaXZlbiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRhcmdldCB0byBjaGVjayBpbiBwYXR0ZXJuIGZvci5cbiAgICAgKiBAcGFyYW0gcGF0dGVybiAtIExpc3Qgb2YgcGF0dGVybiB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybnMgVmFsdWUgXCJ0cnVlXCIgaWYgZ2l2ZW4gb2JqZWN0IGlzIG1hdGNoZXMgYnkgYXQgbGVhcyBvbmUgb2YgdGhlXG4gICAgICogZ2l2ZW4gcGF0dGVybiBhbmQgXCJmYWxzZVwiIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNBbnlNYXRjaGluZyh0YXJnZXQ6c3RyaW5nLCBwYXR0ZXJuOkFycmF5PHN0cmluZ3xSZWdFeHA+KTpib29sZWFuIHtcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50UGF0dGVybjpSZWdFeHB8c3RyaW5nIG9mIHBhdHRlcm4pXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRQYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGF0dGVybiA9PT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UGF0dGVybi50ZXN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHBsYWluIG5hdGl2ZSBvYmplY3QuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBcInRydWVcIiBpZiBnaXZlbiBvYmplY3QgaXMgYSBwbGFpbiBqYXZhU2NyaXB0IG9iamVjdCBhbmRcbiAgICAgKiBcImZhbHNlXCIgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1BsYWluT2JqZWN0KG9iamVjdDptaXhlZCk6Ym9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBPYmplY3QucHJvdG90eXBlKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFZhbHVlIFwidHJ1ZVwiIGlmIGdpdmVuIG9iamVjdCBpcyBhIGZ1bmN0aW9uIGFuZCBcImZhbHNlXCJcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24ob2JqZWN0Om1peGVkKTpib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqZWN0KSAmJiB7fS50b1N0cmluZy5jYWxsKFxuICAgICAgICAgICAgb2JqZWN0XG4gICAgICAgICkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICB9XG4gICAgLy8gLyBlbmRyZWdpb25cbiAgICAvLyAvIHJlZ2lvbiBsYW5ndWFnZSBmaXhlc1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGZpeGVzIGFuIHVnbHkgamF2YVNjcmlwdCBidWcuIElmIHlvdSBhZGQgYSBtb3VzZW91dCBldmVudFxuICAgICAqIGxpc3RlbmVyIHRvIGEgZG9tIG5vZGUgdGhlIGdpdmVuIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgZWFjaCB0aW1lIGFueVxuICAgICAqIGRvbSBub2RlIGluc2lkZSB0aGUgb2JzZXJ2ZWQgZG9tIG5vZGUgdHJpZ2dlcnMgYSBtb3VzZW91dCBldmVudC4gVGhpc1xuICAgICAqIG1ldGhvZHMgZ3VhcmFudGVlcyB0aGF0IHRoZSBnaXZlbiBldmVudCBoYW5kbGVyIGlzIG9ubHkgY2FsbGVkIGlmIHRoZVxuICAgICAqIG9ic2VydmVkIGRvbSBub2RlIHdhcyBsZWF2ZWQuXG4gICAgICogQHBhcmFtIGV2ZW50SGFuZGxlciAtIFRoZSBtb3VzZSBvdXQgZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBnaXZlbiBmdW5jdGlvbiB3cmFwcGVkIGJ5IHRoZSB3b3JrYXJvdW5kIGxvZ2ljLlxuICAgICAqL1xuICAgIHN0YXRpYyBtb3VzZU91dEV2ZW50SGFuZGxlckZpeChldmVudEhhbmRsZXI6RnVuY3Rpb24pOkZ1bmN0aW9uIHtcbiAgICAgICAgY29uc3Qgc2VsZjpPYmplY3QgPSB0aGlzXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudDpPYmplY3QpOmFueSB7XG4gICAgICAgICAgICBsZXQgcmVsYXRlZFRhcmdldDpEb21Ob2RlID0gZXZlbnQudG9FbGVtZW50XG4gICAgICAgICAgICBpZiAoJ3JlbGF0ZWRUYXJnZXQnIGluIGV2ZW50KVxuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0XG4gICAgICAgICAgICB3aGlsZSAocmVsYXRlZFRhcmdldCAmJiByZWxhdGVkVGFyZ2V0LnRhZ05hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldC5wYXJlbnROb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGxvZ2dpbmdcbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgZ2l2ZW4gb2JqZWN0J3MgcmVwcmVzZW50YXRpb24gaW4gdGhlIGJyb3dzZXJzIGNvbnNvbGUgaWZcbiAgICAgKiBwb3NzaWJsZSBvciBpbiBhIHN0YW5kYWxvbmUgYWxlcnQtd2luZG93IGFzIGZhbGxiYWNrLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBBbnkgb2JqZWN0IHRvIHByaW50LlxuICAgICAqIEBwYXJhbSBmb3JjZSAtIElmIHNldCB0byBcInRydWVcIiBnaXZlbiBpbnB1dCB3aWxsIGJlIHNob3duIGluZGVwZW5kZW50bHlcbiAgICAgKiBmcm9tIGN1cnJlbnQgbG9nZ2luZyBjb25maWd1cmF0aW9uIG9yIGludGVycHJldGVyJ3MgY29uc29sZVxuICAgICAqIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSBhdm9pZEFubm90YXRpb24gLSBJZiBzZXQgdG8gXCJ0cnVlXCIgZ2l2ZW4gaW5wdXQgaGFzIG5vIG1vZHVsZSBvclxuICAgICAqIGxvZyBsZXZlbCBzcGVjaWZpYyBhbm5vdGF0aW9ucy5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgLSBEZXNjcmlwdGlvbiBvZiBsb2cgbWVzc2FnZXMgaW1wb3J0YW5jZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIGZvciBzdHJpbmdcbiAgICAgKiBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBsb2coXG4gICAgICAgIG9iamVjdDphbnksIGZvcmNlOmJvb2xlYW4gPSBmYWxzZSwgYXZvaWRBbm5vdGF0aW9uOmJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgbGV2ZWw6c3RyaW5nID0gJ2luZm8nLCAuLi5hZGRpdGlvbmFsQXJndW1lbnRzOkFycmF5PGFueT5cbiAgICApOlRvb2xzIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubG9nZ2luZyB8fCBmb3JjZSB8fCBbJ2Vycm9yJywgJ2NyaXRpY2FsJ10uaW5jbHVkZXMoXG4gICAgICAgICAgICBsZXZlbFxuICAgICAgICApKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZTphbnlcbiAgICAgICAgICAgIGlmIChhdm9pZEFubm90YXRpb24pXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG9iamVjdFxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzLnVuc2hpZnQob2JqZWN0KVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLmNvbnN0cnVjdG9yLl9uYW1lfSAoJHtsZXZlbH0pOiBgICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdHJpbmdGb3JtYXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLCBhZGRpdGlvbmFsQXJndW1lbnRzKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnN0cnVjdG9yLmlzTnVtZXJpYyhcbiAgICAgICAgICAgICAgICBvYmplY3RcbiAgICAgICAgICAgICkgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLmNvbnN0cnVjdG9yLl9uYW1lfSAoJHtsZXZlbH0pOiBgICtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnRvU3RyaW5nKClcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCcsLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0sJylcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhvYmplY3QsIGZvcmNlLCB0cnVlKVxuICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1wiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgaWYgKCEoJ2NvbnNvbGUnIGluICQuZ2xvYmFsICYmIGxldmVsIGluICQuZ2xvYmFsLmNvbnNvbGUpIHx8IChcbiAgICAgICAgICAgICAgICAgICAgJC5nbG9iYWwuY29uc29sZVtsZXZlbF0gPT09IHRoaXMuY29uc3RydWN0b3Iubm9vcFxuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdhbGVydCcgaW4gJC5nbG9iYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmdsb2JhbC5hbGVydChtZXNzYWdlKVxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAkLmdsb2JhbC5jb25zb2xlW2xldmVsXShtZXNzYWdlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgbWV0aG9kIGZvciB0aGUgbmF0aXZlIGNvbnNvbGUgbWV0aG9kIHVzdWFsbHkgcHJvdmlkZWQgYnlcbiAgICAgKiBpbnRlcnByZXRlci5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gQW55IG9iamVjdCB0byBwcmludC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIGZvciBzdHJpbmdcbiAgICAgKiBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBpbmZvKG9iamVjdDphbnksIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55Pik6VG9vbHMge1xuICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nLmFwcGx5KHRoaXMsIFtvYmplY3QsIGZhbHNlLCBmYWxzZSwgJ2luZm8nXS5jb25jYXQoXG4gICAgICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzKSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBtZXRob2QgZm9yIHRoZSBuYXRpdmUgY29uc29sZSBtZXRob2QgdXN1YWxseSBwcm92aWRlZCBieVxuICAgICAqIGludGVycHJldGVyLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBBbnkgb2JqZWN0IHRvIHByaW50LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQXJndW1lbnRzIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgZm9yIHN0cmluZ1xuICAgICAqIGZvcm1hdGluZy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGRlYnVnKG9iamVjdDphbnksIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55Pik6VG9vbHMge1xuICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nLmFwcGx5KHRoaXMsIFtvYmplY3QsIGZhbHNlLCBmYWxzZSwgJ2RlYnVnJ10uY29uY2F0KFxuICAgICAgICAgICAgYWRkaXRpb25hbEFyZ3VtZW50cykpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgbWV0aG9kIGZvciB0aGUgbmF0aXZlIGNvbnNvbGUgbWV0aG9kIHVzdWFsbHkgcHJvdmlkZWQgYnlcbiAgICAgKiBpbnRlcnByZXRlci5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gQW55IG9iamVjdCB0byBwcmludC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIGZvciBzdHJpbmdcbiAgICAgKiBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBlcnJvcihvYmplY3Q6YW55LCAuLi5hZGRpdGlvbmFsQXJndW1lbnRzOkFycmF5PGFueT4pOlRvb2xzIHtcbiAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgIHJldHVybiB0aGlzLmxvZy5hcHBseSh0aGlzLCBbb2JqZWN0LCB0cnVlLCBmYWxzZSwgJ2Vycm9yJ10uY29uY2F0KFxuICAgICAgICAgICAgYWRkaXRpb25hbEFyZ3VtZW50cykpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgbWV0aG9kIGZvciB0aGUgbmF0aXZlIGNvbnNvbGUgbWV0aG9kIHVzdWFsbHkgcHJvdmlkZWQgYnlcbiAgICAgKiBpbnRlcnByZXRlci5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gQW55IG9iamVjdCB0byBwcmludC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIGZvciBzdHJpbmdcbiAgICAgKiBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjcml0aWNhbChvYmplY3Q6YW55LCAuLi5hZGRpdGlvbmFsQXJndW1lbnRzOkFycmF5PGFueT4pOlRvb2xzIHtcbiAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgIHJldHVybiB0aGlzLmxvZy5hcHBseSh0aGlzLCBbb2JqZWN0LCB0cnVlLCBmYWxzZSwgJ3dhcm4nXS5jb25jYXQoXG4gICAgICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzKSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBtZXRob2QgZm9yIHRoZSBuYXRpdmUgY29uc29sZSBtZXRob2QgdXN1YWxseSBwcm92aWRlZCBieVxuICAgICAqIGludGVycHJldGVyLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBBbnkgb2JqZWN0IHRvIHByaW50LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQXJndW1lbnRzIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgZm9yIHN0cmluZ1xuICAgICAqIGZvcm1hdGluZy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHdhcm4ob2JqZWN0OmFueSwgLi4uYWRkaXRpb25hbEFyZ3VtZW50czpBcnJheTxhbnk+KTpUb29scyB7XG4gICAgICAgIC8vIElnbm9yZVR5cGVDaGVja1xuICAgICAgICByZXR1cm4gdGhpcy5sb2cuYXBwbHkodGhpcywgW29iamVjdCwgZmFsc2UsIGZhbHNlLCAnd2FybiddLmNvbmNhdChcbiAgICAgICAgICAgIGFkZGl0aW9uYWxBcmd1bWVudHMpKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEdW1wcyBhIGdpdmVuIG9iamVjdCBpbiBhIGh1bWFuIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gQW55IG9iamVjdCB0byBzaG93LlxuICAgICAqIEBwYXJhbSBsZXZlbCAtIE51bWJlciBvZiBsZXZlbHMgdG8gZGlnIGludG8gZ2l2ZW4gb2JqZWN0IHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwYXJhbSBjdXJyZW50TGV2ZWwgLSBNYXhpbWFsIG51bWJlciBvZiByZWN1cnNpdmUgZnVuY3Rpb24gY2FsbHMgdG9cbiAgICAgKiByZXByZXNlbnQgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiBnaXZlbiBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIHNob3cob2JqZWN0OmFueSwgbGV2ZWw6bnVtYmVyID0gMywgY3VycmVudExldmVsOm51bWJlciA9IDApOnN0cmluZyB7XG4gICAgICAgIGxldCBvdXRwdXQ6c3RyaW5nID0gJydcbiAgICAgICAgaWYgKFRvb2xzLmRldGVybWluZVR5cGUob2JqZWN0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBvYmplY3QpXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBgJHtrZXkudG9TdHJpbmcoKX06IGBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA8PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBUb29scy5zaG93KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBsZXZlbCwgY3VycmVudExldmVsICsgMSlcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAke29iamVjdFtrZXldfWBcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9ICdcXG4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC50cmltKClcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSBgJHtvYmplY3R9YC50cmltKClcbiAgICAgICAgcmV0dXJuIGAke291dHB1dH0gKFR5cGU6IFwiJHtUb29scy5kZXRlcm1pbmVUeXBlKG9iamVjdCl9XCIpYFxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGRvbSBub2RlXG4gICAgLyoqXG4gICAgICogR2V0IHRleHQgY29udGVudCBvZiBjdXJyZW50IGVsZW1lbnQgd2l0aG91dCBpdCBjaGlsZHJlbidzIHRleHQgY29udGVudHMuXG4gICAgICogQHJldHVybnMgVGhlIHRleHQgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldFRleHQoKTpzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy4kZG9tTm9kZS5jbG9uZSgpLmNoaWxkcmVuKCkucmVtb3ZlKCkuZW5kKCkudGV4dCgpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgY2xhc3MgbmFtZSBvcmRlciBvZiBjdXJyZW50IGRvbSBub2RlLlxuICAgICAqIEByZXR1cm5zIEN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgbm9ybWFsaXplQ2xhc3NOYW1lcygpOlRvb2xzIHtcbiAgICAgICAgdGhpcy4kZG9tTm9kZS5maW5kKCcqJykuYWRkQmFjaygpLmVhY2goZnVuY3Rpb24oKTp2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzRG9tTm9kZTokRG9tTm9kZSA9ICQodGhpcylcbiAgICAgICAgICAgIGlmICgkdGhpc0RvbU5vZGUuYXR0cignY2xhc3MnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZENsYXNzTmFtZXM6QXJyYXk8c3RyaW5nPiA9ICR0aGlzRG9tTm9kZS5hdHRyKFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnXG4gICAgICAgICAgICAgICAgKS5zcGxpdCgnICcpLnNvcnQoKSB8fCBbXVxuICAgICAgICAgICAgICAgICR0aGlzRG9tTm9kZS5hdHRyKCdjbGFzcycsICcnKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2xhc3NOYW1lOnN0cmluZyBvZiBzb3J0ZWRDbGFzc05hbWVzKVxuICAgICAgICAgICAgICAgICAgICAkdGhpc0RvbU5vZGUuYWRkQ2xhc3MoY2xhc3NOYW1lKVxuICAgICAgICAgICAgfSBlbHNlIGlmICgkdGhpc0RvbU5vZGUuaXMoJ1tjbGFzc10nKSlcbiAgICAgICAgICAgICAgICAkdGhpc0RvbU5vZGUucmVtb3ZlQXR0cignY2xhc3MnKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHN0eWxlIGF0dHJpYnV0ZXMgb3JkZXIgb2YgY3VycmVudCBkb20gbm9kZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgbm9ybWFsaXplU3R5bGVzKCk6VG9vbHMge1xuICAgICAgICBjb25zdCBzZWxmOlRvb2xzID0gdGhpc1xuICAgICAgICB0aGlzLiRkb21Ob2RlLmZpbmQoJyonKS5hZGRCYWNrKCkuZWFjaChmdW5jdGlvbigpOnZvaWQge1xuICAgICAgICAgICAgY29uc3QgJHRoaXNEb21Ob2RlOiREb21Ob2RlID0gJCh0aGlzKVxuICAgICAgICAgICAgbGV0IHNlcmlhbGl6ZWRTdHlsZXM6P3N0cmluZyA9ICR0aGlzRG9tTm9kZS5hdHRyKCdzdHlsZScpXG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZFN0eWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZFN0eWxlczpBcnJheTxzdHJpbmc+ID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25zdHJ1Y3Rvci5zdHJpbmdDb21wcmVzc1N0eWxlVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkU3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICkuc3BsaXQoJzsnKS5zb3J0KCkgfHwgW11cbiAgICAgICAgICAgICAgICAkdGhpc0RvbU5vZGUuYXR0cignc3R5bGUnLCAnJylcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0eWxlOnN0cmluZyBvZiBzb3J0ZWRTdHlsZXMpXG4gICAgICAgICAgICAgICAgICAgICR0aGlzRG9tTm9kZS5jc3MuYXBwbHkoJHRoaXNEb21Ob2RlLCBzdHlsZS50cmltKCkuc3BsaXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnOicpKVxuICAgICAgICAgICAgICAgICR0aGlzRG9tTm9kZS5hdHRyKFxuICAgICAgICAgICAgICAgICAgICAnc3R5bGUnLCBzZWxmLmNvbnN0cnVjdG9yLnN0cmluZ0NvbXByZXNzU3R5bGVWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzRG9tTm9kZS5hdHRyKCdzdHlsZScpKSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHRoaXNEb21Ob2RlLmlzKCdbc3R5bGVdJykpXG4gICAgICAgICAgICAgICAgJHRoaXNEb21Ob2RlLnJlbW92ZUF0dHIoJ3N0eWxlJylcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gaHRtbCBvciB0ZXh0IHN0cmluZ3MgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSBmaXJzdCAtIEZpcnN0IGh0bWwsIHNlbGVjdG9yIHRvIGRvbSBub2RlIG9yIHRleHQgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIC0gU2Vjb25kIGh0bWwsIHNlbGVjdG9yIHRvIGRvbSBub2RlICBvciB0ZXh0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIGZvcmNlSFRNTFN0cmluZyAtIEluZGljYXRlcyB3aGV0aGVyIGdpdmVuIGNvbnRlbnRzIGFyZVxuICAgICAqIGludGVycHJldGVkIGFzIGh0bWwgc3RyaW5nIChvdGhlcndpc2UgYW4gYXV0b21hdGljIGRldGVjdGlvbiB3aWxsIGJlXG4gICAgICogdHJpZ2dlcmVkKS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgYm90aCBkb20gcmVwcmVzZW50YXRpb25zIGFyZSBlcXVpdmFsZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VxdWl2YWxlbnREb20oXG4gICAgICAgIGZpcnN0OmFueSwgc2Vjb25kOmFueSwgZm9yY2VIVE1MU3RyaW5nOmJvb2xlYW4gPSBmYWxzZVxuICAgICk6Ym9vbGVhbiB7XG4gICAgICAgIGlmIChmaXJzdCA9PT0gc2Vjb25kKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgaWYgKGZpcnN0ICYmIHNlY29uZCkge1xuICAgICAgICAgICAgY29uc3QgZGV0ZW1lcm1pbmVIVE1MUGF0dGVybjpSZWdFeHAgPVxuICAgICAgICAgICAgICAgIC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvXG4gICAgICAgICAgICBjb25zdCBpbnB1dHM6e2ZpcnN0OmFueTtzZWNvbmQ6YW55fSA9IHtmaXJzdCwgc2Vjb25kfVxuICAgICAgICAgICAgY29uc3QgJGRvbU5vZGVzOntmaXJzdDokRG9tTm9kZTtzZWNvbmQ6JERvbU5vZGV9ID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0OiAkKCc8ZHVtbXk+JyksIHNlY29uZDogJCgnPGR1bW15PicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIE5PVEU6IEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBcIjxcIiBhbmQgZW5kIHdpdGggXCI+XCIgYXJlXG4gICAgICAgICAgICAgICAgbWFya3VwIGFuZCBza2lwIHRoZSBtb3JlIGV4cGVuc2l2ZSByZWd1bGFyIGV4cHJlc3Npb24gY2hlY2suXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlOnN0cmluZyBvZiBbJ2ZpcnN0JywgJ3NlY29uZCddKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRzW3R5cGVdID09PSAnc3RyaW5nJyAmJiAoZm9yY2VIVE1MU3RyaW5nIHx8IChcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzW3R5cGVdLnN0YXJ0c1dpdGgoJzwnKSAmJlxuICAgICAgICAgICAgICAgICAgICBpbnB1dHNbdHlwZV0uZW5kc1dpdGgoJz4nKSAmJiBpbnB1dHNbdHlwZV0ubGVuZ3RoID49IDMgfHxcbiAgICAgICAgICAgICAgICAgICAgZGV0ZW1lcm1pbmVIVE1MUGF0dGVybi50ZXN0KGlucHV0c1t0eXBlXSlcbiAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICAgICAgJGRvbU5vZGVzW3R5cGVdID0gJChgPGRpdj4ke2lucHV0c1t0eXBlXX08L2Rpdj5gKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCAkc2VsZWN0ZWREb21Ob2RlOiREb21Ob2RlID0gJChpbnB1dHNbdHlwZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNlbGVjdGVkRG9tTm9kZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGRvbU5vZGVzW3R5cGVdID0gJCgnPGRpdj4nKS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZWxlY3RlZERvbU5vZGUuY2xvbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJGRvbU5vZGVzLmZpcnN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICRkb21Ob2Rlcy5maXJzdC5sZW5ndGggPT09ICRkb21Ob2Rlcy5zZWNvbmQubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAkZG9tTm9kZXMuZmlyc3QgPSAkZG9tTm9kZXMuZmlyc3QuVG9vbHMoXG4gICAgICAgICAgICAgICAgICAgICdub3JtYWxpemVDbGFzc05hbWVzJ1xuICAgICAgICAgICAgICAgICkuJGRvbU5vZGUuVG9vbHMoJ25vcm1hbGl6ZVN0eWxlcycpLiRkb21Ob2RlXG4gICAgICAgICAgICAgICAgJGRvbU5vZGVzLnNlY29uZCA9ICRkb21Ob2Rlcy5zZWNvbmQuVG9vbHMoXG4gICAgICAgICAgICAgICAgICAgICdub3JtYWxpemVDbGFzc05hbWVzJ1xuICAgICAgICAgICAgICAgICkuJGRvbU5vZGUuVG9vbHMoJ25vcm1hbGl6ZVN0eWxlcycpLiRkb21Ob2RlXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4Om51bWJlciA9IDBcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRvbU5vZGU6RG9tTm9kZSBvZiAkZG9tTm9kZXMuZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZS5pc0VxdWFsTm9kZSgkZG9tTm9kZXMuc2Vjb25kW2luZGV4XSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXJlIGN1cnJlbnQgZG9tIG5vZGUgaXMgcmVsYXRpdmUgdG8gY3VycmVudCB2aWV3IHBvcnRcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gZGVsdGEgLSBBbGxvd3MgZGVsdGFzIGZvciBcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiBhbmQgXCJyaWdodFwiIGZvclxuICAgICAqIGRldGVybWluaW5nIHBvc2l0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIG9uZSBvZiBcImFib3ZlXCIsIFwibGVmdFwiLCBcImJlbG93XCIsIFwicmlnaHRcIiBvciBcImluXCIuXG4gICAgICovXG4gICAgZ2V0UG9zaXRpb25SZWxhdGl2ZVRvVmlld3BvcnQoZGVsdGE6UG9zaXRpb24gPSB7fSk6UmVsYXRpdmVQb3NpdGlvbiB7XG4gICAgICAgIGRlbHRhID0gdGhpcy5jb25zdHJ1Y3Rvci5leHRlbmRPYmplY3QoXG4gICAgICAgICAgICB7dG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IDAsIHJpZ2h0OiAwfSwgZGVsdGEpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICd3aW5kb3cnIGluICQuZ2xvYmFsICYmIHRoaXMuJGRvbU5vZGUgJiYgdGhpcy4kZG9tTm9kZS5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMuJGRvbU5vZGVbMF1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCAkd2luZG93OiREb21Ob2RlID0gJCgkLmdsb2JhbC53aW5kb3cpXG4gICAgICAgICAgICBjb25zdCByZWN0YW5nbGU6UG9zaXRpb24gPSB0aGlzLiRkb21Ob2RlWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICBpZiAoKHJlY3RhbmdsZS50b3AgKyBkZWx0YS50b3ApIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Fib3ZlJ1xuICAgICAgICAgICAgaWYgKChyZWN0YW5nbGUubGVmdCArIGRlbHRhLmxlZnQpIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2xlZnQnXG4gICAgICAgICAgICBpZiAoJHdpbmRvdy5oZWlnaHQoKSA8IChyZWN0YW5nbGUuYm90dG9tICsgZGVsdGEuYm90dG9tKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2JlbG93J1xuICAgICAgICAgICAgaWYgKCR3aW5kb3cud2lkdGgoKSA8IChyZWN0YW5nbGUucmlnaHQgKyBkZWx0YS5yaWdodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdyaWdodCdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2luJ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBkaXJlY3RpdmUgbmFtZSBjb3JyZXNwb25kaW5nIHNlbGVjdG9yIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZGlyZWN0aXZlTmFtZSAtIFRoZSBkaXJlY3RpdmUgbmFtZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGdlbmVyYXRlZCBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGVEaXJlY3RpdmVTZWxlY3RvcihkaXJlY3RpdmVOYW1lOnN0cmluZyk6c3RyaW5nIHtcbiAgICAgICAgY29uc3QgZGVsaW1pdGVkTmFtZTpzdHJpbmcgPSBUb29scy5zdHJpbmdDYW1lbENhc2VUb0RlbGltaXRlZChcbiAgICAgICAgICAgIGRpcmVjdGl2ZU5hbWUpXG4gICAgICAgIHJldHVybiBgJHtkZWxpbWl0ZWROYW1lfSwgLiR7ZGVsaW1pdGVkTmFtZX0sIFske2RlbGltaXRlZE5hbWV9XSwgYCArXG4gICAgICAgICAgICBgW2RhdGEtJHtkZWxpbWl0ZWROYW1lfV0sIFt4LSR7ZGVsaW1pdGVkTmFtZX1dYCArIChcbiAgICAgICAgICAgICAgICAoZGVsaW1pdGVkTmFtZS5pbmNsdWRlcygnLScpID8gKFxuICAgICAgICAgICAgICAgICAgICBgLCBbJHtkZWxpbWl0ZWROYW1lLnJlcGxhY2UoLy0vZywgJ1xcXFw6Jyl9XSwgYCArXG4gICAgICAgICAgICAgICAgICAgIGBbJHtkZWxpbWl0ZWROYW1lLnJlcGxhY2UoLy0vZywgJ18nKX1dYCkgOiAnJykpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkaXJlY3RpdmUgbmFtZSBjb3JyZXNwb25kaW5nIGNsYXNzIG9yIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gZGlyZWN0aXZlTmFtZSAtIFRoZSBkaXJlY3RpdmUgbmFtZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGN1cnJlbnQgZG9tIG5vZGUuXG4gICAgICovXG4gICAgcmVtb3ZlRGlyZWN0aXZlKGRpcmVjdGl2ZU5hbWU6c3RyaW5nKTokRG9tTm9kZSB7XG4gICAgICAgIGNvbnN0IGRlbGltaXRlZE5hbWU6c3RyaW5nID1cbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3RyaW5nQ2FtZWxDYXNlVG9EZWxpbWl0ZWQoZGlyZWN0aXZlTmFtZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuJGRvbU5vZGUucmVtb3ZlQ2xhc3MoZGVsaW1pdGVkTmFtZSkucmVtb3ZlQXR0cihcbiAgICAgICAgICAgIGRlbGltaXRlZE5hbWVcbiAgICAgICAgKS5yZW1vdmVBdHRyKGBkYXRhLSR7ZGVsaW1pdGVkTmFtZX1gKS5yZW1vdmVBdHRyKFxuICAgICAgICAgICAgYHgtJHtkZWxpbWl0ZWROYW1lfWBcbiAgICAgICAgKS5yZW1vdmVBdHRyKGRlbGltaXRlZE5hbWUucmVwbGFjZSgnLScsICc6JykpLnJlbW92ZUF0dHIoXG4gICAgICAgICAgICBkZWxpbWl0ZWROYW1lLnJlcGxhY2UoJy0nLCAnXycpKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGEgbm9ybWFsaXplZCBjYW1lbCBjYXNlIGRpcmVjdGl2ZSBuYW1lIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSBkaXJlY3RpdmVOYW1lIC0gVGhlIGRpcmVjdGl2ZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgbmFtZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Tm9ybWFsaXplZERpcmVjdGl2ZU5hbWUoZGlyZWN0aXZlTmFtZTpzdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIGZvciAoY29uc3QgZGVsaW1pdGVyOnN0cmluZyBvZiBbJy0nLCAnOicsICdfJ10pIHtcbiAgICAgICAgICAgIGxldCBwcmVmaXhGb3VuZDpib29sZWFuID0gZmFsc2VcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZml4OnN0cmluZyBvZiBbYGRhdGEke2RlbGltaXRlcn1gLCBgeCR7ZGVsaW1pdGVyfWBdKVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3RpdmVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlTmFtZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4Rm91bmQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZWZpeEZvdW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkZWxpbWl0ZXI6c3RyaW5nIG9mIFsnLScsICc6JywgJ18nXSlcbiAgICAgICAgICAgIGRpcmVjdGl2ZU5hbWUgPSBUb29scy5zdHJpbmdEZWxpbWl0ZWRUb0NhbWVsQ2FzZShcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVOYW1lLCBkZWxpbWl0ZXIpXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVOYW1lXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYSBkaXJlY3RpdmUgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBkaXJlY3RpdmVOYW1lIC0gVGhlIGRpcmVjdGl2ZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIHZhbHVlIG9yIFwibnVsbFwiIGlmIG5vXG4gICAgICogYXR0cmlidXRlIHZhbHVlIGV4aXN0cy5cbiAgICAgKi9cbiAgICBnZXREaXJlY3RpdmVWYWx1ZShkaXJlY3RpdmVOYW1lOnN0cmluZyk6P3N0cmluZyB7XG4gICAgICAgIGNvbnN0IGRlbGltaXRlZE5hbWU6c3RyaW5nID1cbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3RyaW5nQ2FtZWxDYXNlVG9EZWxpbWl0ZWQoZGlyZWN0aXZlTmFtZSlcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lOnN0cmluZyBvZiBbXG4gICAgICAgICAgICBkZWxpbWl0ZWROYW1lLCBgZGF0YS0ke2RlbGltaXRlZE5hbWV9YCwgYHgtJHtkZWxpbWl0ZWROYW1lfWAsXG4gICAgICAgICAgICBkZWxpbWl0ZWROYW1lLnJlcGxhY2UoJy0nLCAnXFxcXDonKVxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTpzdHJpbmcgPSB0aGlzLiRkb21Ob2RlLmF0dHIoYXR0cmlidXRlTmFtZSlcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzZWxlY3RvciBwcmVmaXggZnJvbSBhIGdpdmVuIHNlbGVjdG9yLiBUaGlzIG1ldGhvZHMgc2VhcmNoZXNcbiAgICAgKiBpbiB0aGUgb3B0aW9ucyBvYmplY3QgZm9yIGEgZ2l2ZW4gXCJkb21Ob2RlU2VsZWN0b3JQcmVmaXhcIi5cbiAgICAgKiBAcGFyYW0gZG9tTm9kZVNlbGVjdG9yIC0gVGhlIGRvbSBub2RlIHNlbGVjdG9yIHRvIHNsaWNlLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNsaWNlZCBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBzbGljZURvbU5vZGVTZWxlY3RvclByZWZpeChkb21Ob2RlU2VsZWN0b3I6c3RyaW5nKTpzdHJpbmcge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAnZG9tTm9kZVNlbGVjdG9yUHJlZml4JyBpbiB0aGlzLl9vcHRpb25zICYmXG4gICAgICAgICAgICBkb21Ob2RlU2VsZWN0b3Iuc3RhcnRzV2l0aCh0aGlzLl9vcHRpb25zLmRvbU5vZGVTZWxlY3RvclByZWZpeClcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGVTZWxlY3Rvci5zdWJzdHJpbmcoXG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXgubGVuZ3RoXG4gICAgICAgICAgICApLnRyaW0oKVxuICAgICAgICByZXR1cm4gZG9tTm9kZVNlbGVjdG9yXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGRvbSBub2RlIG5hbWUgb2YgYSBnaXZlbiBkb20gbm9kZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIGRvbU5vZGVTZWxlY3RvciAtIEEgZ2l2ZW4gdG8gZG9tIG5vZGUgc2VsZWN0b3IgdG8gZGV0ZXJtaW5lIGl0c1xuICAgICAqIG5hbWUuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBUaGUgZG9tIG5vZGUgbmFtZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJldHVybnMgJ2RpdidcbiAgICAgKiAkLlRvb2xzLmdldERvbU5vZGVOYW1lKCcmbHQ7ZGl2Jmd0OycpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm5zICdkaXYnXG4gICAgICogJC5Ub29scy5nZXREb21Ob2RlTmFtZSgnJmx0O2RpdiZndDsmbHQ7L2RpdiZndDsnKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcmV0dXJucyAnYnInXG4gICAgICogJC5Ub29scy5nZXREb21Ob2RlTmFtZSgnJmx0O2JyLyZndDsnKVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREb21Ob2RlTmFtZShkb21Ob2RlU2VsZWN0b3I6c3RyaW5nKTo/c3RyaW5nIHtcbiAgICAgICAgY29uc3QgbWF0Y2g6P0FycmF5PHN0cmluZz4gPSBkb21Ob2RlU2VsZWN0b3IubWF0Y2goXG4gICAgICAgICAgICBuZXcgUmVnRXhwKCdePD8oW2EtekEtWl0rKS4qPj8uKicpKVxuICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiBkb20gc2VsZWN0b3JzIHRvIGFuIGFycmF5IG9mICQgd3JhcHBlZCBkb20gbm9kZXMuXG4gICAgICogTm90ZSBpZiBzZWxlY3RvciBkZXNjcmlwdGlvbiBhcyBvbmUgb2YgXCJjbGFzc1wiIG9yIFwiaWRcIiBhcyBzdWZmaXggZWxlbWVudFxuICAgICAqIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0gZG9tTm9kZVNlbGVjdG9ycyAtIEFuIG9iamVjdCB3aXRoIGRvbSBub2RlIHNlbGVjdG9ycy5cbiAgICAgKiBAcGFyYW0gd3JhcHBlckRvbU5vZGUgLSBBIGRvbSBub2RlIHRvIGJlIHRoZSBwYXJlbnQgb3Igd3JhcHBlciBvZiBhbGxcbiAgICAgKiByZXRyaWV2ZWQgZG9tIG5vZGVzLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgQWxsICQgd3JhcHBlZCBkb20gbm9kZXMgY29ycmVzcG9uZGluZyB0byBnaXZlblxuICAgICAqIHNlbGVjdG9ycy5cbiAgICAgKi9cbiAgICBncmFiRG9tTm9kZShcbiAgICAgICAgZG9tTm9kZVNlbGVjdG9yczpQbGFpbk9iamVjdCwgd3JhcHBlckRvbU5vZGU6RG9tTm9kZXwkRG9tTm9kZVxuICAgICk6e1trZXk6c3RyaW5nXTokRG9tTm9kZX0ge1xuICAgIC8qIGVzbGludC1lbmFibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgICAgICBjb25zdCBkb21Ob2Rlczp7W2tleTpzdHJpbmddOiREb21Ob2RlfSA9IHt9XG4gICAgICAgIGlmIChkb21Ob2RlU2VsZWN0b3JzKVxuICAgICAgICAgICAgaWYgKHdyYXBwZXJEb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHdyYXBwZXJEb21Ob2RlOiREb21Ob2RlID0gJCh3cmFwcGVyRG9tTm9kZSlcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWU6c3RyaW5nIGluIGRvbU5vZGVTZWxlY3RvcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlU2VsZWN0b3JzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZXNbbmFtZV0gPSAkd3JhcHBlckRvbU5vZGUuZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlU2VsZWN0b3JzW25hbWVdKVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lOnN0cmluZyBpbiBkb21Ob2RlU2VsZWN0b3JzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZVNlbGVjdG9ycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2g6P0FycmF5PHN0cmluZz4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGVTZWxlY3RvcnNbbmFtZV0ubWF0Y2goJywgKicpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZWxlY3RvclBhcnQ6c3RyaW5nIG9mIGRvbU5vZGVTZWxlY3RvcnNbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLnNwbGl0KG1hdGNoWzBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZVNlbGVjdG9yc1tuYW1lXSArPSAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsaXplRG9tTm9kZVNlbGVjdG9yKHNlbGVjdG9yUGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGVzW25hbWVdID0gJCh0aGlzLm5vcm1hbGl6ZURvbU5vZGVTZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlU2VsZWN0b3JzW25hbWVdKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXgpXG4gICAgICAgICAgICBkb21Ob2Rlcy5wYXJlbnQgPSAkKHRoaXMuX29wdGlvbnMuZG9tTm9kZVNlbGVjdG9yUHJlZml4KVxuICAgICAgICBpZiAoJ3dpbmRvdycgaW4gJC5nbG9iYWwpXG4gICAgICAgICAgICBkb21Ob2Rlcy53aW5kb3cgPSAkKCQuZ2xvYmFsLndpbmRvdylcbiAgICAgICAgaWYgKCdkb2N1bWVudCcgaW4gJC5nbG9iYWwpXG4gICAgICAgICAgICBkb21Ob2Rlcy5kb2N1bWVudCA9ICQoJC5nbG9iYWwuZG9jdW1lbnQpXG4gICAgICAgIHJldHVybiBkb21Ob2Rlc1xuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIHNjb3BlXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlcyBhbGwgaW5oZXJpdGVkIHZhcmlhYmxlcyBmcm9tIHBhcmVudCBzY29wZSB3aXRoIFwidW5kZWZpbmVkXCIuXG4gICAgICogQHBhcmFtIHNjb3BlIC0gQSBzY29wZSB3aGVyZSBpbmhlcml0ZWQgbmFtZXMgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqIEBwYXJhbSBwcmVmaXhlc1RvSWdub3JlIC0gTmFtZSBwcmVmaXhlcyB0byBpZ25vcmUgZHVyaW5nIGRlbGV0aW5nIG5hbWVzXG4gICAgICogaW4gZ2l2ZW4gc2NvcGUuXG4gICAgICogQHJldHVybnMgVGhlIGlzb2xhdGVkIHNjb3BlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc29sYXRlU2NvcGUoc2NvcGU6T2JqZWN0LCBwcmVmaXhlc1RvSWdub3JlOkFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICckJywgJ18nXG4gICAgXSk6T2JqZWN0IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lOnN0cmluZyBpbiBzY29wZSlcbiAgICAgICAgICAgIGlmICghKHByZWZpeGVzVG9JZ25vcmUuaW5jbHVkZXMobmFtZS5jaGFyQXQoMCkpIHx8IFtcbiAgICAgICAgICAgICAgICAndGhpcycsICdjb25zdHJ1Y3RvcidcbiAgICAgICAgICAgIF0uaW5jbHVkZXMobmFtZSkgfHwgc2NvcGUuaGFzT3duUHJvcGVydHkobmFtZSkpKVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIE5PVEU6IERlbGV0ZSAoXCJkZWxldGUgJHNjb3BlW25hbWVdXCIpIGRvZXNuJ3QgZGVzdHJveSB0aGVcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljIGxvb2t1cCB0byBwYXJlbnQgc2NvcGUuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzY29wZVtuYW1lXSA9IHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gc2NvcGVcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIG5hbWUgaW4gZ2l2ZW4gc2NvcGUgKHVzZWZ1bGwgZm9yIGpzb25wIHJlcXVlc3RzKS5cbiAgICAgKiBAcGFyYW0gcHJlZml4IC0gQSBwcmVmaXggd2hpY2ggd2lsbCBiZSBwcmVwcmVuZGVkIHRvIHVuaXFlIG5hbWUuXG4gICAgICogQHBhcmFtIHN1ZmZpeCAtIEEgc3VmZml4IHdoaWNoIHdpbGwgYmUgcHJlcHJlbmRlZCB0byB1bmlxZSBuYW1lLlxuICAgICAqIEBwYXJhbSBzY29wZSAtIEEgc2NvcGUgd2hlcmUgdGhlIG5hbWUgc2hvdWxkIGJlIHVuaXF1ZS5cbiAgICAgKiBAcGFyYW0gaW5pdGlhbFVuaXF1ZU5hbWUgLSBBbiBpbml0aWFsIHNjb3BlIG5hbWUgdG8gdXNlIGlmIG5vdCBleGlzdHMuXG4gICAgICogQHJldHVybnMgVGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgc3RhdGljIGRldGVybWluZVVuaXF1ZVNjb3BlTmFtZShcbiAgICAgICAgcHJlZml4OnN0cmluZyA9ICdjYWxsYmFjaycsIHN1ZmZpeDpzdHJpbmcgPSAnJyxcbiAgICAgICAgc2NvcGU6T2JqZWN0ID0gJC5nbG9iYWwsIGluaXRpYWxVbmlxdWVOYW1lOnN0cmluZyA9ICcnXG4gICAgKTpzdHJpbmcge1xuICAgICAgICBpZiAoaW5pdGlhbFVuaXF1ZU5hbWUubGVuZ3RoICYmICEoaW5pdGlhbFVuaXF1ZU5hbWUgaW4gc2NvcGUpKVxuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxVbmlxdWVOYW1lXG4gICAgICAgIGxldCB1bmlxdWVOYW1lOnN0cmluZyA9IHByZWZpeCArIHN1ZmZpeFxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdW5pcXVlTmFtZSA9IHByZWZpeCArIHBhcnNlSW50KFxuICAgICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygxMCwgMTApLCAxMFxuICAgICAgICAgICAgKSArIHN1ZmZpeFxuICAgICAgICAgICAgaWYgKCEodW5pcXVlTmFtZSBpbiBzY29wZSkpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pcXVlTmFtZVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGZ1bmN0aW9uXG4gICAgLyoqXG4gICAgICogTWV0aG9kcyBnaXZlbiBieSB0aGlzIG1ldGhvZCBoYXMgdGhlIHBsdWdpbiBzY29wZSByZWZlcmVuY2VkIHdpdGhcbiAgICAgKiBcInRoaXNcIi4gT3RoZXJ3aXNlIFwidGhpc1wiIHVzdWFsbHkgcG9pbnRzIHRvIHRoZSBvYmplY3QgdGhlIGdpdmVuIG1ldGhvZFxuICAgICAqIHdhcyBhdHRhY2hlZCB0by4gSWYgXCJtZXRob2RcIiBkb2Vzbid0IG1hdGNoIHN0cmluZyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAqIHRocm91Z2ggYSB3cmFwcGVyIGZ1bmN0aW9uIHdpdGggXCJjb250ZXh0XCIgc2V0dGVkIGFzIFwic2NvcGVcIiBvciBcInRoaXNcIiBpZlxuICAgICAqIG5vdGhpbmcgaXMgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIG1ldGhvZCAtIEEgbWV0aG9kIG5hbWUgb2YgZ2l2ZW4gc2NvcGUuXG4gICAgICogQHBhcmFtIHNjb3BlIC0gQSBnaXZlbiBzY29wZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEEgbGlzdCBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmb3J3YXJkXG4gICAgICogdG8gZ2l2ZW4gZnVuY3Rpb24sIHdoZW4gaXQgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBnaXZlbiBtZXRob2RzIHJldHVybiB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRNZXRob2QoXG4gICAgICAgIG1ldGhvZDpGdW5jdGlvbnxzdHJpbmcsIHNjb3BlOmFueSA9IG51bGwsXG4gICAgICAgIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55PlxuICAgICk6RnVuY3Rpb24ge1xuICAgICAgICAvKlxuICAgICAgICAgICAgVGhpcyBmb2xsb3dpbmcgb3V0Y29tbWVudCBsaW5lIHdvdWxkIGJlIHJlc3BvbnNpYmxlIGZvciBhIGJ1ZyBpblxuICAgICAgICAgICAgeXVpY29tcHJlc3Nvci4gQmVjYXVzZSBvZiBkZWNsYXJhdGlvbiBvZiBhcmd1bWVudHMgdGhlIHBhcnNlclxuICAgICAgICAgICAgdGhpbmdzIHRoYXQgYXJndW1lbnRzIGlzIGEgbG9jYWwgdmFyaWFibGUgYW5kIGNvdWxkIGJlIHJlbmFtZWQuIEl0XG4gICAgICAgICAgICBkb2Vzbid0IGNhcmUgYWJvdXQgdGhhdCB0aGUgbWFnaWMgYXJndW1lbnRzIG9iamVjdCBpcyBuZWNlc3NhcnkgdG9cbiAgICAgICAgICAgIGdlbmVyYXRlIHRoZSBhcmd1bWVudHMgYXJyYXkgaW4gdGhpcyBjb250ZXh0LlxuXG4gICAgICAgICAgICB2YXIgYXJndW1lbnRzID0gdGhpcy5jb25zdHJ1Y3Rvci5hcnJheU1ha2UoYXJndW1lbnRzKVxuICAgICAgICAqL1xuICAgICAgICBpZiAoIXNjb3BlKVxuICAgICAgICAgICAgc2NvcGUgPSB0aGlzXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2NvcGUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCk6YW55IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlW21ldGhvZF0gJiYgdHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGRvZXNuJ3QgZXhpc3RzIGluIFwiJHtzY29wZX1cIi5gKVxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZVttZXRob2RdLmFwcGx5KHNjb3BlLCBhZGRpdGlvbmFsQXJndW1lbnRzLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5hcnJheU1ha2UoYXJndW1lbnRzKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGY6VG9vbHMgPSB0aGlzXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpOmFueSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIHNlbGYuY29uc3RydWN0b3IuYXJyYXlNYWtlKFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICAgKS5jb25jYXQoYWRkaXRpb25hbEFyZ3VtZW50cykpXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gQSB2YWx1ZSB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIGlkZW50aXR5KHZhbHVlOmFueSk6YW55IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVydGVkIGZpbHRlciBoZWxwZXIgdG8gaW52ZXJzZSBlYWNoIGdpdmVuIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gQSBmdW5jdGlvbiB0aGF0IGZpbHRlcnMgYW4gYXJyYXkuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIGZpbHRlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW52ZXJ0QXJyYXlGaWx0ZXIoZmlsdGVyOkZ1bmN0aW9uKTpGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhOmFueSk6YW55IHtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWREYXRhOmFueSA9IGZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDpBcnJheTxhbnk+ID0gW11cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjdXJseSAqL1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGF0ZTphbnkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyZWREYXRhLmluY2x1ZGVzKGRhdGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGUpXG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjdXJseSAqL1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGV2ZW50XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgZXZlbnQgZnVuY3Rpb25zIGZyb20gdHJpZ2dlcmluZyB0byBvZnRlbiBieSBkZWZpbmluZyBhIG1pbmltYWxcbiAgICAgKiBzcGFuIGJldHdlZW4gZWFjaCBmdW5jdGlvbiBjYWxsLiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBnaXZlbiB0byB0aGlzXG4gICAgICogZnVuY3Rpb24gd2lsbCBiZSBmb3J3YXJkZWQgdG8gZ2l2ZW4gZXZlbnQgZnVuY3Rpb24gY2FsbC4gVGhlIGZ1bmN0aW9uXG4gICAgICogd3JhcHBlciByZXR1cm5zIG51bGwgaWYgY3VycmVudCBmdW5jdGlvbiB3aWxsIGJlIG9taXR0ZWQgZHVlIHRvXG4gICAgICogZGVib3VuY2VpbmcuXG4gICAgICogQHBhcmFtIGV2ZW50RnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBkZWJvdW5jZWQuXG4gICAgICogQHBhcmFtIHRocmVzaG9sZEluTWlsbGlzZWNvbmRzIC0gVGhlIG1pbmltdW0gdGltZSBzcGFuIGJldHdlZW4gZWFjaFxuICAgICAqIGZ1bmN0aW9uIGNhbGwuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxBcmd1bWVudHMgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmb3J3YXJkIHRvIGdpdmVuXG4gICAgICogZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgd3JhcHBlZCBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGRlYm91bmNlKFxuICAgICAgICBldmVudEZ1bmN0aW9uOkZ1bmN0aW9uLCB0aHJlc2hvbGRJbk1pbGxpc2Vjb25kczpudW1iZXIgPSA2MDAsXG4gICAgICAgIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55PlxuICAgICk6RnVuY3Rpb24ge1xuICAgICAgICBsZXQgbG9jazpib29sZWFuID0gZmFsc2VcbiAgICAgICAgbGV0IHdhaXRpbmdDYWxsQXJndW1lbnRzOj9BcnJheTxhbnk+ID0gbnVsbFxuICAgICAgICBsZXQgdGltZW91dElEOj9udW1iZXIgPSBudWxsXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpOj9udW1iZXIge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyOkFycmF5PGFueT4gPSBUb29scy5hcnJheU1ha2UoYXJndW1lbnRzKVxuICAgICAgICAgICAgaWYgKGxvY2spXG4gICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxBcmd1bWVudHMgPSBwYXJhbWV0ZXIuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzIHx8IFtdKVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jayA9IHRydWVcbiAgICAgICAgICAgICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpOnZvaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2NrID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhaXRpbmdDYWxsQXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHdhaXRpbmdDYWxsQXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxBcmd1bWVudHMgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aHJlc2hvbGRJbk1pbGxpc2Vjb25kcylcbiAgICAgICAgICAgICAgICBldmVudEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtZXRlci5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxBcmd1bWVudHMgfHwgW10pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXRJRFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBpbnRlcm5hbCBldmVudCBoYW5kbGVyIG1ldGhvZHMgYW5kIHJ1bnMgdGhlbSBieSBkZWZhdWx0LiBJblxuICAgICAqIGFkZGl0aW9uIHRoaXMgbWV0aG9kIHNlYXJjaGVzIGZvciBhIGdpdmVuIGV2ZW50IG1ldGhvZCBieSB0aGUgb3B0aW9uc1xuICAgICAqIG9iamVjdC4gQWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIGZvcndhcmRlZCB0byByZXNwZWN0aXZlIGV2ZW50XG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBBbiBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBjYWxsT25seU9wdGlvbnNNZXRob2QgLSBQcmV2ZW50cyBmcm9tIHRyeWluZyB0byBjYWxsIGFuIGludGVybmFsXG4gICAgICogZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gc2NvcGUgLSBUaGUgc2NvcGUgZnJvbSB3aGVyZSB0aGUgZ2l2ZW4gZXZlbnQgaGFuZGxlciBzaG91bGQgYmVcbiAgICAgKiBjYWxsZWQuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxBcmd1bWVudHMgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmb3J3YXJkIHRvXG4gICAgICogY29ycmVzcG9uZGluZyBldmVudCBoYW5kbGVycy5cbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgXCJ0cnVlXCIgaWYgYW4gb3B0aW9ucyBldmVudCBoYW5kbGVyIHdhcyBjYWxsZWQgYW5kXG4gICAgICogXCJmYWxzZVwiIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmaXJlRXZlbnQoXG4gICAgICAgIGV2ZW50TmFtZTpzdHJpbmcsIGNhbGxPbmx5T3B0aW9uc01ldGhvZDpib29sZWFuID0gZmFsc2UsXG4gICAgICAgIHNjb3BlOmFueSA9IHRoaXMsIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55PlxuICAgICk6Ym9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlck5hbWU6c3RyaW5nID1cbiAgICAgICAgICAgIGBvbiR7dGhpcy5jb25zdHJ1Y3Rvci5zdHJpbmdDYXBpdGFsaXplKGV2ZW50TmFtZSl9YFxuICAgICAgICBpZiAoIWNhbGxPbmx5T3B0aW9uc01ldGhvZClcbiAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJOYW1lIGluIHNjb3BlKVxuICAgICAgICAgICAgICAgIHNjb3BlW2V2ZW50SGFuZGxlck5hbWVdLmFwcGx5KHNjb3BlLCBhZGRpdGlvbmFsQXJndW1lbnRzKVxuICAgICAgICAgICAgZWxzZSBpZiAoYF8ke2V2ZW50SGFuZGxlck5hbWV9YCBpbiBzY29wZSlcbiAgICAgICAgICAgICAgICBzY29wZVtgXyR7ZXZlbnRIYW5kbGVyTmFtZX1gXS5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUsIGFkZGl0aW9uYWxBcmd1bWVudHMpXG4gICAgICAgIGlmIChzY29wZS5fb3B0aW9ucyAmJiBldmVudEhhbmRsZXJOYW1lIGluIHNjb3BlLl9vcHRpb25zKSB7XG4gICAgICAgICAgICBzY29wZS5fb3B0aW9uc1tldmVudEhhbmRsZXJOYW1lXS5hcHBseShzY29wZSwgYWRkaXRpb25hbEFyZ3VtZW50cylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb24tY29tcGxldGUtc2VudGVuY2UgKi9cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgbWV0aG9kIGZvciBcIiQub24oKVwiLiBJdCBzZXRzIGN1cnJlbnQgcGx1Z2luIG5hbWUgYXMgZXZlbnRcbiAgICAgKiBzY29wZSBpZiBubyBzY29wZSBpcyBnaXZlbi4gR2l2ZW4gYXJndW1lbnRzIGFyZSBtb2RpZmllZCBhbmQgcGFzc2VkXG4gICAgICogdGhyb3VnaCBcIiQub24oKVwiLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgJCdzIGdyYWJiZWQgZG9tIG5vZGUuXG4gICAgICovXG4gICAgb24oKTokRG9tTm9kZSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBqc2RvYy9yZXF1aXJlLWRlc2NyaXB0aW9uLWNvbXBsZXRlLXNlbnRlbmNlICovXG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kRXZlbnRIZWxwZXIoYXJndW1lbnRzLCBmYWxzZSlcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBtZXRob2QgZm8gXCIkLm9mZigpXCIuIEl0IHNldHMgY3VycmVudCBwbHVnaW4gbmFtZSBhcyBldmVudFxuICAgICAqIHNjb3BlIGlmIG5vIHNjb3BlIGlzIGdpdmVuLiBHaXZlbiBhcmd1bWVudHMgYXJlIG1vZGlmaWVkIGFuZCBwYXNzZWRcbiAgICAgKiB0aHJvdWdoIFwiJC5vZmYoKVwiLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgJCdzIGdyYWJiZWQgZG9tIG5vZGUuXG4gICAgICovXG4gICAgb2ZmKCk6JERvbU5vZGUge1xuICAgIC8qIGVzbGludC1lbmFibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZEV2ZW50SGVscGVyKGFyZ3VtZW50cywgdHJ1ZSwgJ29mZicpXG4gICAgfVxuICAgIC8vIC8gZW5kcmVnaW9uXG4gICAgLy8gLyByZWdpb24gb2JqZWN0XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IFtbQ2xhc3NdXSBvZiBhbiBvYmplY3QuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBhbmFseXplLlxuICAgICAqIEByZXR1cm5zIE5hbWUgb2YgZGV0ZXJtaW5lZCBjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0ZXJtaW5lVHlwZShvYmplY3Q6YW55ID0gdW5kZWZpbmVkKTpzdHJpbmcge1xuICAgICAgICBpZiAoW3VuZGVmaW5lZCwgbnVsbF0uaW5jbHVkZXMob2JqZWN0KSlcbiAgICAgICAgICAgIHJldHVybiBgJHtvYmplY3R9YFxuICAgICAgICBpZiAoWydvYmplY3QnLCAnZnVuY3Rpb24nXS5pbmNsdWRlcyhcbiAgICAgICAgICAgIHR5cGVvZiBvYmplY3RcbiAgICAgICAgKSAmJiAndG9TdHJpbmcnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nUmVwcmVzZW50YXRpb246c3RyaW5nID1cbiAgICAgICAgICAgICAgICBUb29scy5jbGFzc1RvVHlwZU1hcHBpbmcudG9TdHJpbmcuY2FsbChvYmplY3QpXG4gICAgICAgICAgICBpZiAoVG9vbHMuY2xhc3NUb1R5cGVNYXBwaW5nLmhhc093blByb3BlcnR5KHN0cmluZ1JlcHJlc2VudGF0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gVG9vbHMuY2xhc3NUb1R5cGVNYXBwaW5nW3N0cmluZ1JlcHJlc2VudGF0aW9uXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGdpdmVuIHBhdHRlcm4gaW4gZWFjaCB2YWx1ZSBpbiBnaXZlbiBvYmplY3QgcmVjdXJzaXZlbHkgd2l0aFxuICAgICAqIGdpdmVuIHN0cmluZyByZXBsYWNlbWVudC5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGNvbnZlcnQgc3Vic3RyaW5ncyBpbi5cbiAgICAgKiBAcGFyYW0gcGF0dGVybiAtIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSByZXBsYWNlbWVudCAtIFN0cmluZyB0byB1c2UgYXMgcmVwbGFjZW1lbnQgZm9yIGZvdW5kIHBhdHRlcm5zLlxuICAgICAqIEByZXR1cm5zIENvbnZlcnRlZCBvYmplY3Qgd2l0aCByZXBsYWNlZCBwYXR0ZXJucy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydFN1YnN0cmluZ0luUGxhaW5PYmplY3QoXG4gICAgICAgIG9iamVjdDpQbGFpbk9iamVjdCwgcGF0dGVybjpSZWdFeHAsIHJlcGxhY2VtZW50OnN0cmluZ1xuICAgICk6UGxhaW5PYmplY3Qge1xuICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gb2JqZWN0KVxuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgIGlmIChUb29scy5pc1BsYWluT2JqZWN0KG9iamVjdFtrZXldKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBUb29scy5jb252ZXJ0U3Vic3RyaW5nSW5QbGFpbk9iamVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBwYXR0ZXJuLCByZXBsYWNlbWVudClcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IG9iamVjdFtrZXldLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZW1lbnQpXG4gICAgICAgIHJldHVybiBvYmplY3RcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kaWZpZXMgZ2l2ZW4gdGFyZ2V0IGNvcnJlc3BvbmRpbmcgdG8gZ2l2ZW4gc291cmNlIGFuZCByZW1vdmVzIHNvdXJjZVxuICAgICAqIG1vZGlmaWNhdGlvbiBpbmZvcy5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gT2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gc291cmNlIC0gU291cmNlIG9iamVjdCB0byBsb2FkIG1vZGlmaWNhdGlvbnMgZnJvbS5cbiAgICAgKiBAcGFyYW0gcmVtb3ZlSW5kaWNhdG9yS2V5IC0gSW5kaWNhdG9yIHByb3BlcnR5IG5hbWUgb3IgdmFsdWUgdG8gbWFyayBhXG4gICAgICogdmFsdWUgdG8gcmVtb3ZlIGZyb20gb2JqZWN0IG9yIGxpc3QuXG4gICAgICogQHBhcmFtIHByZXBlbmRJbmRpY2F0b3JLZXkgLSBJbmRpY2F0b3IgcHJvcGVydHkgbmFtZSB0byBtYXJrIGEgdmFsdWUgdG9cbiAgICAgKiBwcmVwZW5kIHRvIHRhcmdldCBsaXN0LlxuICAgICAqIEBwYXJhbSBhcHBlbmRJbmRpY2F0b3JLZXkgLSBJbmRpY2F0b3IgcHJvcGVydHkgbmFtZSB0byBtYXJrIGEgdmFsdWUgdG9cbiAgICAgKiBhcHBlbmQgdG8gdGFyZ2V0IGxpc3QuXG4gICAgICogQHBhcmFtIHBhcmVudFNvdXJjZSAtIFNvdXJjZSBjb250ZXh0IHRvIHJlbW92ZSBtb2RpZmljYXRpb24gaW5mbyBmcm9tXG4gICAgICogKHVzdWFsbHkgb25seSBuZWVkZWQgaW50ZXJuYWxseSkuXG4gICAgICogQHBhcmFtIHBhcmVudEtleSAtIFNvdXJjZSBrZXkgaW4gZ2l2ZW4gc291cmNlIGNvbnRleHQgdG8gcmVtb3ZlXG4gICAgICogbW9kaWZpY2F0aW9uIGluZm8gZnJvbSAodXN1YWxseSBvbmx5IG5lZWRlZCBpbnRlcm5hbGx5KS5cbiAgICAgKiBAcmV0dXJuIEdpdmVuIHRhcmdldCBtb2RpZmllZCB3aXRoIGdpdmVuIHNvdXJjZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbW9kaWZ5T2JqZWN0KFxuICAgICAgICB0YXJnZXQ6YW55LCBzb3VyY2U6YW55LCByZW1vdmVJbmRpY2F0b3JLZXk6c3RyaW5nID0gJ19fcmVtb3ZlX18nLFxuICAgICAgICBwcmVwZW5kSW5kaWNhdG9yS2V5OnN0cmluZyA9ICdfX3ByZXBlbmRfXycsXG4gICAgICAgIGFwcGVuZEluZGljYXRvcktleTpzdHJpbmcgPSAnX19hcHBlbmRfXycsIHBhcmVudFNvdXJjZTphbnkgPSBudWxsLFxuICAgICAgICBwYXJlbnRLZXk6YW55ID0gbnVsbFxuICAgICkge1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgTWFwICYmIHRhcmdldCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5OnN0cmluZywgdmFsdWU6YW55XSBvZiBzb3VyY2UpXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgVG9vbHMubW9kaWZ5T2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmdldChrZXkpLCB2YWx1ZSwgcmVtb3ZlSW5kaWNhdG9yS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGVuZEluZGljYXRvcktleSwgYXBwZW5kSW5kaWNhdG9yS2V5LCBzb3VyY2UsIGtleSlcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHNvdXJjZSAhPT0gbnVsbCAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdGFyZ2V0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnXG4gICAgICAgICkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIHNvdXJjZSlcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChbXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVJbmRpY2F0b3JLZXksIHByZXBlbmRJbmRpY2F0b3JLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRJbmRpY2F0b3JLZXlcbiAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlVG9Nb2RpZnk6YW55IG9mIFtdLmNvbmNhdChzb3VyY2Vba2V5XSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSByZW1vdmVJbmRpY2F0b3JLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaW5jbHVkZXModmFsdWVUb01vZGlmeSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmluZGV4T2YodmFsdWVUb01vZGlmeSksIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBwcmVwZW5kSW5kaWNhdG9yS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnVuc2hpZnQodmFsdWVUb01vZGlmeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2godmFsdWVUb01vZGlmeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09IHJlbW92ZUluZGljYXRvcktleSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaGFzT3duUHJvcGVydHkodmFsdWVUb01vZGlmeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbdmFsdWVUb01vZGlmeV1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFNvdXJjZSAmJiBwYXJlbnRLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudFNvdXJjZVtwYXJlbnRLZXldXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgVG9vbHMubW9kaWZ5T2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgcmVtb3ZlSW5kaWNhdG9yS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXBlbmRJbmRpY2F0b3JLZXksIGFwcGVuZEluZGljYXRvcktleSwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dGVuZHMgZ2l2ZW4gdGFyZ2V0IG9iamVjdCB3aXRoIGdpdmVuIHNvdXJjZXMgb2JqZWN0LiBBcyB0YXJnZXQgYW5kXG4gICAgICogc291cmNlcyBtYW55IGV4cGFuZGFibGUgdHlwZXMgYXJlIGFsbG93ZWQgYnV0IHRhcmdldCBhbmQgc291cmNlcyBoYXZlIHRvXG4gICAgICogdG8gY29tZSBmcm9tIHRoZSBzYW1lIHR5cGUuXG4gICAgICogQHBhcmFtIHRhcmdldE9yRGVlcEluZGljYXRvciAtIE1heWJlIHRoZSB0YXJnZXQgb3IgZGVlcCBpbmRpY2F0b3IuXG4gICAgICogQHBhcmFtIF90YXJnZXRBbmRPclNvdXJjZXMgLSBUYXJnZXQgYW5kIGF0IGxlYXN0IG9uZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gdGFyZ2V0IGV4dGVuZGVkIHdpdGggYWxsIGdpdmVuIHNvdXJjZXMuXG4gICAgICovXG4gICAgc3RhdGljIGV4dGVuZE9iamVjdChcbiAgICAgICAgdGFyZ2V0T3JEZWVwSW5kaWNhdG9yOmJvb2xlYW58YW55LCAuLi5fdGFyZ2V0QW5kT3JTb3VyY2VzOkFycmF5PGFueT5cbiAgICApOmFueSB7XG4gICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAxXG4gICAgICAgIGxldCBkZWVwOmJvb2xlYW4gPSBmYWxzZVxuICAgICAgICBsZXQgdGFyZ2V0Om1peGVkXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0T3JEZWVwSW5kaWNhdG9yID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb24gYW5kIHNraXAgZGVlcCBpbmRpY2F0b3IgYW5kIHRhcmdldC5cbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXRPckRlZXBJbmRpY2F0b3JcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpbmRleF1cbiAgICAgICAgICAgIGluZGV4ID0gMlxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldE9yRGVlcEluZGljYXRvclxuICAgICAgICBjb25zdCBtZXJnZVZhbHVlID0gKGtleTpzdHJpbmcsIHZhbHVlOmFueSwgdGFyZ2V0VmFsdWU6YW55KTphbnkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0YXJnZXRWYWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0VmFsdWVcbiAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIG1hcHMuXG4gICAgICAgICAgICBpZiAoZGVlcCAmJiB2YWx1ZSAmJiAoXG4gICAgICAgICAgICAgICAgVG9vbHMuaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xvbmU6YW55XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHRhcmdldFZhbHVlICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlIGluc3RhbmNlb2YgTWFwXG4gICAgICAgICAgICAgICAgICAgICkgPyB0YXJnZXRWYWx1ZSA6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSB0YXJnZXRWYWx1ZSAmJiBUb29scy5pc1BsYWluT2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKSA/IHRhcmdldFZhbHVlIDoge31cbiAgICAgICAgICAgICAgICByZXR1cm4gVG9vbHMuZXh0ZW5kT2JqZWN0KGRlZXAsIGNsb25lLCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZTphbnkgPSBhcmd1bWVudHNbaW5kZXhdXG4gICAgICAgICAgICBsZXQgdGFyZ2V0VHlwZTpzdHJpbmcgPSB0eXBlb2YgdGFyZ2V0XG4gICAgICAgICAgICBsZXQgc291cmNlVHlwZTpzdHJpbmcgPSB0eXBlb2Ygc291cmNlXG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgICAgIHRhcmdldFR5cGUgKz0gJyBNYXAnXG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGUgKz0gJyBNYXAnXG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gc291cmNlVHlwZSAmJiB0YXJnZXQgIT09IHNvdXJjZSlcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwICYmIHNvdXJjZSBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5OnN0cmluZywgdmFsdWU6YW55XSBvZiBzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0KGtleSwgbWVyZ2VWYWx1ZShrZXksIHZhbHVlLCB0YXJnZXQuZ2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSkpKVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiBzb3VyY2UgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoc291cmNlKSAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2VWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LCBzb3VyY2Vba2V5XSwgdGFyZ2V0W2tleV0pXG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHNvdXJjZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHNvdXJjZVxuICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHByb3hpZXMgZnJvbSBnaXZlbiBkYXRhIHN0cnVjdHVyZSByZWN1cnNpdmxleS5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIHByb3h5LlxuICAgICAqIEBwYXJhbSBzZWVuT2JqZWN0cyAtIFRyYWNrcyBhbGwgYWxyZWFkeSBwcm9jZXNzZWQgb2JlamN0cyB0byBhdm9pZFxuICAgICAqIGVuZGxlc3MgbG9vcHMgKHVzdWFsbHkgb25seSBuZWVkZWQgZm9yIGludGVybmFsIHBydXBvc2UpLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gb2JqZWN0IHVud3JhcHBlZCBmcm9tIGEgZHluYW1pYyBwcm94eS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdW53cmFwUHJveHkob2JqZWN0OmFueSwgc2Vlbk9iamVjdHM6QXJyYXk8YW55PiA9IFtdKTphbnkge1xuICAgICAgICBpZiAob2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB3aGlsZSAob2JqZWN0Ll9fdGFyZ2V0X18pXG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0Ll9fdGFyZ2V0X19cbiAgICAgICAgICAgIGNvbnN0IGluZGV4Om51bWJlciA9IHNlZW5PYmplY3RzLmluZGV4T2Yob2JqZWN0KVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbk9iamVjdHNbaW5kZXhdXG4gICAgICAgICAgICBzZWVuT2JqZWN0cy5wdXNoKG9iamVjdClcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXg6bnVtYmVyID0gMFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWU6bWl4ZWQgb2Ygb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtpbmRleF0gPSBUb29scy51bndyYXBQcm94eSh2YWx1ZSwgc2Vlbk9iamVjdHMpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXk6bWl4ZWQsIHZhbHVlOm1peGVkXSBvZiBvYmplY3QpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zZXQoa2V5LCBUb29scy51bndyYXBQcm94eSh2YWx1ZSwgc2Vlbk9iamVjdHMpKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBvYmplY3QpXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gVG9vbHMudW53cmFwUHJveHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0sIHNlZW5PYmplY3RzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBkeW5hbWljIGdldHRlciBhbmQgc2V0dGVyIHRvIGFueSBnaXZlbiBkYXRhIHN0cnVjdHVyZSBzdWNoIGFzIG1hcHMuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBwcm94eS5cbiAgICAgKiBAcGFyYW0gZ2V0dGVyV3JhcHBlciAtIEZ1bmN0aW9uIHRvIHdyYXAgZWFjaCBwcm9wZXJ0eSBnZXQuXG4gICAgICogQHBhcmFtIHNldHRlcldyYXBwZXIgLSBGdW5jdGlvbiB0byB3cmFwIGVhY2ggcHJvcGVydHkgc2V0LlxuICAgICAqIEBwYXJhbSBnZXR0ZXJNZXRob2ROYW1lIC0gTWV0aG9kIG5hbWUgdG8gZ2V0IGEgc3RvcmVkIHZhbHVlIGJ5IGtleS5cbiAgICAgKiBAcGFyYW0gc2V0dGVyTWV0aG9kTmFtZSAtIE1ldGhvZCBuYW1lIHRvIHNldCBhIHN0b3JlZCB2YWx1ZSBieSBrZXkuXG4gICAgICogQHBhcmFtIGNvbnRhaW5lc01ldGhvZE5hbWUgLSBNZXRob2QgbmFtZSB0byBpbmRpY2F0ZSBpZiBhIGtleSBpcyBzdG9yZWRcbiAgICAgKiBpbiBnaXZlbiBkYXRhIHN0cnVjdHVyZS5cbiAgICAgKiBAcGFyYW0gZGVlcCAtIEluZGljYXRlcyB0byBwZXJmb3JtIGEgZGVlcCB3cmFwcGluZyBvZiBzcGVjaWZpZWQgdHlwZXMuXG4gICAgICogcGVyZm9ybWVkIHZpYSBcInZhbHVlIGluc3RhbmNlb2YgdHlwZVwiLikuXG4gICAgICogQHBhcmFtIHR5cGVzVG9FeHRlbmQgLSBUeXBlcyB3aGljaCBzaG91bGQgYmUgZXh0ZW5kZWQgKENoZWNrcyBhcmVcbiAgICAgKiBwZXJmb3JtZWQgdmlhIFwidmFsdWUgaW5zdGFuY2VvZiB0eXBlXCIuKS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIG9iamVjdCB3cmFwcGVkIHdpdGggYSBkeW5hbWljIGdldHRlciBwcm94eS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRHluYW1pY0dldHRlckFuZFNldHRlcjxWYWx1ZT4oXG4gICAgICAgIG9iamVjdDpWYWx1ZSwgZ2V0dGVyV3JhcHBlcjpHZXR0ZXJGdW5jdGlvbiA9ICh2YWx1ZTphbnkpOmFueSA9PiB2YWx1ZSxcbiAgICAgICAgc2V0dGVyV3JhcHBlcjpTZXR0ZXJGdW5jdGlvbiA9IChrZXk6YW55LCB2YWx1ZTphbnkpOmFueSA9PiB2YWx1ZSxcbiAgICAgICAgZ2V0dGVyTWV0aG9kTmFtZTpzdHJpbmcgPSAnW10nLCBzZXR0ZXJNZXRob2ROYW1lOnN0cmluZyA9ICdbXScsXG4gICAgICAgIGNvbnRhaW5lc01ldGhvZE5hbWU6c3RyaW5nID0gJ2hhc093blByb3BlcnR5JywgZGVlcDpib29sZWFuID0gdHJ1ZSxcbiAgICAgICAgdHlwZXNUb0V4dGVuZDpBcnJheTxtaXhlZD4gPSBbT2JqZWN0XVxuICAgICk6VmFsdWUge1xuICAgICAgICBpZiAoZGVlcClcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5Om1peGVkLCB2YWx1ZTptaXhlZF0gb2Ygb2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc2V0KGtleSwgVG9vbHMuYWRkRHluYW1pY0dldHRlckFuZFNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLCBnZXR0ZXJXcmFwcGVyLCBzZXR0ZXJXcmFwcGVyLCBnZXR0ZXJNZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyTWV0aG9kTmFtZSwgY29udGFpbmVzTWV0aG9kTmFtZSwgZGVlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzVG9FeHRlbmQpKVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBUb29scy5hZGREeW5hbWljR2V0dGVyQW5kU2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBnZXR0ZXJXcmFwcGVyLCBzZXR0ZXJXcmFwcGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlck1ldGhvZE5hbWUsIHNldHRlck1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVzTWV0aG9kTmFtZSwgZGVlcCwgdHlwZXNUb0V4dGVuZClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4Om51bWJlciA9IDBcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlOm1peGVkIG9mIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbaW5kZXhdID0gVG9vbHMuYWRkRHluYW1pY0dldHRlckFuZFNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLCBnZXR0ZXJXcmFwcGVyLCBzZXR0ZXJXcmFwcGVyLCBnZXR0ZXJNZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyTWV0aG9kTmFtZSwgY29udGFpbmVzTWV0aG9kTmFtZSwgZGVlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzVG9FeHRlbmQpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdHlwZTptaXhlZCBvZiB0eXBlc1RvRXh0ZW5kKVxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0Ll9fdGFyZ2V0X18pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyOntcbiAgICAgICAgICAgICAgICAgICAgaGFzPzoodGFyZ2V0Ok9iamVjdCwgbmFtZTpzdHJpbmcpID0+IGJvb2xlYW47XG4gICAgICAgICAgICAgICAgICAgIGdldD86KHRhcmdldDpPYmplY3QsIG5hbWU6c3RyaW5nKSA9PiBhbnk7XG4gICAgICAgICAgICAgICAgICAgIHNldD86KHRhcmdldDpPYmplY3QsIG5hbWU6c3RyaW5nKSA9PiBhbnlcbiAgICAgICAgICAgICAgICB9ID0ge31cbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVzTWV0aG9kTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5oYXMgPSAodGFyZ2V0Ok9iamVjdCwgbmFtZTpzdHJpbmcpOmJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lc01ldGhvZE5hbWUgPT09ICdbXScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgaW4gdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2NvbnRhaW5lc01ldGhvZE5hbWVdKG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVzTWV0aG9kTmFtZSAmJiBnZXR0ZXJNZXRob2ROYW1lKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmdldCA9ICh0YXJnZXQ6T2JqZWN0LCBuYW1lOnN0cmluZyk6YW55ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnX190YXJnZXRfXycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbbmFtZV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXS5iaW5kKHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbY29udGFpbmVzTWV0aG9kTmFtZV0obmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyTWV0aG9kTmFtZSA9PT0gJ1tdJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcldyYXBwZXIodGFyZ2V0W25hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXJXcmFwcGVyKHRhcmdldFtnZXR0ZXJNZXRob2ROYW1lXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W25hbWVdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGVyTWV0aG9kTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5zZXQgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6T2JqZWN0LCBuYW1lOnN0cmluZywgdmFsdWU6YW55XG4gICAgICAgICAgICAgICAgICAgICk6dm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGVyTWV0aG9kTmFtZSA9PT0gJ1tdJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBzZXR0ZXJXcmFwcGVyKG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtzZXR0ZXJNZXRob2ROYW1lXShuYW1lLCBzZXR0ZXJXcmFwcGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3h5KG9iamVjdCwgaGFuZGxlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgbmVzdGVkIG1hcHBpbmdzIHdpdGggZ2l2ZW4gaW5kaWNhdG9yIGtleSBhbmQgcmVzb2x2ZXNcbiAgICAgKiBtYXJrZWQgdmFsdWVzLiBBZGRpdGlvbmFsbHkgYWxsIG9iamVjdHMgYXJlIHdyYXBwZWQgd2l0aCBhIHByb3h5IHRvXG4gICAgICogZHluYW1pY2FsbHkgcmVzb2x2ZSBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gR2l2ZW4gbWFwcGluZyB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJEZXNjcmlwdGlvbiAtIEFycmF5IG9mIHNjb3BlIG5hbWVzLlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXIgLSBBcnJheSBvZiB2YWx1ZXMgZm9yIGdpdmVuIHNjb3BlIG5hbWVzLiBJZiB0aGVyZSBpc1xuICAgICAqIG9uZSBtaXNzaW5nIGdpdmVuIG9iamVjdCB3aWxsIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSBkZWVwIC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcGVyZm9ybSBhIHJlY3Vyc2l2ZSByZXNvbHZpbmcuXG4gICAgICogQHBhcmFtIGV2YWx1YXRpb25JbmRpY2F0b3JLZXkgLSBJbmRpY2F0b3IgcHJvcGVydHkgbmFtZSB0byBtYXJrIGEgdmFsdWVcbiAgICAgKiB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0gZXhlY3V0aW9uSW5kaWNhdG9yS2V5IC0gSW5kaWNhdG9yIHByb3BlcnR5IG5hbWUgdG8gbWFyayBhIHZhbHVlXG4gICAgICogdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMgRXZhbHVhdGVkIGdpdmVuIG1hcHBpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHJlc29sdmVEeW5hbWljRGF0YVN0cnVjdHVyZShcbiAgICAgICAgb2JqZWN0OmFueSwgcGFyYW1ldGVyRGVzY3JpcHRpb246QXJyYXk8c3RyaW5nPiA9IFtdLFxuICAgICAgICBwYXJhbWV0ZXI6QXJyYXk8YW55PiA9IFtdLCBkZWVwOmJvb2xlYW4gPSB0cnVlLFxuICAgICAgICBldmFsdWF0aW9uSW5kaWNhdG9yS2V5OnN0cmluZyA9ICdfX2V2YWx1YXRlX18nLFxuICAgICAgICBleGVjdXRpb25JbmRpY2F0b3JLZXk6c3RyaW5nID0gJ19fZXhlY3V0ZV9fJ1xuICAgICk6YW55IHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb246YW55ID0gb2JqZWN0XG4gICAgICAgIGlmIChkZWVwICYmIGNvbmZpZ3VyYXRpb24gJiYgIWNvbmZpZ3VyYXRpb24uX190YXJnZXRfXylcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSBUb29scy5hZGREeW5hbWljR2V0dGVyQW5kU2V0dGVyKFxuICAgICAgICAgICAgICAgIFRvb2xzLmNvcHlMaW1pdGVkUmVjdXJzaXZlbHkob2JqZWN0KSwgKCh2YWx1ZTphbnkpOmFueSA9PlxuICAgICAgICAgICAgICAgICAgICBUb29scy5yZXNvbHZlRHluYW1pY0RhdGFTdHJ1Y3R1cmUoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSwgcGFyYW1ldGVyRGVzY3JpcHRpb24sIHBhcmFtZXRlciwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0aW9uSW5kaWNhdG9yS2V5LCBleGVjdXRpb25JbmRpY2F0b3JLZXlcbiAgICAgICAgICAgICAgICAgICAgKSksIChrZXk6YW55LCB2YWx1ZTphbnkpOmFueSA9PiB2YWx1ZSwgJ1tdJywgJycpXG4gICAgICAgIGlmIChwYXJhbWV0ZXJEZXNjcmlwdGlvbi5sZW5ndGggPiBwYXJhbWV0ZXIubGVuZ3RoKVxuICAgICAgICAgICAgcGFyYW1ldGVyLnB1c2goY29uZmlndXJhdGlvbilcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBkZWVwKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXg6bnVtYmVyID0gMFxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZTptaXhlZCBvZiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbaW5kZXhdID0gVG9vbHMucmVzb2x2ZUR5bmFtaWNEYXRhU3RydWN0dXJlKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSwgcGFyYW1ldGVyRGVzY3JpcHRpb24sIHBhcmFtZXRlciwgZGVlcCxcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGlvbkluZGljYXRvcktleSwgZXhlY3V0aW9uSW5kaWNhdG9yS2V5KVxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gb2JqZWN0KVxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb25JbmRpY2F0b3JLZXksIGV4ZWN1dGlvbkluZGljYXRvcktleVxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUb29scy5yZXNvbHZlRHluYW1pY0RhdGFTdHJ1Y3R1cmUoKG5ldyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZVR5cGVDaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShGdW5jdGlvbiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChwYXJhbWV0ZXJEZXNjcmlwdGlvbikuY29uY2F0KCgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09IGV2YWx1YXRpb25JbmRpY2F0b3JLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSA/ICdyZXR1cm4gJyA6ICcnKSArIG9iamVjdFtrZXldKSkpKS5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksIHBhcmFtZXRlckRlc2NyaXB0aW9uLCBwYXJhbWV0ZXIsIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb25JbmRpY2F0b3JLZXksIGV4ZWN1dGlvbkluZGljYXRvcktleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFcnJvciBkdXJpbmcgJyArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0gZXZhbHVhdGlvbkluZGljYXRvcktleSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2V4ZWN1dGluZycgOiAnZXZhbHVhdGluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArIGAgXCIke29iamVjdFtrZXldfVwiOiAke2Vycm9yfWApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IFRvb2xzLnJlc29sdmVEeW5hbWljRGF0YVN0cnVjdHVyZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSwgcGFyYW1ldGVyRGVzY3JpcHRpb24sIHBhcmFtZXRlciwgZGVlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0aW9uSW5kaWNhdG9yS2V5LCBleGVjdXRpb25JbmRpY2F0b3JLZXkpXG4gICAgICAgIHJldHVybiBvYmplY3RcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZ2l2ZW4gb2JqZWN0IGludG8gaXRzIHNlcmlhbGl6ZWQganNvbiByZXByZXNlbnRhdGlvbiBieVxuICAgICAqIHJlcGxhY2luZyBjaXJjdWxhciByZWZlcmVuY2VzIHdpdGggYSBnaXZlbiBwcm92aWRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0gZGV0ZXJtaW5lQ2ljdWxhclJlZmVyZW5jZVZhbHVlIC0gQ2FsbGJhY2sgdG8gY3JlYXRlIGEgZmFsbGJhY2tcbiAgICAgKiB2YWx1ZSBkZXBlbmRpbmcgb24gZ2l2ZW4gcmVkdW5kYW50IHZhbHVlLlxuICAgICAqIEBwYXJhbSBudW1iZXJPZlNwYWNlcyAtIE51bWJlciBvZiBzcGFjZXMgdG8gdXNlIGZvciBzdHJpbmcgZm9ybWF0dGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydENpcmN1bGFyT2JqZWN0VG9KU09OKFxuICAgICAgICBvYmplY3Q6T2JqZWN0LCBkZXRlcm1pbmVDaWN1bGFyUmVmZXJlbmNlVmFsdWU6KChcbiAgICAgICAgICAgIGtleTpzdHJpbmcsIHZhbHVlOmFueSwgc2VlbmRPYmplY3RzOkFycmF5PGFueT5cbiAgICAgICAgKSA9PiBhbnkpID0gKCk6c3RyaW5nID0+ICdfX2NpcmN1bGFyUmVmZXJlbmNlX18nLFxuICAgICAgICBudW1iZXJPZlNwYWNlczpudW1iZXIgPSAwXG4gICAgKTpzdHJpbmcge1xuICAgICAgICBjb25zdCBzZWVuT2JqZWN0czpBcnJheTxhbnk+ID0gW11cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdCwgKGtleTpzdHJpbmcsIHZhbHVlOmFueSk6YW55ID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5PYmplY3RzLmluY2x1ZGVzKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldGVybWluZUNpY3VsYXJSZWZlcmVuY2VWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSwgdmFsdWUsIHNlZW5PYmplY3RzKVxuICAgICAgICAgICAgICAgIHNlZW5PYmplY3RzLnB1c2godmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfSwgbnVtYmVyT2ZTcGFjZXMpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGdpdmVuIHBsYWluIG9iamVjdCBhbmQgYWxsIG5lc3RlZCBmb3VuZCBvYmplY3RzIHRvXG4gICAgICogY29ycmVzcG9uZGluZyBtYXAuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBjb252ZXJ0IHRvLlxuICAgICAqIEBwYXJhbSBkZWVwIC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcGVyZm9ybSBhIHJlY3Vyc2l2ZSBjb252ZXJzaW9uLlxuICAgICAqIEByZXR1cm5zIEdpdmVuIG9iamVjdCBhcyBtYXAuXG4gICAgICovXG4gICAgc3RhdGljIGNvbnZlcnRQbGFpbk9iamVjdFRvTWFwPFZhbHVlPihcbiAgICAgICAgb2JqZWN0OlZhbHVlLCBkZWVwOmJvb2xlYW4gPSB0cnVlXG4gICAgKTpWYWx1ZXxNYXA8YW55LCBhbnk+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIFRvb2xzLmlzUGxhaW5PYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgY29uc3QgbmV3T2JqZWN0Ok1hcDxhbnksIGFueT4gPSBuZXcgTWFwKClcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBvYmplY3QpXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWVwKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBUb29scy5jb252ZXJ0UGxhaW5PYmplY3RUb01hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSwgZGVlcClcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0LnNldChrZXksIG9iamVjdFtrZXldKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdPYmplY3RcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVlcClcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXg6bnVtYmVyID0gMFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWU6YW55IG9mIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbaW5kZXhdID0gVG9vbHMuY29udmVydFBsYWluT2JqZWN0VG9NYXAodmFsdWUsIGRlZXApXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleTptaXhlZCwgdmFsdWU6bWl4ZWRdIG9mIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNldChrZXksIFRvb2xzLmNvbnZlcnRQbGFpbk9iamVjdFRvTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGRlZXApKVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGdpdmVuIG1hcCBhbmQgYWxsIG5lc3RlZCBmb3VuZCBtYXBzIG9iamVjdHMgdG8gY29ycmVzcG9uZGluZ1xuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gTWFwIHRvIGNvbnZlcnQgdG8uXG4gICAgICogQHBhcmFtIGRlZXAgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBwZXJmb3JtIGEgcmVjdXJzaXZlIGNvbnZlcnNpb24uXG4gICAgICogQHJldHVybnMgR2l2ZW4gbWFwIGFzIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydE1hcFRvUGxhaW5PYmplY3Q8VmFsdWU+KFxuICAgICAgICBvYmplY3Q6VmFsdWUsIGRlZXA6Ym9vbGVhbiA9IHRydWVcbiAgICApOlZhbHVlfFBsYWluT2JqZWN0IHtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgY29uc3QgbmV3T2JqZWN0OlBsYWluT2JqZWN0ID0ge31cbiAgICAgICAgICAgIGZvciAobGV0IFtrZXk6YW55LCB2YWx1ZTptaXhlZF0gb2Ygb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZXApXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gVG9vbHMuY29udmVydE1hcFRvUGxhaW5PYmplY3QodmFsdWUsIGRlZXApXG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0W2Ake2tleX1gXSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3T2JqZWN0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZXApXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgVG9vbHMuaXNQbGFpbk9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBUb29scy5jb252ZXJ0TWFwVG9QbGFpbk9iamVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSwgZGVlcClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4Om51bWJlciA9IDBcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlOm1peGVkIG9mIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbaW5kZXhdID0gVG9vbHMuY29udmVydE1hcFRvUGxhaW5PYmplY3QodmFsdWUsIGRlZXApXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgZ2l2ZW4gb2JqZWN0cyBvd24gcHJvcGVydGllcyBpbiBzb3J0ZWQgZmFzaGlvbi4gRm9yXG4gICAgICogZWFjaCBrZXkgdmFsdWUgcGFpciBnaXZlbiBpdGVyYXRvciBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG4gICAgICogdmFsdWUgYW5kIGtleSBhcyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBpdGVyYXRlLlxuICAgICAqIEBwYXJhbSBpdGVyYXRvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2gga2V5IHZhbHVlIHBhaXIuIFZhbHVlXG4gICAgICogd2lsbCBiZSB0aGUgZmlyc3QgYW5kIGtleSB3aWxsIGJlIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgXCJ0aGlzXCIgYmluZGluZyBmb3IgZ2l2ZW4gaXRlcmF0b3IgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBnaXZlbiBzb3J0ZWQga2V5cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yRWFjaFNvcnRlZChcbiAgICAgICAgb2JqZWN0Om1peGVkLCBpdGVyYXRvcjooa2V5OmFueSwgdmFsdWU6YW55KSA9PiBhbnksIGNvbnRleHQ6T2JqZWN0XG4gICAgKTpBcnJheTxhbnk+IHtcbiAgICAgICAgY29uc3Qga2V5czpBcnJheTxhbnk+ID0gVG9vbHMuc29ydChvYmplY3QpXG4gICAgICAgIGZvciAoY29uc3Qga2V5OmFueSBvZiBrZXlzKVxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iamVjdC5nZXQoa2V5KSwga2V5KVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iamVjdFtrZXldLCBrZXkpXG4gICAgICAgIHJldHVybiBrZXlzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNvcnQgZ2l2ZW4gb2JqZWN0cyBrZXlzLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3Qgd2hpY2gga2V5cyBzaG91bGQgYmUgc29ydGVkLlxuICAgICAqIEByZXR1cm5zIFNvcnRlZCBsaXN0IG9mIGdpdmVuIGtleXMuXG4gICAgICovXG4gICAgc3RhdGljIHNvcnQob2JqZWN0Om1peGVkKTpBcnJheTxhbnk+IHtcbiAgICAgICAgY29uc3Qga2V5czpBcnJheTxhbnk+ID0gW11cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4Om51bWJlciA9IDA7IGluZGV4IDwgb2JqZWN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goaW5kZXgpXG4gICAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5VmFsdWVQYWlyOkFycmF5PGFueT4gb2Ygb2JqZWN0KVxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXlWYWx1ZVBhaXJbMF0pXG4gICAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBvYmplY3QpXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KVxuICAgICAgICByZXR1cm4ga2V5cy5zb3J0KClcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIGl0ZW1zIGFyZSBlcXVhbCBmb3IgZ2l2ZW4gcHJvcGVydHkgbGlzdC4gSWZcbiAgICAgKiBwcm9wZXJ0eSBsaXN0IGlzbid0IHNldCBhbGwgcHJvcGVydGllcyB3aWxsIGJlIGNoZWNrZWQuIEFsbCBrZXlzIHdoaWNoXG4gICAgICogc3RhcnRzIHdpdGggb25lIG9mIHRoZSBleGNlcHRpb24gcHJlZml4ZXMgd2lsbCBiZSBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSBmaXJzdFZhbHVlIC0gRmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHNlY29uZFZhbHVlIC0gU2Vjb25kIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIC0gUHJvcGVydHkgbmFtZXMgdG8gY2hlY2suIENoZWNrIGFsbCBpZiBcIm51bGxcIiBpc1xuICAgICAqIHNlbGVjdGVkIChkZWZhdWx0KS5cbiAgICAgKiBAcGFyYW0gZGVlcCAtIFJlY3Vyc2lvbiBkZXB0aCBuZWdhdGl2ZSB2YWx1ZXMgbWVhbnMgaW5maW5pdGVseSBkZWVwXG4gICAgICogKGRlZmF1bHQpLlxuICAgICAqIEBwYXJhbSBleGNlcHRpb25QcmVmaXhlcyAtIFByb3BlcnR5IHByZWZpeGVzIHdoaWNoIGluZGljYXRlcyBwcm9wZXJ0aWVzXG4gICAgICogdG8gaWdub3JlLlxuICAgICAqIEBwYXJhbSBpZ25vcmVGdW5jdGlvbnMgLSBJbmRpY2F0ZXMgd2hldGhlciBmdW5jdGlvbnMgaGF2ZSB0byBiZVxuICAgICAqIGlkZW50aWNhbCB0byBpbnRlcnByZXQgaXMgYXMgZXF1YWwuIElmIHNldCB0byBcInRydWVcIiB0d28gZnVuY3Rpb25zIHdpbGxcbiAgICAgKiBiZSBhc3N1bWVkIHRvIGJlIGVxdWFsIChkZWZhdWx0KS5cbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBcInRydWVcIiBpZiBib3RoIG9iamVjdHMgYXJlIGVxdWFsIGFuZCBcImZhbHNlXCIgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBlcXVhbHMoXG4gICAgICAgIGZpcnN0VmFsdWU6YW55LCBzZWNvbmRWYWx1ZTphbnksIHByb3BlcnRpZXM6P0FycmF5PGFueT4gPSBudWxsLFxuICAgICAgICBkZWVwOm51bWJlciA9IC0xLCBleGNlcHRpb25QcmVmaXhlczpBcnJheTxzdHJpbmc+ID0gWyckJywgJ18nXSxcbiAgICAgICAgaWdub3JlRnVuY3Rpb25zOmJvb2xlYW4gPSB0cnVlXG4gICAgKTpib29sZWFuIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaWdub3JlRnVuY3Rpb25zICYmIFRvb2xzLmlzRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgZmlyc3RWYWx1ZVxuICAgICAgICAgICAgKSAmJiBUb29scy5pc0Z1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHNlY29uZFZhbHVlXG4gICAgICAgICAgICApIHx8IGZpcnN0VmFsdWUgPT09IHNlY29uZFZhbHVlIHx8IFRvb2xzLm51bWJlcklzTm90QU51bWJlcihcbiAgICAgICAgICAgICAgICBmaXJzdFZhbHVlXG4gICAgICAgICAgICApICYmIFRvb2xzLm51bWJlcklzTm90QU51bWJlcihzZWNvbmRWYWx1ZSkgfHxcbiAgICAgICAgICAgIGZpcnN0VmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgJiZcbiAgICAgICAgICAgIHNlY29uZFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwICYmXG4gICAgICAgICAgICBmaXJzdFZhbHVlLnRvU3RyaW5nKCkgPT09IHNlY29uZFZhbHVlLnRvU3RyaW5nKCkgfHxcbiAgICAgICAgICAgIGZpcnN0VmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmXG4gICAgICAgICAgICBzZWNvbmRWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgKFxuICAgICAgICAgICAgICAgIGlzTmFOKGZpcnN0VmFsdWUuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGlzTmFOKHNlY29uZFZhbHVlLmdldFRpbWUoKSkgfHxcbiAgICAgICAgICAgICAgICAhaXNOYU4oZmlyc3RWYWx1ZS5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKHNlY29uZFZhbHVlLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmaXJzdFZhbHVlLmdldFRpbWUoKSA9PT0gc2Vjb25kVmFsdWUuZ2V0VGltZSgpXG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGlmIChUb29scy5pc1BsYWluT2JqZWN0KGZpcnN0VmFsdWUpICYmIFRvb2xzLmlzUGxhaW5PYmplY3QoXG4gICAgICAgICAgICBzZWNvbmRWYWx1ZVxuICAgICAgICApICYmICEoXG4gICAgICAgICAgICBmaXJzdFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHNlY29uZFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgICkgfHwgQXJyYXkuaXNBcnJheShmaXJzdFZhbHVlKSAmJiBBcnJheS5pc0FycmF5KFxuICAgICAgICAgICAgc2Vjb25kVmFsdWVcbiAgICAgICAgKSAmJiBmaXJzdFZhbHVlLmxlbmd0aCA9PT0gc2Vjb25kVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaXJzdCwgc2Vjb25kXSBvZiBbW2ZpcnN0VmFsdWUsIHNlY29uZFZhbHVlXSwgW1xuICAgICAgICAgICAgICAgIHNlY29uZFZhbHVlLCBmaXJzdFZhbHVlXG4gICAgICAgICAgICBdXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0SXNBcnJheTpib29sZWFuID0gQXJyYXkuaXNBcnJheShmaXJzdClcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RJc0FycmF5ICYmICghQXJyYXkuaXNBcnJheShcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kXG4gICAgICAgICAgICAgICAgKSkgfHwgZmlyc3QubGVuZ3RoICE9PSBzZWNvbmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICBsZXQgZXF1YWw6Ym9vbGVhbiA9IHRydWVcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWU6YW55IG9mIGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAhPT0gMCAmJiAhVG9vbHMuZXF1YWxzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLCBzZWNvbmRbaW5kZXhdLCBwcm9wZXJ0aWVzLCBkZWVwIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHRpb25QcmVmaXhlc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsIHx8IHByb3BlcnRpZXMgJiYgIXByb3BlcnRpZXMuaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRvQnJlYWs6Ym9vbGVhbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjZXB0aW9uUHJlZml4OnN0cmluZyBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHRpb25QcmVmaXhlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS50b1N0cmluZygpLnN0YXJ0c1dpdGgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHRpb25QcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9CcmVhayA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9CcmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAhPT0gMCAmJiAhVG9vbHMuZXF1YWxzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFtrZXldLCBzZWNvbmRba2V5XSwgcHJvcGVydGllcywgZGVlcCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvblByZWZpeGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWwgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZXF1YWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGdpdmVuIG9iamVjdCAob2YgYW55IHR5cGUpIGludG8gb3B0aW9uYWxseSBnaXZlbiBkZXN0aW5hdGlvbi5cbiAgICAgKiBAcGFyYW0gc291cmNlIC0gT2JqZWN0IHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHJlY3Vyc2lvbkxpbWl0IC0gU3BlY2lmaWVzIGhvdyBkZWVwIHdlIHNob3VsZCB0cmF2ZXJzZSBpbnRvIGdpdmVuXG4gICAgICogb2JqZWN0IHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiAtIFRhcmdldCB0byBjb3B5IHNvdXJjZSB0by5cbiAgICAgKiBAcGFyYW0gc3RhY2tTb3VyY2UgLSBJbnRlcm5hbGx5IHVzZWQgdG8gYXZvaWQgdHJhdmVyc2luZyBsb29wcy5cbiAgICAgKiBAcGFyYW0gc3RhY2tEZXN0aW5hdGlvbiAtIEludGVybmFsbHkgdXNlZCB0byBhdm9pZCB0cmF2ZXJzaW5nIGxvb3BzIGFuZFxuICAgICAqIHJlZmVyZW5jaW5nIHRoZW0gY29ycmVjdGx5LlxuICAgICAqIEBwYXJhbSByZWN1cnNpb25MZXZlbCAtIEludGVybmFsbHkgdXNlZCB0byB0cmFjayBjdXJyZW50IHJlY3Vyc2lvblxuICAgICAqIGxldmVsIGluIGdpdmVuIHNvdXJjZSBkYXRhIHN0cnVjdHVyZS5cbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBcInRydWVcIiBpZiBib3RoIG9iamVjdHMgYXJlIGVxdWFsIGFuZCBcImZhbHNlXCIgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb3B5TGltaXRlZFJlY3Vyc2l2ZWx5KFxuICAgICAgICBzb3VyY2U6YW55LCByZWN1cnNpb25MaW1pdDpudW1iZXIgPSAtMSwgZGVzdGluYXRpb246YW55ID0gbnVsbCxcbiAgICAgICAgc3RhY2tTb3VyY2U6QXJyYXk8YW55PiA9IFtdLCBzdGFja0Rlc3RpbmF0aW9uOkFycmF5PGFueT4gPSBbXSxcbiAgICAgICAgcmVjdXJzaW9uTGV2ZWw6bnVtYmVyID0gMFxuICAgICk6YW55IHtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBkZXN0aW5hdGlvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJDYW4ndCBjb3B5IGJlY2F1c2Ugc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcmUgaWRlbnRpY2FsLlwiKVxuICAgICAgICAgICAgaWYgKHJlY3Vyc2lvbkxpbWl0ICE9PSAtMSAmJiByZWN1cnNpb25MaW1pdCA8IHJlY3Vyc2lvbkxldmVsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICBpZiAoIVt1bmRlZmluZWQsIG51bGxdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgKSAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4Om51bWJlciA9IHN0YWNrU291cmNlLmluZGV4T2Yoc291cmNlKVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja0Rlc3RpbmF0aW9uW2luZGV4XVxuICAgICAgICAgICAgICAgIHN0YWNrU291cmNlLnB1c2goc291cmNlKVxuICAgICAgICAgICAgICAgIHN0YWNrRGVzdGluYXRpb24ucHVzaChkZXN0aW5hdGlvbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvcHlWYWx1ZTpGdW5jdGlvbiA9ICh2YWx1ZTphbnkpOmFueSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OmFueSA9IFRvb2xzLmNvcHlMaW1pdGVkUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLCByZWN1cnNpb25MaW1pdCwgbnVsbCwgc3RhY2tTb3VyY2UsIHN0YWNrRGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxldmVsICsgMSlcbiAgICAgICAgICAgICAgICBpZiAoIVt1bmRlZmluZWQsIG51bGxdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzdGFja1NvdXJjZS5wdXNoKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBzdGFja0Rlc3RpbmF0aW9uLnB1c2gocmVzdWx0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbTphbnkgb2Ygc291cmNlKVxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvcHlWYWx1ZShpdGVtKSlcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5Om1peGVkLCB2YWx1ZTptaXhlZF0gb2Ygc291cmNlKVxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5zZXQoa2V5LCBjb3B5VmFsdWUodmFsdWUpKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBjb3B5VmFsdWUoc291cmNlW2tleV0pXG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKVxuICAgICAgICAgICAgICAgIHJldHVybiBUb29scy5jb3B5TGltaXRlZFJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsIHJlY3Vyc2lvbkxpbWl0LCBbXSwgc3RhY2tTb3VyY2UsIHN0YWNrRGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxldmVsKVxuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgICAgICByZXR1cm4gVG9vbHMuY29weUxpbWl0ZWRSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLCByZWN1cnNpb25MaW1pdCwgbmV3IE1hcCgpLCBzdGFja1NvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tEZXN0aW5hdGlvbiwgcmVjdXJzaW9uTGV2ZWwpXG4gICAgICAgICAgICBpZiAoVG9vbHMuZGV0ZXJtaW5lVHlwZShzb3VyY2UpID09PSAnZGF0ZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHNvdXJjZS5nZXRUaW1lKCkpXG4gICAgICAgICAgICBpZiAoVG9vbHMuZGV0ZXJtaW5lVHlwZShzb3VyY2UpID09PSAncmVnZXhwJykge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLnNvdXJjZSwgc291cmNlLnRvU3RyaW5nKCkubWF0Y2goL1teXFwvXSokLylbMF0pXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubGFzdEluZGV4ID0gc291cmNlLmxhc3RJbmRleFxuICAgICAgICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFbdW5kZWZpbmVkLCBudWxsXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgICkgJiYgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRvb2xzLmNvcHlMaW1pdGVkUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSwgcmVjdXJzaW9uTGltaXQsIHt9LCBzdGFja1NvdXJjZSwgc3RhY2tEZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uTGV2ZWwpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uIHx8IHNvdXJjZVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGFycmF5XG4gICAgLyoqXG4gICAgICogTWVyZ2UgdGhlIGNvbnRlbnRzIG9mIHR3byBhcnJheXMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRhcmdldCBhcnJheS5cbiAgICAgKiBAcGFyYW0gc291cmNlIC0gU291cmNlIGFycmF5LlxuICAgICAqIEByZXR1cm5zIFRhcmdldCBhcnJheSB3aXRoIG1lcmdlZCBnaXZlbiBzb3VyY2Ugb25lLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheU1lcmdlKHRhcmdldDpBcnJheTxhbnk+LCBzb3VyY2U6QXJyYXk8YW55Pik6QXJyYXk8YW55PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aDpudW1iZXIgPSBOdW1iZXIoc291cmNlLmxlbmd0aClcbiAgICAgICAgbGV0IHNvdXJjZUluZGV4Om51bWJlciA9IDBcbiAgICAgICAgbGV0IHRhcmdldEluZGV4Om51bWJlciA9IHRhcmdldC5sZW5ndGhcbiAgICAgICAgZm9yICg7c291cmNlSW5kZXggPCBsZW5ndGg7IHNvdXJjZUluZGV4KyspXG4gICAgICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXgrK10gPSBzb3VyY2Vbc291cmNlSW5kZXhdXG4gICAgICAgIHRhcmdldC5sZW5ndGggPSB0YXJnZXRJbmRleFxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGdpdmVuIG9iamVjdCBpbnRvIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBUYXJnZXQgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyBHZW5lcmF0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5TWFrZShvYmplY3Q6YW55KTpBcnJheTxhbnk+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0OkFycmF5PGFueT4gPSBbXVxuICAgICAgICBpZiAoIVtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKHJlc3VsdCkpXG4gICAgICAgICAgICBpZiAoVG9vbHMuaXNBcnJheUxpa2UoT2JqZWN0KG9iamVjdCkpKVxuICAgICAgICAgICAgICAgIFRvb2xzLmFycmF5TWVyZ2UoXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCwgdHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycgPyBbb2JqZWN0XSA6IG9iamVjdClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmplY3QpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgYWxsIHZhbHVlcyBpbiBnaXZlbiBpdGVyYWJsZSB1bmlxdWUgYnkgcmVtb3ZpbmcgZHVwbGljYXRlcyAoVGhlXG4gICAgICogZmlyc3Qgb2NjdXJyZW5jZXMgd2lsbCBiZSBsZWZ0KS5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIEFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFNsaWNlZCB2ZXJzaW9uIG9mIGdpdmVuIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlVbmlxdWUoZGF0YTpBcnJheTxhbnk+KTpBcnJheTxhbnk+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0OkFycmF5PGFueT4gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlOmFueSBvZiBkYXRhKVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuaW5jbHVkZXModmFsdWUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1bW1hcml6ZXMgZ2l2ZW4gcHJvcGVydHkgb2YgZ2l2ZW4gaXRlbSBsaXN0LlxuICAgICAqIEBwYXJhbSBkYXRhIC0gQXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGdpdmVuIHByb3BlcnR5IG5hbWUuXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSAtIFByb3BlcnR5IG5hbWUgdG8gc3VtbWFyaXplLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBWYWx1ZSB0byByZXR1cm4gaWYgcHJvcGVydHkgdmFsdWVzIGRvZXNuJ3QgbWF0Y2guXG4gICAgICogQHJldHVybnMgU3VtbWFyaXplZCBhcnJheS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlBZ2dyZWdhdGVQcm9wZXJ0eUlmRXF1YWwoXG4gICAgICAgIGRhdGE6QXJyYXk8T2JqZWN0PiwgcHJvcGVydHlOYW1lOnN0cmluZywgZGVmYXVsdFZhbHVlOmFueSA9ICcnXG4gICAgKTphbnkge1xuICAgICAgICBsZXQgcmVzdWx0OmFueSA9IGRlZmF1bHRWYWx1ZVxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCAmJiBkYXRhWzBdLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRhdGFbMF1bcHJvcGVydHlOYW1lXVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1bcHJvcGVydHlOYW1lXSAhPT0gcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGV2ZXJ5IGl0ZW0gd2l0Y2ggaGFzIG9ubHkgZW1wdHkgYXR0cmlidXRlcyBmb3IgZ2l2ZW4gcHJvcGVydHlcbiAgICAgKiBuYW1lcy4gSWYgZ2l2ZW4gcHJvcGVydHkgbmFtZXMgYXJlIGVtcHR5IGVhY2ggYXR0cmlidXRlIHdpbGwgYmVcbiAgICAgKiBjb25zaWRlcmVkLiBUaGUgZW1wdHkgc3RyaW5nLCBcIm51bGxcIiBhbmQgXCJ1bmRlZmluZWRcIiB3aWxsIGJlIGludGVycHJldGVkXG4gICAgICogYXMgZW1wdHkuXG4gICAgICogQHBhcmFtIGRhdGEgLSBEYXRhIHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lcyAtIFByb3BlcnRpZXMgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybnMgR2l2ZW4gZGF0YSB3aXRob3V0IGVtcHR5IGl0ZW1zLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheURlbGV0ZUVtcHR5SXRlbXMoXG4gICAgICAgIGRhdGE6P0FycmF5PE9iamVjdD4sIHByb3BlcnR5TmFtZXM6QXJyYXk8c3RyaW5nPiA9IFtdXG4gICAgKTo/QXJyYXk8T2JqZWN0PiB7XG4gICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgIGNvbnN0IHJlc3VsdDpBcnJheTxhbnk+ID0gW11cbiAgICAgICAgZm9yIChjb25zdCBpdGVtOmFueSBvZiBkYXRhKSB7XG4gICAgICAgICAgICBsZXQgZW1wdHk6Ym9vbGVhbiA9IHRydWVcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lOnN0cmluZyBpbiBpdGVtKVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIGlmICghWycnLCBudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKGl0ZW1bXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWVcbiAgICAgICAgICAgICAgICAgICAgXSkgJiYgKCFwcm9wZXJ0eU5hbWVzLmxlbmd0aCB8fCBwcm9wZXJ0eU5hbWVzLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lXG4gICAgICAgICAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVtcHR5KVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBhbGwgcHJvcGVydGllcyBmcm9tIGFsbCBpdGVtcyB3aWNoIG9jY3VyIGluIGdpdmVuIHByb3BlcnR5XG4gICAgICogbmFtZXMuXG4gICAgICogQHBhcmFtIGRhdGEgLSBEYXRhIHdoZXJlIGVhY2ggaXRlbSBzaG91bGQgYmUgc2xpY2VkLlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWVzIC0gUHJvcGVydHkgbmFtZXMgdG8gZXh0cmFjdC5cbiAgICAgKiBAcmV0dXJucyBEYXRhIHdpdGggc2xpY2VkIGl0ZW1zLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheUV4dHJhY3QoXG4gICAgICAgIGRhdGE6QXJyYXk8T2JqZWN0PiwgcHJvcGVydHlOYW1lczpBcnJheTxzdHJpbmc+XG4gICAgKTpBcnJheTxPYmplY3Q+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0OkFycmF5PE9iamVjdD4gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW06T2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW06T2JqZWN0ID0ge31cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lOnN0cmluZyBvZiBwcm9wZXJ0eU5hbWVzKVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW1bcHJvcGVydHlOYW1lXSA9IGl0ZW1bcHJvcGVydHlOYW1lXVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3SXRlbSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGFsbCB2YWx1ZXMgd2hpY2ggbWF0Y2hlcyBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICogQHBhcmFtIGRhdGEgLSBEYXRhIHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gcmVndWxhckV4cHJlc3Npb24gLSBQYXR0ZXJuIHRvIG1hdGNoIGZvci5cbiAgICAgKiBAcmV0dXJucyBGaWx0ZXJlZCBkYXRhLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheUV4dHJhY3RJZk1hdGNoZXMoXG4gICAgICAgIGRhdGE6QXJyYXk8c3RyaW5nPiwgcmVndWxhckV4cHJlc3Npb246c3RyaW5nfFJlZ0V4cFxuICAgICk6QXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDpBcnJheTxzdHJpbmc+ID0gW11cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZTpzdHJpbmcgb2YgZGF0YSlcbiAgICAgICAgICAgIGlmICgoKHR5cGVvZiByZWd1bGFyRXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpID8gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvblxuICAgICAgICAgICAgKSA6IHJlZ3VsYXJFeHByZXNzaW9uKS50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIGdpdmVuIGRhdGEgaWYgZ2l2ZW4gcHJvcGVydHkgaXMgc2V0IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIERhdGEgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgLSBQcm9wZXJ0eSBuYW1lIHRvIGNoZWNrIGZvciBleGlzdGVuY2UuXG4gICAgICogQHJldHVybnMgR2l2ZW4gZGF0YSB3aXRob3V0IHRoZSBpdGVtcyB3aGljaCBkb2Vzbid0IGhhdmUgc3BlY2lmaWVkXG4gICAgICogcHJvcGVydHkuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5RXh0cmFjdElmUHJvcGVydHlFeGlzdHMoXG4gICAgICAgIGRhdGE6P0FycmF5PE9iamVjdD4sIHByb3BlcnR5TmFtZTpzdHJpbmdcbiAgICApOj9BcnJheTxPYmplY3Q+IHtcbiAgICAgICAgaWYgKGRhdGEgJiYgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6QXJyYXk8T2JqZWN0PiA9IFtdXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW06T2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RzOmJvb2xlYW4gPSBmYWxzZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBpdGVtKVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBwcm9wZXJ0eU5hbWUgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFbXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIG51bGxcbiAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhpdGVtW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdHMgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGdpdmVuIGRhdGEgd2hlcmUgc3BlY2lmaWVkIHByb3BlcnR5IHZhbHVlIG1hdGNoZXMgZ2l2ZW5cbiAgICAgKiBwYXR0ZXJucy5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIERhdGEgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eVBhdHRlcm4gLSBNYXBwaW5nIG9mIHByb3BlcnR5IG5hbWVzIHRvIHBhdHRlcm4uXG4gICAgICogQHJldHVybnMgRmlsdGVyZWQgZGF0YS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlFeHRyYWN0SWZQcm9wZXJ0eU1hdGNoZXMoXG4gICAgICAgIGRhdGE6P0FycmF5PE9iamVjdD4sIHByb3BlcnR5UGF0dGVybjp7W2tleTpzdHJpbmddOnN0cmluZ3xSZWdFeHB9XG4gICAgKTo/QXJyYXk8T2JqZWN0PiB7XG4gICAgICAgIGlmIChkYXRhICYmIHByb3BlcnR5UGF0dGVybikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OkFycmF5PE9iamVjdD4gPSBbXVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtOk9iamVjdCBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXM6Ym9vbGVhbiA9IHRydWVcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZTpzdHJpbmcgaW4gcHJvcGVydHlQYXR0ZXJuKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISgoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVBhdHRlcm5bcHJvcGVydHlOYW1lXSBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICApID8gcHJvcGVydHlQYXR0ZXJuW3Byb3BlcnR5TmFtZV0gOiBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlQYXR0ZXJuW3Byb3BlcnR5TmFtZV1cbiAgICAgICAgICAgICAgICAgICAgKSkudGVzdChpdGVtW3Byb3BlcnR5TmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGFsbCBvYmplY3RzIHdoaWNoIGV4aXN0cyBpbiBcImZpcnN0U2V0XCIgYW5kIGluIFwic2Vjb25kU2V0XCIuXG4gICAgICogT2JqZWN0IGtleSB3aGljaCB3aWxsIGJlIGNvbXBhcmVkIGFyZSBnaXZlbiBieSBcImtleXNcIi4gSWYgYW4gZW1wdHkgYXJyYXlcbiAgICAgKiBpcyBnaXZlbiBlYWNoIGtleSB3aWxsIGJlIGNvbXBhcmVkLiBJZiBhbiBvYmplY3QgaXMgZ2l2ZW4gY29ycmVzcG9uZGluZ1xuICAgICAqIGluaXRpYWwgZGF0YSBrZXkgd2lsbCBiZSBtYXBwZWQgdG8gcmVmZXJlbmNlZCBuZXcgZGF0YSBrZXkuXG4gICAgICogQHBhcmFtIGZpcnN0U2V0IC0gUmVmZXJlbmNlZCBkYXRhIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0gc2Vjb25kU2V0IC0gRGF0YSB0byBjaGVjayBmb3IgZXhpc3RlbmNlLlxuICAgICAqIEBwYXJhbSBrZXlzIC0gS2V5cyB0byBkZWZpbmUgZXF1YWxpdHkuXG4gICAgICogQHBhcmFtIHN0cmljdCAtIFRoZSBzdHJpY3QgcGFyYW1ldGVyIGluZGljYXRlcyB3aGV0aGVyIFwibnVsbFwiIGFuZFxuICAgICAqIFwidW5kZWZpbmVkXCIgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGVxdWFsICh0YWtlcyBvbmx5IGVmZmVjdCBpZiBnaXZlblxuICAgICAqIGtleXMgYXJlbid0IGVtcHR5KS5cbiAgICAgKiBAcmV0dXJucyBEYXRhIHdoaWNoIGRvZXMgZXhpdCBpbiBnaXZlbiBpbml0aWFsIGRhdGEuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5SW50ZXJzZWN0KFxuICAgICAgICBmaXJzdFNldDpBcnJheTxhbnk+LCBzZWNvbmRTZXQ6QXJyYXk8YW55PixcbiAgICAgICAga2V5czpPYmplY3R8QXJyYXk8c3RyaW5nPiA9IFtdLCBzdHJpY3Q6Ym9vbGVhbiA9IHRydWVcbiAgICApOkFycmF5PGFueT4ge1xuICAgICAgICBjb25zdCBjb250YWluaW5nRGF0YTpBcnJheTxhbnk+ID0gW11cbiAgICAgICAgZm9yIChjb25zdCBpbml0aWFsSXRlbTphbnkgb2YgZmlyc3RTZXQpXG4gICAgICAgICAgICBpZiAoVG9vbHMuaXNQbGFpbk9iamVjdChpbml0aWFsSXRlbSkpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXdJdGVtOmFueSBvZiBzZWNvbmRTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4aXN0czpib29sZWFuID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0ZUdpdmVuS2V5czpib29sZWFuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXNBcmVBbkFycmF5OmJvb2xlYW4gPSBBcnJheS5pc0FycmF5KGtleXMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChUb29scy5pc1BsYWluT2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5c1xuICAgICAgICAgICAgICAgICAgICApIHx8IGtleXNBcmVBbkFycmF5ICYmIGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUdpdmVuS2V5cyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlR2l2ZW5LZXlzID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMgPSBpbml0aWFsSXRlbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZTpGdW5jdGlvbiA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0U2V0S2V5OnN0cmluZ3xudW1iZXIsIHNlY29uZFNldEtleTpzdHJpbmd8bnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICk6P2ZhbHNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlzQXJlQW5BcnJheSAmJiBpdGVyYXRlR2l2ZW5LZXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0U2V0S2V5ID0gc2Vjb25kU2V0S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXRlcmF0ZUdpdmVuS2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRTZXRLZXkgPSBmaXJzdFNldEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0l0ZW1bc2Vjb25kU2V0S2V5XSAhPT0gaW5pdGlhbEl0ZW1bXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTZXRLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0gJiYgKHN0cmljdCB8fCAhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtW3NlY29uZFNldEtleV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApICYmIFtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsSXRlbVtmaXJzdFNldEtleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICApKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0cyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUoaW5kZXgsIGtleSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4ga2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlKGtleSwga2V5c1trZXldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nRGF0YS5wdXNoKGluaXRpYWxJdGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlY29uZFNldC5pbmNsdWRlcyhpbml0aWFsSXRlbSkpXG4gICAgICAgICAgICAgICAgY29udGFpbmluZ0RhdGEucHVzaChpbml0aWFsSXRlbSlcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5pbmdEYXRhXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsaXN0IG9mIGl0ZW1zIHdpdGhpbiBnaXZlbiByYW5nZS5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBBcnJheSBvZiBsb3dlciBhbmQgdXBwZXIgYm91bmRzLiBJZiBvbmx5IG9uZSB2YWx1ZSBpc1xuICAgICAqIGdpdmVuIGxvd2VyIGJvdW5kIHdpbGwgYmUgYXNzdW1lZCB0byBiZSB6ZXJvLiBCb3RoIGludGVnZXJzIGhhdmUgdG8gYmVcbiAgICAgKiBwb3NpdGl2ZSBhbmQgd2lsbCBiZSBjb250YWluZWQgaW4gdGhlIHJlc3VsdGluZyBhcnJheS5cbiAgICAgKiBAcGFyYW0gc3RlcCAtIFNwYWNlIGJldHdlZW4gdHdvIGNvbnNlY3V0aXZlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyBQcm9kdWNlZCBhcnJheSBvZiBpbnRlZ2Vycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlNYWtlUmFuZ2UocmFuZ2U6QXJyYXk8bnVtYmVyPiwgc3RlcDpudW1iZXIgPSAxKTpBcnJheTxudW1iZXI+IHtcbiAgICAgICAgbGV0IGluZGV4Om51bWJlclxuICAgICAgICBsZXQgaGlnaGVyQm91bmQ6bnVtYmVyXG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMFxuICAgICAgICAgICAgaGlnaGVyQm91bmQgPSBwYXJzZUludChyYW5nZVswXSwgMTApXG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KHJhbmdlWzBdLCAxMClcbiAgICAgICAgICAgIGhpZ2hlckJvdW5kID0gcGFyc2VJbnQocmFuZ2VbMV0sIDEwKVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJldHVybiByYW5nZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbaW5kZXhdXG4gICAgICAgIHdoaWxlIChpbmRleCA8PSBoaWdoZXJCb3VuZCAtIHN0ZXApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHN0ZXBcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VtcyB1cCBnaXZlbiBwcm9wZXJ0eSBvZiBnaXZlbiBpdGVtIGxpc3QuXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgb2JqZWN0cyB3aXRoIHNwZWNpZmllZCBwcm9wZXJ0eSB0byBzdW0gdXAuXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSAtIFByb3BlcnR5IG5hbWUgdG8gc3VtIHVwIGl0cyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgYWdncmVnYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlTdW1VcFByb3BlcnR5KFxuICAgICAgICBkYXRhOj9BcnJheTxPYmplY3Q+LCBwcm9wZXJ0eU5hbWU6c3RyaW5nXG4gICAgKTpudW1iZXIge1xuICAgICAgICBsZXQgcmVzdWx0Om51bWJlciA9IDBcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW06T2JqZWN0IG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHBhcnNlRmxvYXQoaXRlbVtwcm9wZXJ0eU5hbWVdIHx8IDApXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIHRvIGFub3RoZXIgaXRlbSBhcyBhcnJheSBjb25uZWN0aW9uIChtYW55IHRvIG9uZSkuXG4gICAgICogQHBhcmFtIGl0ZW0gLSBJdGVtIHdoZXJlIHRoZSBpdGVtIHNob3VsZCBiZSBhcHBlbmRlZCB0by5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGFyZ2V0IHRvIGFkZCB0byBnaXZlbiBpdGVtLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgdGFyZ2V0IGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGNoZWNrSWZFeGlzdHMgLSBJbmRpY2F0ZXMgaWYgZHVwbGljYXRlcyBhcmUgYWxsb3dlZCBpbiByZXN1bHRpbmdcbiAgICAgKiBsaXN0ICh3aWxsIHJlc3VsdCBpbiBsaW5lYXIgcnVudGltZSBpbnN0ZWFkIG9mIGNvbnN0YW50IG9uZSkuXG4gICAgICogQHJldHVybnMgSXRlbSB3aXRoIHRoZSBhcHBlbmRlZCB0YXJnZXQuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5QXBwZW5kQWRkKFxuICAgICAgICBpdGVtOk9iamVjdCwgdGFyZ2V0OmFueSwgbmFtZTpzdHJpbmcsIGNoZWNrSWZFeGlzdHM6Ym9vbGVhbiA9IHRydWVcbiAgICApOk9iamVjdCB7XG4gICAgICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoIShjaGVja0lmRXhpc3RzICYmIGl0ZW1bbmFtZV0uaW5jbHVkZXModGFyZ2V0KSkpXG4gICAgICAgICAgICAgICAgaXRlbVtuYW1lXS5wdXNoKHRhcmdldClcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBpdGVtW25hbWVdID0gW3RhcmdldF1cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBnaXZlbiB0YXJnZXQgb24gZ2l2ZW4gbGlzdC5cbiAgICAgKiBAcGFyYW0gbGlzdCAtIEFycmF5IHRvIHNwbGljZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGFyZ2V0IHRvIHJlbW92ZSBmcm9tIGdpdmVuIGxpc3QuXG4gICAgICogQHBhcmFtIHN0cmljdCAtIEluZGljYXRlcyB3aGV0aGVyIHRvIGZpcmUgYW4gZXhjZXB0aW9uIGlmIGdpdmVuIHRhcmdldFxuICAgICAqIGRvZXNuJ3QgZXhpc3RzIGdpdmVuIGxpc3QuXG4gICAgICogQHJldHVybnMgSXRlbSB3aXRoIHRoZSBhcHBlbmRlZCB0YXJnZXQuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5UmVtb3ZlKFxuICAgICAgICBsaXN0Oj9BcnJheTxhbnk+LCB0YXJnZXQ6YW55LCBzdHJpY3Q6Ym9vbGVhbiA9IGZhbHNlXG4gICAgKTo/QXJyYXk8YW55PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleDpudW1iZXIgPSBsaXN0LmluZGV4T2YodGFyZ2V0KVxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiR2l2ZW4gdGFyZ2V0IGRvZXNuJ3QgZXhpc3RzIGluIGdpdmVuIGxpc3QuXCIpXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmUgKi9cbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkdpdmVuIHRhcmdldCBpc24ndCBhbiBhcnJheS5cIilcbiAgICAgICAgcmV0dXJuIGxpc3RcbiAgICB9XG4gICAgLy8gLyBlbmRyZWdpb25cbiAgICAvLyAvIHJlZ2lvbiBzdHJpbmdcbiAgICAvLyAvLyByZWdpb24gdXJsIGhhbmRsaW5nXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBnaXZlbiBzdHJpbmcgaW50byB0aGUgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlZFxuICAgICAqIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBleGNsdWRlU3ltYm9scyAtIFN5bWJvbHMgbm90IHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyBDb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdDb252ZXJ0VG9WYWxpZFJlZ3VsYXJFeHByZXNzaW9uKFxuICAgICAgICB2YWx1ZTpzdHJpbmcsIGV4Y2x1ZGVTeW1ib2xzOkFycmF5PHN0cmluZz4gPSBbXVxuICAgICk6c3RyaW5nIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBvbmx5IGZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEgJiYgIVRvb2xzLnNwZWNpYWxSZWdleFNlcXVlbmNlcy5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gVGhlIGVzY2FwZSBzZXF1ZW5jZSBtdXN0IGFsc28gYmUgZXNjYXBlZDsgYnV0IGF0IGZpcnN0LlxuICAgICAgICBpZiAoIWV4Y2x1ZGVTeW1ib2xzLmluY2x1ZGVzKCdcXFxcJykpXG4gICAgICAgICAgICB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgICAgIGZvciAoY29uc3QgcmVwbGFjZTpzdHJpbmcgb2YgVG9vbHMuc3BlY2lhbFJlZ2V4U2VxdWVuY2VzKVxuICAgICAgICAgICAgaWYgKCFleGNsdWRlU3ltYm9scy5pbmNsdWRlcyhyZXBsYWNlKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoYFxcXFwke3JlcGxhY2V9YCwgJ2cnKSwgYFxcXFwke3JlcGxhY2V9YClcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgZ2l2ZW4gbmFtZSBpbnRvIGEgdmFsaWQgamF2YVNjcmlwdCBvbmUuXG4gICAgICogQHBhcmFtIG5hbWUgLSBOYW1lIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIGFsbG93ZWRTeW1ib2xzIC0gU3RyaW5nIG9mIHN5bWJvbHMgd2hpY2ggc2hvdWxkIGJlIGFsbG93ZWQgd2l0aGluXG4gICAgICogYSB2YXJpYWJsZSBuYW1lIChub3QgdGhlIGZpcnN0IGNoYXJhY3RlcikuXG4gICAgICogQHJldHVybnMgQ29udmVydGVkIG5hbWUgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0NvbnZlcnRUb1ZhbGlkVmFyaWFibGVOYW1lKFxuICAgICAgICBuYW1lOnN0cmluZywgYWxsb3dlZFN5bWJvbHM6c3RyaW5nID0gJzAtOWEtekEtWl8kJ1xuICAgICk6c3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudG9TdHJpbmcoKS5yZXBsYWNlKC9eW15hLXpBLVpfJF0rLywgJycpLnJlcGxhY2UoXG4gICAgICAgICAgICBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZFN5bWJvbHN9XSsoW2EtekEtWjAtOV0pYCwgJ2cnKSwgKFxuICAgICAgICAgICAgICAgIGZ1bGxNYXRjaDpzdHJpbmcsIGZpcnN0TGV0dGVyOnN0cmluZ1xuICAgICAgICAgICAgKTpzdHJpbmcgPT4gZmlyc3RMZXR0ZXIudG9VcHBlckNhc2UoKSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGVuY29kaW5nICprZXkqIG9yICp2YWx1ZSogcGFydHMgb2YgcXVlcnlcbiAgICAgKiBjb21wb25lbnQuIFdlIG5lZWQgYSBjdXN0b20gbWV0aG9kIGJlY2F1c2UgXCJlbmNvZGVVUklDb21wb25lbnQoKVwiIGlzIHRvb1xuICAgICAqIGFnZ3Jlc3NpdmUgYW5kIGVuY29kZXMgc3R1ZmYgdGhhdCBkb2Vzbid0IGhhdmUgdG8gYmUgZW5jb2RlZCBwZXJcbiAgICAgKiBcImh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODY6XCIuXG4gICAgICogQHBhcmFtIHVybCAtIFVSTCB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGVuY29kZVNwYWNlcyAtIEluZGljYXRlcyB3aGV0aGVyIGdpdmVuIHVybCBzaG91bGQgZW5jb2RlXG4gICAgICogd2hpdGVzcGFjZXMgYXMgXCIrXCIgb3IgXCIlMjBcIi5cbiAgICAgKiBAcmV0dXJucyBFbmNvZGVkIGdpdmVuIHVybC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nRW5jb2RlVVJJQ29tcG9uZW50KHVybDpzdHJpbmcsIGVuY29kZVNwYWNlczpib29sZWFuKTpzdHJpbmcge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHVybCkucmVwbGFjZSgvJTQwL2dpLCAnQCcpLnJlcGxhY2UoXG4gICAgICAgICAgICAvJTNBL2dpLCAnOidcbiAgICAgICAgKS5yZXBsYWNlKC8lMjQvZywgJyQnKS5yZXBsYWNlKC8lMkMvZ2ksICcsJykucmVwbGFjZShcbiAgICAgICAgICAgIC8lMjAvZywgKGVuY29kZVNwYWNlcykgPyAnJTIwJyA6ICcrJylcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIHBhdGggc2VsZWN0b3IgdG8gdGhlIGdpdmVuIHBhdGggaWYgdGhlcmUgaXNuJ3Qgb25lIHlldC5cbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGZvciBhcHBlbmRpbmcgYSBzZWxlY3Rvci5cbiAgICAgKiBAcGFyYW0gcGF0aFNlcGFyYXRvciAtIFRoZSBzZWxlY3RvciBmb3IgYXBwZW5kaW5nIHRvIHBhdGguXG4gICAgICogQHJldHVybnMgVGhlIGFwcGVuZGVkIHBhdGguXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0FkZFNlcGFyYXRvclRvUGF0aChcbiAgICAgICAgcGF0aDpzdHJpbmcsIHBhdGhTZXBhcmF0b3I6c3RyaW5nID0gJy8nXG4gICAgKTpzdHJpbmcge1xuICAgICAgICBwYXRoID0gcGF0aC50cmltKClcbiAgICAgICAgaWYgKHBhdGguc3Vic3RyKC0xKSAhPT0gcGF0aFNlcGFyYXRvciAmJiBwYXRoLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBwYXRoICsgcGF0aFNlcGFyYXRvclxuICAgICAgICByZXR1cm4gcGF0aFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZ2l2ZW4gcGF0aCBoYXMgZ2l2ZW4gcGF0aCBwcmVmaXguXG4gICAgICogQHBhcmFtIHByZWZpeCAtIFBhdGggcHJlZml4IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIHNlYXJjaCBpbi5cbiAgICAgKiBAcGFyYW0gc2VwYXJhdG9yIC0gRGVsaW1pdGVyIHRvIHVzZSBpbiBwYXRoIChkZWZhdWx0IGlzIHRoZSBwb3NpeFxuICAgICAqIGNvbmZvcm0gc2xhc2gpLlxuICAgICAqIEByZXR1cm5zIFZhbHVlIFwidHJ1ZVwiIGlmIGdpdmVuIHByZWZpeCBvY2N1ciBhbmQgXCJmYWxzZVwiIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nSGFzUGF0aFByZWZpeChcbiAgICAgICAgcHJlZml4Oj9zdHJpbmcgPSAnL2FkbWluJyxcbiAgICAgICAgcGF0aDpzdHJpbmcgPSAoXG4gICAgICAgICAgICAnbG9jYXRpb24nIGluICQuZ2xvYmFsICYmICQuZ2xvYmFsLmxvY2F0aW9uLnBhdGhuYW1lIHx8ICcnKSxcbiAgICAgICAgc2VwYXJhdG9yOnN0cmluZyA9ICcvJ1xuICAgICk6Ym9vbGVhbiB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFwcmVmaXguZW5kc1dpdGgoc2VwYXJhdG9yKSlcbiAgICAgICAgICAgICAgICBwcmVmaXggKz0gc2VwYXJhdG9yXG4gICAgICAgICAgICByZXR1cm4gcGF0aCA9PT0gcHJlZml4LnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAwLCBwcmVmaXgubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aFxuICAgICAgICAgICAgKSB8fCBwYXRoLnN0YXJ0c1dpdGgocHJlZml4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBkb21haW4gbmFtZSBmcm9tIGdpdmVuIHVybC4gSWYgbm8gZXhwbGljaXQgZG9tYWluIG5hbWUgZ2l2ZW5cbiAgICAgKiBjdXJyZW50IGRvbWFpbiBuYW1lIHdpbGwgYmUgYXNzdW1lZC4gSWYgbm8gcGFyYW1ldGVyIGdpdmVuIGN1cnJlbnRcbiAgICAgKiBkb21haW4gbmFtZSB3aWxsIGJlIGRldGVybWluZWQuXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSB1cmwgdG8gZXh0cmFjdCBkb21haW4gZnJvbS5cbiAgICAgKiBAcGFyYW0gZmFsbGJhY2sgLSBUaGUgZmFsbGJhY2sgaG9zdCBuYW1lIGlmIG5vIG9uZSBleGl0cyBpbiBnaXZlbiB1cmxcbiAgICAgKiAoZGVmYXVsdCBpcyBjdXJyZW50IGhvc3RuYW1lKS5cbiAgICAgKiBAcmV0dXJucyBFeHRyYWN0ZWQgZG9tYWluLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdHZXREb21haW5OYW1lKFxuICAgICAgICB1cmw6c3RyaW5nID0gJ2xvY2F0aW9uJyBpbiAkLmdsb2JhbCAmJiAkLmdsb2JhbC5sb2NhdGlvbi5ocmVmIHx8ICcnLFxuICAgICAgICBmYWxsYmFjazphbnkgPSAoXG4gICAgICAgICAgICAnbG9jYXRpb24nIGluICQuZ2xvYmFsICYmICQuZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8ICcnKVxuICAgICk6YW55IHtcbiAgICAgICAgY29uc3QgcmVzdWx0OkFycmF5PD9zdHJpbmc+ID1cbiAgICAgICAgICAgIC9eKFthLXpdKjo/XFwvXFwvKT8oW14vXSs/KSg/OjpbMC05XSspPyg/OlxcLy4qfCQpL2kuZXhlYyh1cmwpXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDIgJiYgcmVzdWx0WzFdICYmIHJlc3VsdFsyXSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMl1cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHBvcnQgbnVtYmVyIGZyb20gZ2l2ZW4gdXJsLiBJZiBubyBleHBsaWNpdCBwb3J0IG51bWJlciBnaXZlblxuICAgICAqIGFuZCBubyBmYWxsYmFjayBpcyBkZWZpbmVkIGN1cnJlbnQgcG9ydCBudW1iZXIgd2lsbCBiZSBhc3N1bWVkIGZvciBsb2NhbFxuICAgICAqIGxpbmtzLiBGb3IgZXh0ZXJuYWwgbGlua3MgODAgd2lsbCBiZSBhc3N1bWVkIGZvciBodHRwIHByb3RvY29sIG9yIDQ0M1xuICAgICAqIGZvciBodHRwcy5cbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIHVybCB0byBleHRyYWN0IHBvcnQgZnJvbS5cbiAgICAgKiBAcGFyYW0gZmFsbGJhY2sgLSBGYWxsYmFjayBwb3J0IG51bWJlciBpZiBubyBleHBsaWNpdCBvbmUgd2FzIGZvdW5kLlxuICAgICAqIERlZmF1bHQgaXMgZGVyaXZlZCBmcm9tIGN1cnJlbnQgcHJvdG9jb2wgbmFtZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXIgZm9yIGNoZWNraW5nIGlmIGdpdmVuIHVybCBpcyBhblxuICAgICAqIGludGVybmFsIHVybC4gR2l2ZW4gdXJsIGFuZCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIGZvcndhcmRlZCB0byB0aGVcbiAgICAgKiBcInN0cmluZ0lzSW50ZXJuYWxVUkwoKVwiIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyBFeHRyYWN0ZWQgcG9ydCBudW1iZXIuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0dldFBvcnROdW1iZXIoXG4gICAgICAgIHVybDpzdHJpbmcgPSAnbG9jYXRpb24nIGluICQuZ2xvYmFsICYmICQuZ2xvYmFsLmxvY2F0aW9uLmhyZWYgfHwgJycsXG4gICAgICAgIGZhbGxiYWNrOmFueSA9IG51bGwsIHBhcmFtZXRlcjpBcnJheTxzdHJpbmc+ID0gW11cbiAgICApOm51bWJlciB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDpBcnJheTw/c3RyaW5nPiA9XG4gICAgICAgICAgICAvXig/OlthLXpdKjo/XFwvXFwvW14vXSs/KT8oPzpbXi9dKz8pOihbMC05XSspL2kuZXhlYyh1cmwpXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0WzFdLCAxMClcbiAgICAgICAgaWYgKGZhbGxiYWNrICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrXG4gICAgICAgIGlmIChUb29scy5zdHJpbmdJc0ludGVybmFsVVJMLmFwcGx5KFxuICAgICAgICAgICAgdGhpcywgW3VybF0uY29uY2F0KHBhcmFtZXRlcilcbiAgICAgICAgICAgICkgJiYgJ2xvY2F0aW9uJyBpbiAkLmdsb2JhbCAmJiAkLmdsb2JhbC5sb2NhdGlvbi5wb3J0ICYmXG4gICAgICAgICAgICBwYXJzZUludCgkLmdsb2JhbC5sb2NhdGlvbi5wb3J0LCAxMClcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KCQuZ2xvYmFsLmxvY2F0aW9uLnBvcnQsIDEwKVxuICAgICAgICByZXR1cm4gKFRvb2xzLnN0cmluZ0dldFByb3RvY29sTmFtZSh1cmwpID09PSAnaHR0cHMnKSA/IDQ0MyA6IDgwXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHByb3RvY29sIG5hbWUgZnJvbSBnaXZlbiB1cmwuIElmIG5vIGV4cGxpY2l0IHVybCBpcyBnaXZlbixcbiAgICAgKiBjdXJyZW50IHByb3RvY29sIHdpbGwgYmUgYXNzdW1lZC4gSWYgbm8gcGFyYW1ldGVyIGdpdmVuIGN1cnJlbnQgcHJvdG9jb2xcbiAgICAgKiBudW1iZXIgd2lsbCBiZSBkZXRlcm1pbmVkLlxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgdXJsIHRvIGV4dHJhY3QgcHJvdG9jb2wgZnJvbS5cbiAgICAgKiBAcGFyYW0gZmFsbGJhY2sgLSBGYWxsYmFjayBwb3J0IHRvIHVzZSBpZiBubyBwcm90b2NvbCBleGlzdHMgaW4gZ2l2ZW5cbiAgICAgKiB1cmwgKGRlZmF1bHQgaXMgY3VycmVudCBwcm90b2NvbCkuXG4gICAgICogcmV0dXJucyBFeHRyYWN0ZWQgcHJvdG9jb2wuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0dldFByb3RvY29sTmFtZShcbiAgICAgICAgdXJsOnN0cmluZyA9ICdsb2NhdGlvbicgaW4gJC5nbG9iYWwgJiYgJC5nbG9iYWwubG9jYXRpb24uaHJlZiB8fCAnJyxcbiAgICAgICAgZmFsbGJhY2s6YW55ID0gJ2xvY2F0aW9uJyBpbiAkLmdsb2JhbCAmJlxuICAgICAgICAgICAgJC5nbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgIDAsICQuZ2xvYmFsLmxvY2F0aW9uLnByb3RvY29sLmxlbmd0aCAtIDEpIHx8ICcnXG4gICAgKTphbnkge1xuICAgICAgICBjb25zdCByZXN1bHQ6QXJyYXk8P3N0cmluZz4gPSAvXihbYS16XSspOlxcL1xcLy9pLmV4ZWModXJsKVxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPiAxICYmIHJlc3VsdFsxXSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMV1cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBwYWdlJ3MgR0VUIFVSTCB2YXJpYWJsZXMgYW5kIHJldHVybiB0aGVtIGFzIGFuIGFzc29jaWF0aXZlIGFycmF5XG4gICAgICogYW5kIHByZXNlcnZlcyBvcmRlcmluZy5cbiAgICAgKiBAcGFyYW0ga2V5VG9HZXQgLSBJZiBrZXkgZ2l2ZW4gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgaXMgcmV0dXJuZWQgYW5kXG4gICAgICogZnVsbCBvYmplY3Qgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSBnaXZlbklucHV0IC0gQW4gYWx0ZXJuYXRpdmUgaW5wdXQgdG8gdGhlIHVybCBzZWFyY2ggcGFyYW1ldGVyLiBJZlxuICAgICAqIFwiI1wiIGlzIGdpdmVuIHRoZSBjb21wbGV0ZSBjdXJyZW50IGhhc2ggdGFnIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgdXJsXG4gICAgICogYW5kIHNlYXJjaCBwYXJhbWV0ZXIgd2lsbCBiZSBleHRyYWN0ZWQgZnJvbSB0aGVyZS4gSWYgXCImXCIgaXMgZ2l2ZW5cbiAgICAgKiBjbGFzc2ljYWwgc2VhcmNoIHBhcmFtZXRlciBhbmQgaGFzaCBwYXJhbWV0ZXIgd2lsbCBiZSB0YWtlbiBpbiBhY2NvdW50LlxuICAgICAqIElmIGEgc2VhcmNoIHN0cmluZyBpcyBnaXZlbiB0aGlzIHdpbGwgYmUgYW5hbHl6ZWQuIFRoZSBkZWZhdWx0IGlzIHRvXG4gICAgICogdGFrZSBnaXZlbiBzZWFyY2ggcGFydCBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIHN1YkRlbGltaXRlciAtIERlZmluZXMgd2hpY2ggc2VxdWVuY2UgaW5kaWNhdGVzIHRoZSBzdGFydCBvZlxuICAgICAqIHBhcmFtZXRlciBpbiBhIGhhc2ggcGFydCBvZiB0aGUgdXJsLlxuICAgICAqIEBwYXJhbSBoYXNoZWRQYXRoSW5kaWNhdG9yIC0gSWYgZGVmaW5lZCBhbmQgZ2l2ZW4gaGFzaCBzdGFydHMgd2l0aCB0aGlzXG4gICAgICogaW5kaWNhdG9yIGdpdmVuIGhhc2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBwYXRoIGNvbnRhaW5pbmcgc2VhcmNoIGFuZFxuICAgICAqIGhhc2ggcGFydHMuXG4gICAgICogQHBhcmFtIGdpdmVuU2VhcmNoIC0gU2VhcmNoIHBhcnQgdG8gdGFrZSBpbnRvIGFjY291bnQgZGVmYXVsdHMgdG9cbiAgICAgKiBjdXJyZW50IHVybCBzZWFyY2ggcGFydC5cbiAgICAgKiBAcGFyYW0gZ2l2ZW5IYXNoIC0gSGFzaCBwYXJ0IHRvIHRha2UgaW50byBhY2NvdW50IGRlZmF1bHRzIHRvIGN1cnJlbnRcbiAgICAgKiB1cmwgaGFzaCBwYXJ0LlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGN1cnJlbnQgZ2V0IGFycmF5IG9yIHJlcXVlc3RlZCB2YWx1ZS4gSWYgcmVxdWVzdGVkXG4gICAgICoga2V5IGRvZXNuJ3QgZXhpc3QgXCJ1bmRlZmluZWRcIiBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nR2V0VVJMVmFyaWFibGUoXG4gICAgICAgIGtleVRvR2V0OnN0cmluZywgZ2l2ZW5JbnB1dDo/c3RyaW5nLCBzdWJEZWxpbWl0ZXI6c3RyaW5nID0gJyQnLFxuICAgICAgICBoYXNoZWRQYXRoSW5kaWNhdG9yOnN0cmluZyA9ICchJywgZ2l2ZW5TZWFyY2g6P3N0cmluZyxcbiAgICAgICAgZ2l2ZW5IYXNoOj9zdHJpbmcgPSAoXG4gICAgICAgICAgICAnbG9jYXRpb24nIGluICQuZ2xvYmFsICYmICQuZ2xvYmFsLmxvY2F0aW9uLmhhc2ggfHwgJycpXG4gICAgKTpBcnJheTxzdHJpbmc+fHN0cmluZyB7XG4gICAgICAgIC8vIHJlZ2lvbiBzZXQgc2VhcmNoIGFuZCBoYXNoXG4gICAgICAgIGxldCBoYXNoOnN0cmluZyA9IChnaXZlbkhhc2gpID8gZ2l2ZW5IYXNoIDogJyMnXG4gICAgICAgIGxldCBzZWFyY2g6c3RyaW5nID0gJydcbiAgICAgICAgaWYgKGdpdmVuU2VhcmNoKVxuICAgICAgICAgICAgc2VhcmNoID0gZ2l2ZW5TZWFyY2hcbiAgICAgICAgZWxzZSBpZiAoaGFzaGVkUGF0aEluZGljYXRvciAmJiBoYXNoLnN0YXJ0c1dpdGgoaGFzaGVkUGF0aEluZGljYXRvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Ykhhc2hTdGFydEluZGV4Om51bWJlciA9IGhhc2guaW5kZXhPZignIycpXG4gICAgICAgICAgICBsZXQgcGF0aEFuZFNlYXJjaDpzdHJpbmdcbiAgICAgICAgICAgIGlmIChzdWJIYXNoU3RhcnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoQW5kU2VhcmNoID0gaGFzaC5zdWJzdHJpbmcoaGFzaGVkUGF0aEluZGljYXRvci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgaGFzaCA9ICcnXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhBbmRTZWFyY2ggPSBoYXNoLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVkUGF0aEluZGljYXRvci5sZW5ndGgsIHN1Ykhhc2hTdGFydEluZGV4KVxuICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoLnN1YnN0cmluZyhzdWJIYXNoU3RhcnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1YlNlYXJjaFN0YXJ0SW5kZXg6bnVtYmVyID0gcGF0aEFuZFNlYXJjaC5pbmRleE9mKCc/JylcbiAgICAgICAgICAgIGlmIChzdWJTZWFyY2hTdGFydEluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBwYXRoQW5kU2VhcmNoLnN1YnN0cmluZyhzdWJTZWFyY2hTdGFydEluZGV4KVxuICAgICAgICB9IGVsc2UgaWYgKCdsb2NhdGlvbicgaW4gJC5nbG9iYWwpXG4gICAgICAgICAgICBzZWFyY2ggPSAkLmdsb2JhbC5sb2NhdGlvbi5zZWFyY2ggfHwgJydcbiAgICAgICAgbGV0IGlucHV0OnN0cmluZyA9IChnaXZlbklucHV0KSA/IGdpdmVuSW5wdXQgOiBzZWFyY2hcbiAgICAgICAgLy8gZW5kcmVnaW9uXG4gICAgICAgIC8vIHJlZ2lvbiBkZXRlcm1pbmUgZGF0YSBmcm9tIHNlYXJjaCBhbmQgaGFzaCBpZiBzcGVjaWZpZWRcbiAgICAgICAgY29uc3QgYm90aDpib29sZWFuID0gaW5wdXQgPT09ICcmJ1xuICAgICAgICBpZiAoYm90aCB8fCBpbnB1dCA9PT0gJyMnKSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZEhhc2g6c3RyaW5nID0gJydcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlZEhhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgICAgICAgY29uc3Qgc3ViRGVsaW1pdGVySW5kZXg6bnVtYmVyID0gZGVjb2RlZEhhc2guaW5kZXhPZihzdWJEZWxpbWl0ZXIpXG4gICAgICAgICAgICBpZiAoc3ViRGVsaW1pdGVySW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgIGlucHV0ID0gJydcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gZGVjb2RlZEhhc2guc3Vic3RyaW5nKHN1YkRlbGltaXRlckluZGV4KVxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKHN1YkRlbGltaXRlcikpXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyaW5nKHN1YkRlbGltaXRlci5sZW5ndGgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuc3RhcnRzV2l0aCgnPycpKVxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHJpbmcoJz8nLmxlbmd0aClcbiAgICAgICAgbGV0IGRhdGE6QXJyYXk8c3RyaW5nPiA9IChpbnB1dCkgPyBpbnB1dC5zcGxpdCgnJicpIDogW11cbiAgICAgICAgc2VhcmNoID0gc2VhcmNoLnN1YnN0cmluZygnPycubGVuZ3RoKVxuICAgICAgICBpZiAoYm90aCAmJiBzZWFyY2gpXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5jb25jYXQoc2VhcmNoLnNwbGl0KCcmJykpXG4gICAgICAgIC8vIGVuZHJlZ2lvblxuICAgICAgICAvLyByZWdpb24gY29uc3RydWN0IGRhdGEgc3RydWN0dXJlXG4gICAgICAgIGNvbnN0IHZhcmlhYmxlczpBcnJheTxzdHJpbmc+ID0gW11cbiAgICAgICAgZm9yIChsZXQgdmFsdWU6c3RyaW5nIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbHVlUGFpcjpBcnJheTxzdHJpbmc+ID0gdmFsdWUuc3BsaXQoJz0nKVxuICAgICAgICAgICAgbGV0IGtleTpzdHJpbmdcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleVZhbHVlUGFpclswXSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5VmFsdWVQYWlyWzFdKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXJpYWJsZXMucHVzaChrZXkpXG4gICAgICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgICAgIHZhcmlhYmxlc1trZXldID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmRyZWdpb25cbiAgICAgICAgaWYgKGtleVRvR2V0KVxuICAgICAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgICAgICByZXR1cm4gdmFyaWFibGVzW2tleVRvR2V0XVxuICAgICAgICByZXR1cm4gdmFyaWFibGVzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiB1cmwgcG9pbnRzIHRvIGFub3RoZXIgZG9tYWluIHRoYW4gc2Vjb25kIGdpdmVuIHVybC4gSWZcbiAgICAgKiBubyBzZWNvbmQgZ2l2ZW4gdXJsIHByb3ZpZGVkIGN1cnJlbnQgdXJsIHdpbGwgYmUgYXNzdW1lZC5cbiAgICAgKiBAcGFyYW0gZmlyc3RVUkwgLSBVUkwgdG8gY2hlY2sgYWdhaW5zdCBzZWNvbmQgdXJsLlxuICAgICAqIEBwYXJhbSBzZWNvbmRVUkwgLSBVUkwgdG8gY2hlY2sgYWdhaW5zdCBmaXJzdCB1cmwuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBcInRydWVcIiBpZiBnaXZlbiBmaXJzdCB1cmwgaGFzIHNhbWUgZG9tYWluIGFzIGdpdmVuXG4gICAgICogc2Vjb25kIChvciBjdXJyZW50KS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nSXNJbnRlcm5hbFVSTChcbiAgICAgICAgZmlyc3RVUkw6c3RyaW5nLCBzZWNvbmRVUkw6c3RyaW5nID0gJ2xvY2F0aW9uJyBpbiAkLmdsb2JhbCAmJlxuICAgICAgICAkLmdsb2JhbC5sb2NhdGlvbi5ocmVmIHx8ICcnXG4gICAgKTpib29sZWFuIHtcbiAgICAgICAgY29uc3QgZXhwbGljaXREb21haW5OYW1lOnN0cmluZyA9IFRvb2xzLnN0cmluZ0dldERvbWFpbk5hbWUoXG4gICAgICAgICAgICBmaXJzdFVSTCwgZmFsc2UpXG4gICAgICAgIGNvbnN0IGV4cGxpY2l0UHJvdG9jb2xOYW1lOnN0cmluZyA9IFRvb2xzLnN0cmluZ0dldFByb3RvY29sTmFtZShcbiAgICAgICAgICAgIGZpcnN0VVJMLCBmYWxzZSlcbiAgICAgICAgY29uc3QgZXhwbGljaXRQb3J0TnVtYmVyID0gVG9vbHMuc3RyaW5nR2V0UG9ydE51bWJlcihmaXJzdFVSTCwgZmFsc2UpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAhZXhwbGljaXREb21haW5OYW1lIHx8XG4gICAgICAgICAgICBleHBsaWNpdERvbWFpbk5hbWUgPT09IFRvb2xzLnN0cmluZ0dldERvbWFpbk5hbWUoc2Vjb25kVVJMKVxuICAgICAgICApICYmIChcbiAgICAgICAgICAgICFleHBsaWNpdFByb3RvY29sTmFtZSB8fFxuICAgICAgICAgICAgZXhwbGljaXRQcm90b2NvbE5hbWUgPT09IFRvb2xzLnN0cmluZ0dldFByb3RvY29sTmFtZShzZWNvbmRVUkwpXG4gICAgICAgICkgJiYgKFxuICAgICAgICAgICAgIWV4cGxpY2l0UG9ydE51bWJlciB8fFxuICAgICAgICAgICAgZXhwbGljaXRQb3J0TnVtYmVyID09PSBUb29scy5zdHJpbmdHZXRQb3J0TnVtYmVyKHNlY29uZFVSTCkpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZWQgZ2l2ZW4gd2Vic2l0ZSB1cmwuXG4gICAgICogQHBhcmFtIHVybCAtIFVuaWZvcm0gcmVzb3VyY2UgbG9jYXRvciB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMgTm9ybWFsaXplZCByZXN1bHQuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ05vcm1hbGl6ZVVSTCh1cmw6P3N0cmluZyk6c3RyaW5nIHtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL146P1xcLysvLCAnJykucmVwbGFjZSgvXFwvKyQvLCAnJykudHJpbSgpXG4gICAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgICAgICByZXR1cm4gYGh0dHA6Ly8ke3VybH1gXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgZ2l2ZW4gd2Vic2l0ZSB1cmwuXG4gICAgICogQHBhcmFtIHVybCAtIFVuaWZvcm0gcmVzb3VyY2UgbG9jYXRvciB0byByZXByZXNlbnQuXG4gICAgICogQHJldHVybnMgUmVwcmVzZW50ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdSZXByZXNlbnRVUkwodXJsOj9zdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiB1cmwucmVwbGFjZSgvXihodHRwcz8pPzo/XFwvKy8sICcnKS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC9cXC8rJC8sICcnXG4gICAgICAgICAgICApLnRyaW0oKVxuICAgICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgLy8gLy8gZW5kcmVnaW9uXG4gICAgLyoqXG4gICAgICogQ29tcHJlc3NlcyBnaXZlbiBzdHlsZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHN0eWxlVmFsdWUgLSBTdHlsZSB2YWx1ZSB0byBjb21wcmVzcy5cbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcHJlc3NlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nQ29tcHJlc3NTdHlsZVZhbHVlKHN0eWxlVmFsdWU6c3RyaW5nKTpzdHJpbmcge1xuICAgICAgICByZXR1cm4gc3R5bGVWYWx1ZS5yZXBsYWNlKC8gKihbOjtdKSAqL2csICckMScpLnJlcGxhY2UoXG4gICAgICAgICAgICAvICsvZywgJyAnXG4gICAgICAgICkucmVwbGFjZSgvXjsrLywgJycpLnJlcGxhY2UoLzsrJC8sICcnKS50cmltKClcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgY2FtZWwgY2FzZWQgc3RyaW5nIHRvIGl0cyBkZWxpbWl0ZWQgc3RyaW5nIHZlcnNpb24uXG4gICAgICogQHBhcmFtIHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBkZWxpbWl0ZXIgLSBEZWxpbWl0ZXIgc3RyaW5nXG4gICAgICogQHBhcmFtIGFiYnJldmlhdGlvbnMgLSBDb2xsZWN0aW9uIG9mIHNob3J0Y3V0IHdvcmRzIHRvIHJlcHJlc2VudCB1cHBlclxuICAgICAqIGNhc2VkLlxuICAgICAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdDYW1lbENhc2VUb0RlbGltaXRlZChcbiAgICAgICAgc3RyaW5nOnN0cmluZywgZGVsaW1pdGVyOnN0cmluZyA9ICctJyxcbiAgICAgICAgYWJicmV2aWF0aW9uczo/QXJyYXk8c3RyaW5nPiA9IG51bGxcbiAgICApOnN0cmluZyB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBqc2RvYy9yZXF1aXJlLWRlc2NyaXB0aW9uLWNvbXBsZXRlLXNlbnRlbmNlICovXG4gICAgICAgIGlmICghYWJicmV2aWF0aW9ucylcbiAgICAgICAgICAgIGFiYnJldmlhdGlvbnMgPSBUb29scy5hYmJyZXZpYXRpb25zXG4gICAgICAgIGNvbnN0IGVzY2FwZWREZWxpbWl0ZXI6c3RyaW5nID1cbiAgICAgICAgICAgIFRvb2xzLnN0cmluZ0dldFJlZ3VsYXJFeHByZXNzaW9uVmFsaWRhdGVkKGRlbGltaXRlcilcbiAgICAgICAgaWYgKGFiYnJldmlhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgYWJicmV2aWF0aW9uUGF0dGVybjpzdHJpbmcgPSAnJ1xuICAgICAgICAgICAgZm9yIChjb25zdCBhYmJyZXZpYXRpb246c3RyaW5nIG9mIGFiYnJldmlhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJicmV2aWF0aW9uUGF0dGVybilcbiAgICAgICAgICAgICAgICAgICAgYWJicmV2aWF0aW9uUGF0dGVybiArPSAnfCdcbiAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb25QYXR0ZXJuICs9IGFiYnJldmlhdGlvbi50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgIGAoJHthYmJyZXZpYXRpb25QYXR0ZXJufSkoJHthYmJyZXZpYXRpb25QYXR0ZXJufSlgLCAnZydcbiAgICAgICAgICAgICksIGAkMSR7ZGVsaW1pdGVyfSQyYClcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKFxuICAgICAgICAgICAgYChbXiR7ZXNjYXBlZERlbGltaXRlcn1dKShbQS1aXVthLXpdKylgLCAnZydcbiAgICAgICAgKSwgYCQxJHtkZWxpbWl0ZXJ9JDJgKVxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoXG4gICAgICAgICAgICBuZXcgUmVnRXhwKCcoW2EtejAtOV0pKFtBLVpdKScsICdnJyksIGAkMSR7ZGVsaW1pdGVyfSQyYFxuICAgICAgICApLnRvTG93ZXJDYXNlKClcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGl0cyBjYXBpdGFsaXplIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nQ2FwaXRhbGl6ZShzdHJpbmc6c3RyaW5nKTpzdHJpbmcge1xuICAgIC8qIGVzbGludC1lbmFibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cmluZygxKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRlbGltaXRlZCBzdHJpbmcgdG8gaXRzIGNhbWVsIGNhc2UgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBkZWxpbWl0ZXIgLSBEZWxpbWl0ZXIgc3RyaW5nIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gYWJicmV2aWF0aW9ucyAtIENvbGxlY3Rpb24gb2Ygc2hvcnRjdXQgd29yZHMgdG8gcmVwcmVzZW50IHVwcGVyXG4gICAgICogY2FzZWQuXG4gICAgICogQHBhcmFtIHByZXNlcnZlV3JvbmdGb3JtYXR0ZWRBYmJyZXZpYXRpb25zIC0gSWYgc2V0IHRvIFwiVHJ1ZVwiIHdyb25nXG4gICAgICogZm9ybWF0dGVkIGNhbWVsIGNhc2UgYWJicmV2aWF0aW9ucyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIHJlbW92ZU11bHRpcGxlRGVsaW1pdGVyIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzZXJpZXMgb2YgZGVsaW1pdGVyXG4gICAgICogc2hvdWxkIGJlIGNvbnNvbGlkYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nRGVsaW1pdGVkVG9DYW1lbENhc2UoXG4gICAgICAgIHN0cmluZzpzdHJpbmcsIGRlbGltaXRlcjpzdHJpbmcgPSAnLScsXG4gICAgICAgIGFiYnJldmlhdGlvbnM6P0FycmF5PHN0cmluZz4gPSBudWxsLFxuICAgICAgICBwcmVzZXJ2ZVdyb25nRm9ybWF0dGVkQWJicmV2aWF0aW9uczpib29sZWFuID0gZmFsc2UsXG4gICAgICAgIHJlbW92ZU11bHRpcGxlRGVsaW1pdGVyOmJvb2xlYW4gPSBmYWxzZVxuICAgICk6c3RyaW5nIHtcbiAgICAgICAgbGV0IGVzY2FwZWREZWxpbWl0ZXI6c3RyaW5nID1cbiAgICAgICAgICAgIFRvb2xzLnN0cmluZ0dldFJlZ3VsYXJFeHByZXNzaW9uVmFsaWRhdGVkKGRlbGltaXRlcilcbiAgICAgICAgaWYgKCFhYmJyZXZpYXRpb25zKVxuICAgICAgICAgICAgYWJicmV2aWF0aW9ucyA9IFRvb2xzLmFiYnJldmlhdGlvbnNcbiAgICAgICAgbGV0IGFiYnJldmlhdGlvblBhdHRlcm46c3RyaW5nXG4gICAgICAgIGlmIChwcmVzZXJ2ZVdyb25nRm9ybWF0dGVkQWJicmV2aWF0aW9ucylcbiAgICAgICAgICAgIGFiYnJldmlhdGlvblBhdHRlcm4gPSBhYmJyZXZpYXRpb25zLmpvaW4oJ3wnKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFiYnJldmlhdGlvblBhdHRlcm4gPSAnJ1xuICAgICAgICAgICAgZm9yIChjb25zdCBhYmJyZXZpYXRpb246c3RyaW5nIG9mIGFiYnJldmlhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJicmV2aWF0aW9uUGF0dGVybilcbiAgICAgICAgICAgICAgICAgICAgYWJicmV2aWF0aW9uUGF0dGVybiArPSAnfCdcbiAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb25QYXR0ZXJuICs9XG4gICAgICAgICAgICAgICAgICAgIGAke1Rvb2xzLnN0cmluZ0NhcGl0YWxpemUoYWJicmV2aWF0aW9uKX18JHthYmJyZXZpYXRpb259YFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJpbmdTdGFydHNXaXRoRGVsaW1pdGVyOmJvb2xlYW4gPSBmYWxzZVxuICAgICAgICBpZiAoc3RyaW5nLnN0YXJ0c1dpdGgoZGVsaW1pdGVyKSkge1xuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZyhkZWxpbWl0ZXIubGVuZ3RoKVxuICAgICAgICAgICAgc3RyaW5nU3RhcnRzV2l0aERlbGltaXRlciA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKFxuICAgICAgICAgICAgYCgke2VzY2FwZWREZWxpbWl0ZXJ9KSgke2FiYnJldmlhdGlvblBhdHRlcm59KWAgK1xuICAgICAgICAgICAgYCgke2VzY2FwZWREZWxpbWl0ZXJ9fCQpYCwgJ2cnXG4gICAgICAgICksIChcbiAgICAgICAgICAgIGZ1bGxNYXRjaDpzdHJpbmcsIGJlZm9yZTpzdHJpbmcsIGFiYnJldmlhdGlvbjpzdHJpbmcsIGFmdGVyOnN0cmluZ1xuICAgICAgICApOnN0cmluZyA9PiBiZWZvcmUgKyBhYmJyZXZpYXRpb24udG9VcHBlckNhc2UoKSArIGFmdGVyKVxuICAgICAgICBpZiAocmVtb3ZlTXVsdGlwbGVEZWxpbWl0ZXIpXG4gICAgICAgICAgICBlc2NhcGVkRGVsaW1pdGVyID0gYCg/OiR7ZXNjYXBlZERlbGltaXRlcn0pK2BcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChcbiAgICAgICAgICAgIGAke2VzY2FwZWREZWxpbWl0ZXJ9KFthLXpBLVowLTldKWAsICdnJ1xuICAgICAgICApLCAoZnVsbE1hdGNoOnN0cmluZywgZmlyc3RMZXR0ZXI6c3RyaW5nKTpzdHJpbmcgPT5cbiAgICAgICAgICAgIGZpcnN0TGV0dGVyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgIGlmIChzdHJpbmdTdGFydHNXaXRoRGVsaW1pdGVyKVxuICAgICAgICAgICAgc3RyaW5nID0gZGVsaW1pdGVyICsgc3RyaW5nXG4gICAgICAgIHJldHVybiBzdHJpbmdcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBzdHJpbmcgZm9ybWF0aW9uLiBSZXBsYWNlcyBldmVyeSBwbGFjZWhvbGRlciBcIntpfVwiIHdpdGggdGhlXG4gICAgICogaSd0aCBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0gc3RyaW5nIC0gVGhlIHN0cmluZyB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxBcmd1bWVudHMgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXNcbiAgICAgKiByZXBsYWNlbWVudHMgZm9yIHN0cmluZyBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0Zvcm1hdChcbiAgICAgICAgc3RyaW5nOnN0cmluZywgLi4uYWRkaXRpb25hbEFyZ3VtZW50czpBcnJheTxhbnk+XG4gICAgKTpzdHJpbmcge1xuICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzLnVuc2hpZnQoc3RyaW5nKVxuICAgICAgICBsZXQgaW5kZXg6bnVtYmVyID0gMFxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlOnN0cmluZ3xudW1iZXIgb2YgYWRkaXRpb25hbEFyZ3VtZW50cykge1xuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChgXFxcXHske2luZGV4fVxcXFx9YCwgJ2dtJyksIGAke3ZhbHVlfWApXG4gICAgICAgICAgICBpbmRleCArPSAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGN1cnJlbnQgc3RyaW5nIGZvciB1c2luZyBpbiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuLlxuICAgICAqIFNwZWNpYWwgcmVndWxhciBleHByZXNzaW9uIGNoYXJzIHdpbGwgYmUgZXNjYXBlZC5cbiAgICAgKiBAcGFyYW0gc3RyaW5nIC0gVGhlIHN0cmluZyB0byBmb3JtYXQuXG4gICAgICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0dldFJlZ3VsYXJFeHByZXNzaW9uVmFsaWRhdGVkKHN0cmluZzpzdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtcXFxcfC4qJF4rW1xcXSgpP1xcLXt9XSkvZywgJ1xcXFwkMScpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGl0cyBsb3dlciBjYXNlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nTG93ZXJDYXNlKHN0cmluZzpzdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyaW5nKDEpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBzIGdpdmVuIG1hcmsgc3RyaW5ncyBpbiBnaXZlbiB0YXJnZXQgd2l0aCBnaXZlbiBtYXJrZXIuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFN0cmluZyB0byBzZWFyY2ggZm9yIG1hcmtlci5cbiAgICAgKiBAcGFyYW0gbWFyayAtIFN0cmluZyB0byBzZWFyY2ggaW4gdGFyZ2V0IGZvci5cbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gSFRNTCB0ZW1wbGF0ZSBzdHJpbmcgdG8gbWFyay5cbiAgICAgKiBAcGFyYW0gY2FzZVNlbnNpdGl2ZSAtIEluZGljYXRlcyB3aGV0aGVyIGNhc2UgdGFrZXMgYSByb2xlIGR1cmluZ1xuICAgICAqIHNlYXJjaGluZy5cbiAgICAgKiBAcmV0dXJucyBQcm9jZXNzZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdNYXJrKFxuICAgICAgICB0YXJnZXQ6P3N0cmluZywgbWFyazo/c3RyaW5nLFxuICAgICAgICBtYXJrZXI6c3RyaW5nID0gJzxzcGFuIGNsYXNzPVwidG9vbHMtbWFya1wiPnsxfTwvc3Bhbj4nLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlOmJvb2xlYW4gPSBmYWxzZVxuICAgICk6P3N0cmluZyB7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgbWFyaykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnRyaW0oKVxuICAgICAgICAgICAgbWFyayA9IG1hcmsudHJpbSgpXG4gICAgICAgICAgICBsZXQgb2Zmc2V0Om51bWJlciA9IDBcbiAgICAgICAgICAgIGxldCBzZWFyY2hUYXJnZXQ6c3RyaW5nID0gdGFyZ2V0XG4gICAgICAgICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpXG4gICAgICAgICAgICAgICAgc2VhcmNoVGFyZ2V0ID0gc2VhcmNoVGFyZ2V0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICBtYXJrID0gbWFyay50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4Om51bWJlciA9IHNlYXJjaFRhcmdldC5pbmRleE9mKG1hcmssIG9mZnNldClcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuc3Vic3RyaW5nKDAsIGluZGV4KSArIFRvb2xzLnN0cmluZ0Zvcm1hdChcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlciwgdGFyZ2V0LnN1YnN0cihpbmRleCwgbWFyay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICkgKyB0YXJnZXQuc3Vic3RyaW5nKGluZGV4ICsgbWFyay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRhcmdldCA9IHRhcmdldC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGluZGV4ICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLmxlbmd0aCAtICd7MX0nLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICApICsgbWFyay5sZW5ndGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBtZDUgaGFzaCBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2FsY3VsYXRlIG1kNSBoYXNoIGZvci5cbiAgICAgKiBAcGFyYW0gb25seUFzY2lpIC0gU2V0IHRvIHRydWUgaWYgZ2l2ZW4gaW5wdXQgaGFzIGFzY2lpIGNoYXJhY3RlcnMgb25seVxuICAgICAqIHRvIGdldCBtb3JlIHBlcmZvcm1hbmNlLlxuICAgICAqIEByZXR1cm5zIENhbGN1bGF0ZWQgbWQ1IGhhc2ggdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ01ENSh2YWx1ZTpzdHJpbmcsIG9ubHlBc2NpaTpib29sZWFuID0gZmFsc2UpOnN0cmluZyB7XG4gICAgICAgIGNvbnN0IGhleENoYXJhY3RlcnM6QXJyYXk8c3RyaW5nPiA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJylcbiAgICAgICAgLy8gcmVnaW9uIHN1YiBoZWxwZXJcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbXVjaCBmYXN0ZXIsIHNvIGlmIHBvc3NpYmxlIHdlIHVzZSBpdC4gU29tZSBJRXNcbiAgICAgICAgICogYXJlIHRoZSBvbmx5IG9uZXMgSSBrbm93IG9mIHRoYXQgbmVlZCB0aGUgaWRpb3RpYyBzZWNvbmQgZnVuY3Rpb24sXG4gICAgICAgICAqIGdlbmVyYXRlZCBieSBhbiBpZiBjbGF1c2UgaW4gdGhlIGVuZC5cbiAgICAgICAgICogQHBhcmFtIGZpcnN0IC0gRmlyc3Qgb3BlcmFuZCB0byBhZGQuXG4gICAgICAgICAqIEBwYXJhbSBzZWNvbmQgLSBTZWNvbmQgb3BlcmFudCB0byBhZGQuXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBzdW0gb2YgYm90aCBnaXZlbiBvcGVyYW5kcy5cbiAgICAgICAgKi9cbiAgICAgICAgbGV0IHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uID0gKFxuICAgICAgICAgICAgZmlyc3Q6bnVtYmVyLCBzZWNvbmQ6bnVtYmVyXG4gICAgICAgICk6bnVtYmVyID0+IChmaXJzdCArIHNlY29uZCkgJiAweEZGRkZGRkZGXG4gICAgICAgIC8vIC8gcmVnaW9uIHByaW1hcnkgZnVuY3Rpb25zIG5lZWRlZCBmb3IgdGhlIGFsZ29yaXRobVxuICAgICAgICAvKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIHRoZSBiYXNpYyBvcGVyYXRpb24gZm9yIGVhY2ggcm91bmQgb2YgdGhlIGFsZ29yaXRobS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNtbiA9IChcbiAgICAgICAgICAgIHE6bnVtYmVyLCBhOm51bWJlciwgYjpudW1iZXIsIHg6bnVtYmVyLCBzOm51bWJlciwgdDpudW1iZXJcbiAgICAgICAgKTpudW1iZXIgPT4ge1xuICAgICAgICAgICAgYSA9IHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uKFxuICAgICAgICAgICAgICAgIHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uKGEsIHEpLFxuICAgICAgICAgICAgICAgIHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uKHgsIHQpKVxuICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uKFxuICAgICAgICAgICAgICAgIChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYilcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyc3QgYWxnb3JpdGhtIHBhcnQuXG4gICAgICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIGIgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gYyAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBkIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIHggLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gcyAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSB0IC0gT3BlcmFuZC5cbiAgICAgICAgICogQHJldHVybnMgUmVzdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZmYgPSAoXG4gICAgICAgICAgICBhOm51bWJlciwgYjpudW1iZXIsIGM6bnVtYmVyLCBkOm51bWJlciwgeDpudW1iZXIsIHM6bnVtYmVyLFxuICAgICAgICAgICAgdDpudW1iZXJcbiAgICAgICAgKTpudW1iZXIgPT4gY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KVxuICAgICAgICAvKipcbiAgICAgICAgICogU2Vjb25kIGFsZ29yaXRobSBwYXJ0LlxuICAgICAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIGMgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gZCAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSB4IC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIHMgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gdCAtIE9wZXJhbmQuXG4gICAgICAgICAqIEByZXR1cm5zIFJlc3VsdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGdnID0gKFxuICAgICAgICAgICAgYTpudW1iZXIsIGI6bnVtYmVyLCBjOm51bWJlciwgZDpudW1iZXIsIHg6bnVtYmVyLCBzOm51bWJlcixcbiAgICAgICAgICAgIHQ6bnVtYmVyXG4gICAgICAgICk6bnVtYmVyID0+IGNtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdClcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXJkIGFsZ29yaXRobSBwYXJ0LlxuICAgICAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIGMgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gZCAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSB4IC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIHMgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gdCAtIE9wZXJhbmQuXG4gICAgICAgICAqIEByZXR1cm5zIFJlc3VsdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhoID0gKFxuICAgICAgICAgICAgYTpudW1iZXIsIGI6bnVtYmVyLCBjOm51bWJlciwgZDpudW1iZXIsIHg6bnVtYmVyLCBzOm51bWJlcixcbiAgICAgICAgICAgIHQ6bnVtYmVyXG4gICAgICAgICk6bnVtYmVyID0+IGNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3VydGggYWxnb3JpdGhtIHBhcnQuXG4gICAgICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIGIgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gYyAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBkIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIHggLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gcyAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSB0IC0gT3BlcmFuZC5cbiAgICAgICAgICogQHJldHVybnMgUmVzdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaWkgPSAoXG4gICAgICAgICAgICBhOm51bWJlciwgYjpudW1iZXIsIGM6bnVtYmVyLCBkOm51bWJlciwgeDpudW1iZXIsIHM6bnVtYmVyLFxuICAgICAgICAgICAgdDpudW1iZXJcbiAgICAgICAgKTpudW1iZXIgPT4gY21uKGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KVxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYWxsIDE2IG5lZWRlZCBzdGVwcy5cbiAgICAgICAgICogQHBhcmFtIHN0YXRlIC0gQ3VycmVudCBzdGF0ZS5cbiAgICAgICAgICogQHBhcmFtIGJsb2NrcyAtIEJsb2NrcyB0byBjeWNsZSB0aHJvdWdoLlxuICAgICAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY3ljbGUgPSAoc3RhdGU6QXJyYXk8YW55PiwgYmxvY2tzOkFycmF5PGFueT4pOkFycmF5PGFueT4gPT4ge1xuICAgICAgICAgICAgbGV0IGE6YW55ID0gc3RhdGVbMF1cbiAgICAgICAgICAgIGxldCBiOmFueSA9IHN0YXRlWzFdXG4gICAgICAgICAgICBsZXQgYzphbnkgPSBzdGF0ZVsyXVxuICAgICAgICAgICAgbGV0IGQ6YW55ID0gc3RhdGVbM11cbiAgICAgICAgICAgIC8vIHJlZ2lvbiByb3VuZCAxXG4gICAgICAgICAgICBhID0gZmYoYSwgYiwgYywgZCwgYmxvY2tzWzBdLCA3LCAtNjgwODc2OTM2KVxuICAgICAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJsb2Nrc1sxXSwgMTIsIC0zODk1NjQ1ODYpXG4gICAgICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwgYmxvY2tzWzJdLCAxNywgNjA2MTA1ODE5KVxuICAgICAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJsb2Nrc1szXSwgMjIsIC0xMDQ0NTI1MzMwKVxuXG4gICAgICAgICAgICBhID0gZmYoYSwgYiwgYywgZCwgYmxvY2tzWzRdLCA3LCAtMTc2NDE4ODk3KVxuICAgICAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJsb2Nrc1s1XSwgMTIsIDEyMDAwODA0MjYpXG4gICAgICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwgYmxvY2tzWzZdLCAxNywgLTE0NzMyMzEzNDEpXG4gICAgICAgICAgICBiID0gZmYoYiwgYywgZCwgYSwgYmxvY2tzWzddLCAyMiwgLTQ1NzA1OTgzKVxuXG4gICAgICAgICAgICBhID0gZmYoYSwgYiwgYywgZCwgYmxvY2tzWzhdLCA3LCAxNzcwMDM1NDE2KVxuICAgICAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJsb2Nrc1s5XSwgMTIsIC0xOTU4NDE0NDE3KVxuICAgICAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJsb2Nrc1sxMF0sIDE3LCAtNDIwNjMpXG4gICAgICAgICAgICBiID0gZmYoYiwgYywgZCwgYSwgYmxvY2tzWzExXSwgMjIsIC0xOTkwNDA0MTYyKVxuXG4gICAgICAgICAgICBhID0gZmYoYSwgYiwgYywgZCwgYmxvY2tzWzEyXSwgNywgMTgwNDYwMzY4MilcbiAgICAgICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBibG9ja3NbMTNdLCAxMiwgLTQwMzQxMTAxKVxuICAgICAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJsb2Nrc1sxNF0sIDE3LCAtMTUwMjAwMjI5MClcbiAgICAgICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBibG9ja3NbMTVdLCAyMiwgMTIzNjUzNTMyOSlcbiAgICAgICAgICAgIC8vIGVuZHJlZ2lvblxuICAgICAgICAgICAgLy8gcmVnaW9uIHJvdW5kIDJcbiAgICAgICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBibG9ja3NbMV0sIDUsIC0xNjU3OTY1MTApXG4gICAgICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywgYmxvY2tzWzZdLCA5LCAtMTA2OTUwMTYzMilcbiAgICAgICAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBibG9ja3NbMTFdLCAxNCwgNjQzNzE3NzEzKVxuICAgICAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJsb2Nrc1swXSwgMjAsIC0zNzM4OTczMDIpXG5cbiAgICAgICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBibG9ja3NbNV0sIDUsIC03MDE1NTg2OTEpXG4gICAgICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywgYmxvY2tzWzEwXSwgOSwgMzgwMTYwODMpXG4gICAgICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwgYmxvY2tzWzE1XSwgMTQsIC02NjA0NzgzMzUpXG4gICAgICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwgYmxvY2tzWzRdLCAyMCwgLTQwNTUzNzg0OClcblxuICAgICAgICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJsb2Nrc1s5XSwgNSwgNTY4NDQ2NDM4KVxuICAgICAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJsb2Nrc1sxNF0sIDksIC0xMDE5ODAzNjkwKVxuICAgICAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJsb2Nrc1szXSwgMTQsIC0xODczNjM5NjEpXG4gICAgICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwgYmxvY2tzWzhdLCAyMCwgMTE2MzUzMTUwMSlcblxuICAgICAgICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJsb2Nrc1sxM10sIDUsIC0xNDQ0NjgxNDY3KVxuICAgICAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJsb2Nrc1syXSwgOSwgLTUxNDAzNzg0KVxuICAgICAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJsb2Nrc1s3XSwgMTQsIDE3MzUzMjg0NzMpXG4gICAgICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwgYmxvY2tzWzEyXSwgMjAsIC0xOTI2NjA3NzM0KVxuICAgICAgICAgICAgLy8gZW5kcmVnaW9uXG4gICAgICAgICAgICAvLyByZWdpb24gcm91bmQgM1xuICAgICAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJsb2Nrc1s1XSwgNCwgLTM3ODU1OClcbiAgICAgICAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBibG9ja3NbOF0sIDExLCAtMjAyMjU3NDQ2MylcbiAgICAgICAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBibG9ja3NbMTFdLCAxNiwgMTgzOTAzMDU2MilcbiAgICAgICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBibG9ja3NbMTRdLCAyMywgLTM1MzA5NTU2KVxuXG4gICAgICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwgYmxvY2tzWzFdLCA0LCAtMTUzMDk5MjA2MClcbiAgICAgICAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBibG9ja3NbNF0sIDExLCAxMjcyODkzMzUzKVxuICAgICAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJsb2Nrc1s3XSwgMTYsIC0xNTU0OTc2MzIpXG4gICAgICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwgYmxvY2tzWzEwXSwgMjMsIC0xMDk0NzMwNjQwKVxuXG4gICAgICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwgYmxvY2tzWzEzXSwgNCwgNjgxMjc5MTc0KVxuICAgICAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJsb2Nrc1swXSwgMTEsIC0zNTg1MzcyMjIpXG4gICAgICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwgYmxvY2tzWzNdLCAxNiwgLTcyMjUyMTk3OSlcbiAgICAgICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBibG9ja3NbNl0sIDIzLCA3NjAyOTE4OSlcblxuICAgICAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJsb2Nrc1s5XSwgNCwgLTY0MDM2NDQ4NylcbiAgICAgICAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBibG9ja3NbMTJdLCAxMSwgLTQyMTgxNTgzNSlcbiAgICAgICAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBibG9ja3NbMTVdLCAxNiwgNTMwNzQyNTIwKVxuICAgICAgICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJsb2Nrc1syXSwgMjMsIC05OTUzMzg2NTEpXG4gICAgICAgICAgICAvLyBlbmRyZWdpb25cbiAgICAgICAgICAgIC8vIHJlZ2lvbiByb3VuZCA0XG4gICAgICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwgYmxvY2tzWzBdLCA2LCAtMTk4NjMwODQ0KVxuICAgICAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJsb2Nrc1s3XSwgMTAsIDExMjY4OTE0MTUpXG4gICAgICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwgYmxvY2tzWzE0XSwgMTUsIC0xNDE2MzU0OTA1KVxuICAgICAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJsb2Nrc1s1XSwgMjEsIC01NzQzNDA1NSlcblxuICAgICAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJsb2Nrc1sxMl0sIDYsIDE3MDA0ODU1NzEpXG4gICAgICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywgYmxvY2tzWzNdLCAxMCwgLTE4OTQ5ODY2MDYpXG4gICAgICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwgYmxvY2tzWzEwXSwgMTUsIC0xMDUxNTIzKVxuICAgICAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJsb2Nrc1sxXSwgMjEsIC0yMDU0OTIyNzk5KVxuXG4gICAgICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwgYmxvY2tzWzhdLCA2LCAxODczMzEzMzU5KVxuICAgICAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJsb2Nrc1sxNV0sIDEwLCAtMzA2MTE3NDQpXG4gICAgICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwgYmxvY2tzWzZdLCAxNSwgLTE1NjAxOTgzODApXG4gICAgICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwgYmxvY2tzWzEzXSwgMjEsIDEzMDkxNTE2NDkpXG5cbiAgICAgICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBibG9ja3NbNF0sIDYsIC0xNDU1MjMwNzApXG4gICAgICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywgYmxvY2tzWzExXSwgMTAsIC0xMTIwMjEwMzc5KVxuICAgICAgICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJsb2Nrc1syXSwgMTUsIDcxODc4NzI1OSlcbiAgICAgICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBibG9ja3NbOV0sIDIxLCAtMzQzNDg1NTUxKVxuICAgICAgICAgICAgLy8gZW5kcmVnaW9uXG4gICAgICAgICAgICBzdGF0ZVswXSA9IHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uKGEsIHN0YXRlWzBdKVxuICAgICAgICAgICAgc3RhdGVbMV0gPSB1bnNpZ25lZE1vZHVsZTJQb3dlck9mMzJBZGRpdGlvbihiLCBzdGF0ZVsxXSlcbiAgICAgICAgICAgIHN0YXRlWzJdID0gdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24oYywgc3RhdGVbMl0pXG4gICAgICAgICAgICBzdGF0ZVszXSA9IHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uKGQsIHN0YXRlWzNdKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cbiAgICAgICAgLy8gLyBlbmRyZWdpb25cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGdpdmVuIGNoYXJhY3RlciB0byBpdHMgY29ycmVzcG9uZGluZyBoZXggY29kZVxuICAgICAgICAgKiByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIGNoYXJhY3RlciAtIENoYXJhY3RlciB0byBjb252ZXJ0LlxuICAgICAgICAgKiBAcmV0dXJucyBDb252ZXJ0ZWQgaGV4IGNvZGUgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY29udmVydENoYXJhY3RvclRvSGV4Q29kZSA9IChjaGFyYWN0ZXI6YW55KTpzdHJpbmcgPT4ge1xuICAgICAgICAgICAgbGV0IGhleFN0cmluZzpzdHJpbmcgPSAnJ1xuICAgICAgICAgICAgZm9yIChsZXQgcm91bmQ6bnVtYmVyID0gMDsgcm91bmQgPCA0OyByb3VuZCsrKVxuICAgICAgICAgICAgICAgIGhleFN0cmluZyArPSBoZXhDaGFyYWN0ZXJzWyhjaGFyYWN0ZXIgPj4gKFxuICAgICAgICAgICAgICAgICAgICByb3VuZCAqIDggKyA0XG4gICAgICAgICAgICAgICAgKSkgJiAweDBGXSArIGhleENoYXJhY3RlcnNbKGNoYXJhY3RlciA+PiAocm91bmQgKiA4KSkgJiAweDBGXVxuICAgICAgICAgICAgcmV0dXJuIGhleFN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBnaXZlbiBieXRlIGFycmF5IHRvIGl0cyBjb3JyZXNwb25kaW5nIGhleCBjb2RlIGFzIHN0cmluZy5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gQXJyYXkgb2YgY2hhcmFjdGVycyB0byBjb252ZXJ0LlxuICAgICAgICAgKiBAcmV0dXJucyBDb252ZXJ0ZWQgaGV4IGNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb252ZXJ0VG9IZXhDb2RlID0gKHZhbHVlOkFycmF5PGFueT4pOnN0cmluZyA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleDpudW1iZXIgPSAwOyBpbmRleCA8IHZhbHVlLmxlbmd0aDsgaW5kZXgrKylcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBjb252ZXJ0Q2hhcmFjdG9yVG9IZXhDb2RlKHZhbHVlW2luZGV4XSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5qb2luKCcnKVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVyZSBuZWVkcyB0byBiZSBzdXBwb3J0IGZvciB1bmljb2RlIGhlcmUsIHVubGVzcyB3ZSBwcmV0ZW5kIHRoYXRcbiAgICAgICAgICogd2UgY2FuIHJlZGVmaW5lIHRoZSBtZDUgYWxnb3JpdGhtIGZvciBtdWx0aS1ieXRlIGNoYXJhY3RlcnNcbiAgICAgICAgICogKHBlcmhhcHMgYnkgYWRkaW5nIGV2ZXJ5IGZvdXIgMTYtYml0IGNoYXJhY3RlcnMgYW5kIHNob3J0ZW5pbmcgdGhlXG4gICAgICAgICAqIHN1bSB0byAzMiBiaXRzKS4gT3RoZXJ3aXNlIEkgc3VnZ2VzdCBwZXJmb3JtaW5nIG1kNSBhcyBpZiBldmVyeVxuICAgICAgICAgKiBjaGFyYWN0ZXIgd2FzIHR3byBieXRlcy0tZS5nLiwgMDA0MCAwMDI1ID0gQCUtLWJ1dCB0aGVuIGhvdyB3aWxsIGFuXG4gICAgICAgICAqIG9yZGluYXJ5IG1kNSBzdW0gYmUgbWF0Y2hlZD8gVGhlcmUgaXMgbm8gd2F5IHRvIHN0YW5kYXJkaXplIHRleHRcbiAgICAgICAgICogdG8gc29tZXRoaW5nIGxpa2UgdXRmLTggYmVmb3JlIHRyYW5zZm9ybWF0aW9uOyBzcGVlZCBjb3N0IGlzXG4gICAgICAgICAqIHV0dGVybHkgcHJvaGliaXRpdmUuIFRoZSBKYXZhU2NyaXB0IHN0YW5kYXJkIGl0c2VsZiBuZWVkcyB0byBsb29rXG4gICAgICAgICAqIGF0IHRoaXM6IGl0IHNob3VsZCBzdGFydCBwcm92aWRpbmcgYWNjZXNzIHRvIHN0cmluZ3MgYXMgcHJlZm9ybWVkXG4gICAgICAgICAqIHV0Zi04IDgtYml0IHVuc2lnbmVkIHZhbHVlIGFycmF5cy5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gcHJvY2VzcyB3aXRoIGVhY2ggYmxvY2suXG4gICAgICAgICAqIEByZXR1cm5zIENvbnZlcnRlZCBieXRlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaGFuZGxlQmxvY2sgPSAodmFsdWU6c3RyaW5nKTpBcnJheTxhbnk+ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrczpBcnJheTxhbnk+ID0gW11cbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyOm51bWJlciA9IDA7IGJsb2NrTnVtYmVyIDwgNjQ7IGJsb2NrTnVtYmVyICs9IDRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBibG9ja3NbYmxvY2tOdW1iZXIgPj4gMl0gPSB2YWx1ZS5jaGFyQ29kZUF0KGJsb2NrTnVtYmVyKSArIChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2hhckNvZGVBdChibG9ja051bWJlciArIDEpIDw8IDhcbiAgICAgICAgICAgICAgICApICsgKHZhbHVlLmNoYXJDb2RlQXQoYmxvY2tOdW1iZXIgKyAyKSA8PCAxNikgKyAoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmNoYXJDb2RlQXQoYmxvY2tOdW1iZXIgKyAzKSA8PCAyNClcbiAgICAgICAgICAgIHJldHVybiBibG9ja3NcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmRyZWdpb25cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXJzIHRoZSBtYWluIGFsZ29yaXRobSB0byBjYWxjdWxhdGUgdGhlIG1kNSByZXByZXNlbnRhdGlvbiBvZlxuICAgICAgICAgKiBnaXZlbiB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHRvIGNvbnZlcnQgdG8gaXRzIG1kNSByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICogQHJldHVybnMgQXJyYXkgb2YgYmxvY2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgbWFpbiA9ICh2YWx1ZTpzdHJpbmcpOkFycmF5PGFueT4gPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoOm51bWJlciA9IHZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgY29uc3Qgc3RhdGU6QXJyYXk8YW55PiA9IFtcbiAgICAgICAgICAgICAgICAxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XVxuICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyOm51bWJlclxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IDY0OyBibG9ja051bWJlciA8PSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gNjRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBjeWNsZShzdGF0ZSwgaGFuZGxlQmxvY2sodmFsdWUuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciAtIDY0LCBibG9ja051bWJlcikpKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoYmxvY2tOdW1iZXIgLSA2NClcbiAgICAgICAgICAgIGNvbnN0IHRhaWw6QXJyYXk8bnVtYmVyPiA9IFtcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXVxuICAgICAgICAgICAgZm9yIChibG9ja051bWJlciA9IDA7IGJsb2NrTnVtYmVyIDwgdmFsdWUubGVuZ3RoOyBibG9ja051bWJlcisrKVxuICAgICAgICAgICAgICAgIHRhaWxbYmxvY2tOdW1iZXIgPj4gMl0gfD0gdmFsdWUuY2hhckNvZGVBdChibG9ja051bWJlcikgPDwgKChcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgJSA0XG4gICAgICAgICAgICAgICAgKSA8PCAzKVxuICAgICAgICAgICAgdGFpbFtibG9ja051bWJlciA+PiAyXSB8PSAweDgwIDw8ICgoYmxvY2tOdW1iZXIgJSA0KSA8PCAzKVxuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gNTUpIHtcbiAgICAgICAgICAgICAgICBjeWNsZShzdGF0ZSwgdGFpbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleDpudW1iZXIgPSAwOyBpbmRleCA8IDE2OyBpbmRleCsrKVxuICAgICAgICAgICAgICAgICAgICB0YWlsW2luZGV4XSA9IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhaWxbMTRdID0gbGVuZ3RoICogOFxuICAgICAgICAgICAgY3ljbGUoc3RhdGUsIHRhaWwpXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuICAgICAgICAvLyByZWdpb24gZmluYWwgY2FsbFxuICAgICAgICBpZiAoY29udmVydFRvSGV4Q29kZShtYWluKFxuICAgICAgICAgICAgJ2hlbGxvJ1xuICAgICAgICApKSAhPT0gJzVkNDE0MDJhYmM0YjJhNzZiOTcxOWQ5MTEwMTdjNTkyJylcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBtdWNoIGZhc3Rlciwgc28gaWYgcG9zc2libGUgd2UgdXNlIGl0LiBTb21lIElFc1xuICAgICAgICAgICAgICogYXJlIHRoZSBvbmx5IG9uZXMgSSBrbm93IG9mIHRoYXQgbmVlZCB0aGUgaWRpb3RpYyBzZWNvbmRcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uLCBnZW5lcmF0ZWQgYnkgYW4gaWYgY2xhdXNlIGluIHRoZSBlbmQuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHBhcmFtIGZpcnN0IC0gRmlyc3Qgb3BlcmFuZCB0byBhZGQuXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2Vjb25kIC0gU2Vjb25kIG9wZXJhbnQgdG8gYWRkLlxuICAgICAgICAgICAgICogQHJldHVybnMgVGhlIHN1bSBvZiBib3RoIGdpdmVuIG9wZXJhbmRzLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uID0gKFxuICAgICAgICAgICAgICAgIGZpcnN0Om51bWJlciwgc2Vjb25kOm51bWJlclxuICAgICAgICAgICAgKTpudW1iZXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxzdyA9IChmaXJzdCAmIDB4RkZGRikgKyAoc2Vjb25kICYgMHhGRkZGKVxuICAgICAgICAgICAgICAgIGNvbnN0IG1zdyA9IChmaXJzdCA+PiAxNikgKyAoc2Vjb25kID4+IDE2KSArIChsc3cgPj4gMTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRilcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9IZXhDb2RlKG1haW4oKG9ubHlBc2NpaSkgPyB2YWx1ZSA6IHVuZXNjYXBlKFxuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSkpKVxuICAgICAgICAvLyBlbmRyZWdpb25cbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBnaXZlbiBwaG9uZSBudW1iZXIgZm9yIGF1dG9tYXRpYyBkaWFsaW5nIG1lY2hhbmlzbXMuXG4gICAgICogQHBhcmFtIHBob25lTnVtYmVyIC0gTnVtYmVyIHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyBOb3JtYWxpemVkIG51bWJlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nTm9ybWFsaXplUGhvbmVOdW1iZXIocGhvbmVOdW1iZXI6P3N0cmluZ3w/bnVtYmVyKTpzdHJpbmcge1xuICAgICAgICBpZiAodHlwZW9mIHBob25lTnVtYmVyID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGhvbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIGAke3Bob25lTnVtYmVyfWAucmVwbGFjZSgvW14wLTldKlxcKy8sICcwMCcpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgL1teMC05XSsvZywgJycpXG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGdpdmVuIHBob25lIG51bWJlci4gTk9URTogQ3VycmVudGx5IG9ubHkgc3VwcG9ydCBnZXJtYW4gcGhvbmVcbiAgICAgKiBudW1iZXJzLlxuICAgICAqIEBwYXJhbSBwaG9uZU51bWJlciAtIE51bWJlciB0byBmb3JtYXQuXG4gICAgICogQHJldHVybnMgRm9ybWF0dGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nUmVwcmVzZW50UGhvbmVOdW1iZXIocGhvbmVOdW1iZXI6P3N0cmluZ3w/bnVtYmVyKTpzdHJpbmcge1xuICAgICAgICBpZiAoWydudW1iZXInLCAnc3RyaW5nJ10uaW5jbHVkZXMoVG9vbHMuZGV0ZXJtaW5lVHlwZShcbiAgICAgICAgICAgIHBob25lTnVtYmVyXG4gICAgICAgICkpICYmIHBob25lTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBSZXByZXNlbnQgY291bnRyeSBjb2RlIGFuZCBsZWFkaW5nIGFyZWEgY29kZSB6ZXJvLlxuICAgICAgICAgICAgcGhvbmVOdW1iZXIgPSBgJHtwaG9uZU51bWJlcn1gLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgL14oMDB8XFwrKShbMC05XSspLShbMC05LV0rKSQvLCAnKyQyICgwKSAkMycpXG4gICAgICAgICAgICAvLyBBZGQgR2VybWFuIGNvdW50cnkgY29kZSBpZiBub3QgZXhpc3RzLlxuICAgICAgICAgICAgcGhvbmVOdW1iZXIgPSBwaG9uZU51bWJlci5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC9eMChbMS05XVswLTktXSspJC8sICcrNDkgKDApICQxJylcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIGFyZWEgY29kZSBmcm9tIGJhc2UgbnVtYmVyLlxuICAgICAgICAgICAgcGhvbmVOdW1iZXIgPSBwaG9uZU51bWJlci5yZXBsYWNlKC9eKFteLV0rKS0oWzAtOS1dKykkLywgJyQxIC8gJDInKVxuICAgICAgICAgICAgLy8gUGFydGl0aW9uIGJhc2UgbnVtYmVyIGluIG9uZSB0cmlwbGUgYW5kIHR1cGxlcyBvciB0dXBsZXMgb25seS5cbiAgICAgICAgICAgIHJldHVybiBwaG9uZU51bWJlci5yZXBsYWNlKC9eKC4qPykoWzAtOV0rKSgtP1swLTldKikkLywgKFxuICAgICAgICAgICAgICAgIG1hdGNoOnN0cmluZywgcHJlZml4OnN0cmluZywgbnVtYmVyOnN0cmluZywgc3VmZml4OnN0cmluZ1xuICAgICAgICAgICAgKTpzdHJpbmcgPT4gcHJlZml4ICsgKFxuICAgICAgICAgICAgICAgIChudW1iZXIubGVuZ3RoICUgMiA9PT0gMCkgPyBudW1iZXIucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgLyhbMC05XXsyfSkvZywgJyQxICdcbiAgICAgICAgICAgICAgICApIDogbnVtYmVyLnJlcGxhY2UoL14oWzAtOV17M30pKFswLTldKykkLywgKFxuICAgICAgICAgICAgICAgICAgICBtYXRjaDpzdHJpbmcsIHRyaXBsZTpzdHJpbmcsIHJlc3Q6c3RyaW5nXG4gICAgICAgICAgICAgICAgKTpzdHJpbmcgPT4gYCR7dHJpcGxlfSBgICsgcmVzdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvKFswLTldezJ9KS9nLCAnJDEgJ1xuICAgICAgICAgICAgICAgICkudHJpbSgpKSArIHN1ZmZpeCkudHJpbSgpKS50cmltKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbGwgaHRtbCBzeW1ib2xzIGluIHRleHQgbm9kZXMgaW4gZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gICAgICogQHBhcmFtIGh0bWxTdHJpbmcgLSBIVE1MIHN0cmluZyB0byBkZWNvZGUuXG4gICAgICogQHJldHVybnMgRGVjb2RlZCBodG1sIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nRGVjb2RlSFRNTEVudGl0aWVzKGh0bWxTdHJpbmc6c3RyaW5nKTo/c3RyaW5nIHtcbiAgICAgICAgaWYgKCdkb2N1bWVudCcgaW4gJC5nbG9iYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRhcmVhRG9tTm9kZSA9ICQuZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICAgICAgICAgIHRleHRhcmVhRG9tTm9kZS5pbm5lckhUTUwgPSBodG1sU3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gdGV4dGFyZWFEb21Ob2RlLnZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBkb20gc2VsZWN0b3IgdG8gYSBwcmVmaXhlZCBkb20gc2VsZWN0b3Igc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAtIEEgZG9tIG5vZGUgc2VsZWN0b3IuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiBzZWxlY3RvciBwcmVmaXhlZC5cbiAgICAgKi9cbiAgICBub3JtYWxpemVEb21Ob2RlU2VsZWN0b3Ioc2VsZWN0b3I6c3RyaW5nKTpzdHJpbmcge1xuICAgICAgICBsZXQgZG9tTm9kZVNlbGVjdG9yUHJlZml4OnN0cmluZyA9ICcnXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmRvbU5vZGVTZWxlY3RvclByZWZpeClcbiAgICAgICAgICAgIGRvbU5vZGVTZWxlY3RvclByZWZpeCA9IGAke3RoaXMuX29wdGlvbnMuZG9tTm9kZVNlbGVjdG9yUHJlZml4fSBgXG4gICAgICAgIGlmICghKHNlbGVjdG9yLnN0YXJ0c1dpdGgoZG9tTm9kZVNlbGVjdG9yUHJlZml4KSB8fCBzZWxlY3Rvci50cmltKFxuICAgICAgICApLnN0YXJ0c1dpdGgoJzwnKSkpXG4gICAgICAgICAgICBzZWxlY3RvciA9IGRvbU5vZGVTZWxlY3RvclByZWZpeCArIHNlbGVjdG9yXG4gICAgICAgIHJldHVybiBzZWxlY3Rvci50cmltKClcbiAgICB9XG4gICAgLy8gLyBlbmRyZWdpb25cbiAgICAvLyAvIHJlZ2lvbiBudW1iZXJcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZ2l2ZW4gb2JqZWN0IGlzIGphdmEgc2NyaXB0cyBuYXRpdmUgXCJOdW1iZXIuTmFOXCIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3QgdG8gQ2hlY2suXG4gICAgICogQHJldHVybnMgUmV0dXJucyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlciBvciBub3QuXG4gICAgICovXG4gICAgc3RhdGljIG51bWJlcklzTm90QU51bWJlcihvYmplY3Q6YW55KTpib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIFRvb2xzLmRldGVybWluZVR5cGUob2JqZWN0KSA9PT0gJ251bWJlcicgJiYgaXNOYU4ob2JqZWN0KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3VuZHMgYSBnaXZlbiBudW1iZXIgYWNjdXJhdGUgdG8gZ2l2ZW4gbnVtYmVyIG9mIGRpZ2l0cy5cbiAgICAgKiBAcGFyYW0gbnVtYmVyIC0gVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0gZGlnaXRzIC0gVGhlIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgY29tbWEuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICovXG4gICAgc3RhdGljIG51bWJlclJvdW5kKG51bWJlcjpudW1iZXIsIGRpZ2l0czpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGlnaXRzKSkgLyBNYXRoLnBvdygxMCwgZGlnaXRzKVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGRhdGEgdHJhbnNmZXJcbiAgICAvKipcbiAgICAgKiBTZW5kIGdpdmVuIGRhdGEgdG8gYSBnaXZlbiBpZnJhbWUuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIE5hbWUgb2YgdGhlIHRhcmdldCBpZnJhbWUgb3IgdGhlIHRhcmdldCBpZnJhbWUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB1cmwgLSBVUkwgdG8gc2VuZCB0byBkYXRhIHRvLlxuICAgICAqIEBwYXJhbSBkYXRhIC0gRGF0YSBob2xkaW5nIG9iamVjdCB0byBzZW5kIGRhdGEgdG8uXG4gICAgICogQHBhcmFtIHJlcXVlc3RUeXBlIC0gVGhlIGZvcm1zIGFjdGlvbiBhdHRyaWJ1dGUgdmFsdWUuIElmIG5vdGhpbmcgaXNcbiAgICAgKiBwcm92aWRlZCBcInBvc3RcIiB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0gcmVtb3ZlQWZ0ZXJMb2FkIC0gSW5kaWNhdGVzIGlmIGNyZWF0ZWQgaWZyYW1lIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICogcmlnaHQgYWZ0ZXIgbG9hZCBldmVudC4gT25seSB3b3JrcyBpZiBhbiBpZnJhbWUgb2JqZWN0IGlzIGdpdmVuIGluc3RlYWRcbiAgICAgKiBvZiBhIHNpbXBsZSB0YXJnZXQgbmFtZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBnaXZlbiB0YXJnZXQuXG4gICAgICovXG4gICAgc3RhdGljIHNlbmRUb0lGcmFtZShcbiAgICAgICAgdGFyZ2V0OiREb21Ob2RlfHN0cmluZywgdXJsOnN0cmluZywgZGF0YTp7W2tleTpzdHJpbmddOmFueX0sXG4gICAgICAgIHJlcXVlc3RUeXBlOnN0cmluZyA9ICdwb3N0JywgcmVtb3ZlQWZ0ZXJMb2FkOmJvb2xlYW4gPSBmYWxzZVxuICAgICk6c3RyaW5nIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZTpzdHJpbmcgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6XG4gICAgICAgICAgICB0YXJnZXQuYXR0cignbmFtZScpXG4gICAgICAgIGNvbnN0ICRmb3JtRG9tTm9kZTokRG9tTm9kZSA9ICQoJzxmb3JtPicpLmF0dHIoe1xuICAgICAgICAgICAgYWN0aW9uOiB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3RUeXBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXROYW1lXG4gICAgICAgIH0pXG4gICAgICAgIGZvciAoY29uc3QgbmFtZTpzdHJpbmcgaW4gZGF0YSlcbiAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgICAgICAgICRmb3JtRG9tTm9kZS5hcHBlbmQoJCgnPGlucHV0PicpLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFbbmFtZV1cbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgJGZvcm1Eb21Ob2RlLnN1Ym1pdCgpLnJlbW92ZSgpXG4gICAgICAgIGlmIChyZW1vdmVBZnRlckxvYWQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgJ29uJyBpbiB0YXJnZXQpXG4gICAgICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgICAgIHRhcmdldC5vbignbG9hZCcsICgpOiREb21Ob2RlID0+IHRhcmdldC5yZW1vdmUoKSlcbiAgICAgICAgcmV0dXJuIHRhcmdldE5hbWVcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBnaXZlbiBkYXRhIHRvIGEgdGVtcG9yYXJ5IGNyZWF0ZWQgaWZyYW1lLlxuICAgICAqIEBwYXJhbSB1cmwgLSBVUkwgdG8gc2VuZCB0byBkYXRhIHRvLlxuICAgICAqIEBwYXJhbSBkYXRhIC0gRGF0YSBob2xkaW5nIG9iamVjdCB0byBzZW5kIGRhdGEgdG8uXG4gICAgICogQHBhcmFtIHJlcXVlc3RUeXBlIC0gVGhlIGZvcm1zIGFjdGlvbiBhdHRyaWJ1dGUgdmFsdWUuIElmIG5vdGhpbmcgaXNcbiAgICAgKiBwcm92aWRlZCBcInBvc3RcIiB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0gcmVtb3ZlQWZ0ZXJMb2FkIC0gSW5kaWNhdGVzIGlmIGNyZWF0ZWQgaWZyYW1lIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICogcmlnaHQgYWZ0ZXIgbG9hZCBldmVudC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBkeW5hbWljYWxseSBjcmVhdGVkIGlmcmFtZS5cbiAgICAgKi9cbiAgICBzZW5kVG9FeHRlcm5hbFVSTChcbiAgICAgICAgdXJsOnN0cmluZywgZGF0YTp7W2tleTpzdHJpbmddOmFueX0sIHJlcXVlc3RUeXBlOnN0cmluZyA9ICdwb3N0JyxcbiAgICAgICAgcmVtb3ZlQWZ0ZXJMb2FkOmJvb2xlYW4gPSB0cnVlXG4gICAgKTpzdHJpbmcge1xuICAgICAgICBjb25zdCAkaUZyYW1lRG9tTm9kZTokRG9tTm9kZSA9ICQoJzxpZnJhbWU+JykuYXR0cihcbiAgICAgICAgICAgICduYW1lJywgdGhpcy5jb25zdHJ1Y3Rvci5fbmFtZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9uYW1lLnN1YnN0cmluZygxKSArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKClcbiAgICAgICAgKS5oaWRlKClcbiAgICAgICAgdGhpcy4kZG9tTm9kZS5hZnRlcigkaUZyYW1lRG9tTm9kZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iuc2VuZFRvSUZyYW1lKFxuICAgICAgICAgICAgJGlGcmFtZURvbU5vZGUsIHVybCwgZGF0YSwgcmVxdWVzdFR5cGUsIHJlbW92ZUFmdGVyTG9hZClcbiAgICB9XG4gICAgLy8gLyBlbmRyZWdpb25cbiAgICAvLyBlbmRyZWdpb25cbiAgICAvLyByZWdpb24gcHJvdGVjdGVkXG4gICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgZm9yIGF0dGFjaCBldmVudCBoYW5kbGVyIG1ldGhvZHMgYW5kIHRoZWlyIGV2ZW50IGhhbmRsZXJcbiAgICAgKiByZW1vdmUgcGVuZGFudHMuXG4gICAgICogQHBhcmFtIHBhcmFtZXRlciAtIEFyZ3VtZW50cyBvYmplY3QgZ2l2ZW4gdG8gbWV0aG9kcyBsaWtlIFwiYmluZCgpXCIgb3JcbiAgICAgKiBcInVuYmluZCgpXCIuXG4gICAgICogQHBhcmFtIHJlbW92ZUV2ZW50IC0gSW5kaWNhdGVzIGlmIFwidW5iaW5kKClcIiBvciBcImJpbmQoKVwiIHdhcyBnaXZlbi5cbiAgICAgKiBAcGFyYW0gZXZlbnRGdW5jdGlvbk5hbWUgLSBOYW1lIG9mIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMgUmV0dXJucyAkJ3Mgd3JhcHBlZCBkb20gbm9kZS5cbiAgICAgKi9cbiAgICBfYmluZEV2ZW50SGVscGVyKFxuICAgICAgICBwYXJhbWV0ZXI6QXJyYXk8YW55PiwgcmVtb3ZlRXZlbnQ6Ym9vbGVhbiA9IGZhbHNlLFxuICAgICAgICBldmVudEZ1bmN0aW9uTmFtZTpzdHJpbmcgPSAnb24nXG4gICAgKTokRG9tTm9kZSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBqc2RvYy9yZXF1aXJlLWRlc2NyaXB0aW9uLWNvbXBsZXRlLXNlbnRlbmNlICovXG4gICAgICAgIGNvbnN0ICRkb21Ob2RlOiREb21Ob2RlID0gJChwYXJhbWV0ZXJbMF0pXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmRldGVybWluZVR5cGUoXG4gICAgICAgICAgICBwYXJhbWV0ZXJbMV1cbiAgICAgICAgKSA9PT0gJ29iamVjdCcgJiYgIXJlbW92ZUV2ZW50KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50VHlwZTpzdHJpbmcgaW4gcGFyYW1ldGVyWzFdKVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJbMV0uaGFzT3duUHJvcGVydHkoZXZlbnRUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRGdW5jdGlvbk5hbWVdKFxuICAgICAgICAgICAgICAgICAgICAgICAgJGRvbU5vZGUsIGV2ZW50VHlwZSwgcGFyYW1ldGVyWzFdW2V2ZW50VHlwZV0pXG4gICAgICAgICAgICByZXR1cm4gJGRvbU5vZGVcbiAgICAgICAgfVxuICAgICAgICBwYXJhbWV0ZXIgPSB0aGlzLmNvbnN0cnVjdG9yLmFycmF5TWFrZShwYXJhbWV0ZXIpLnNsaWNlKDEpXG4gICAgICAgIGlmIChwYXJhbWV0ZXIubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcGFyYW1ldGVyLnB1c2goJycpXG4gICAgICAgIGlmICghcGFyYW1ldGVyWzBdLmluY2x1ZGVzKCcuJykpXG4gICAgICAgICAgICBwYXJhbWV0ZXJbMF0gKz0gYC4ke3RoaXMuY29uc3RydWN0b3IuX25hbWV9YFxuICAgICAgICBpZiAocmVtb3ZlRXZlbnQpXG4gICAgICAgICAgICByZXR1cm4gJGRvbU5vZGVbZXZlbnRGdW5jdGlvbk5hbWVdLmFwcGx5KCRkb21Ob2RlLCBwYXJhbWV0ZXIpXG4gICAgICAgIHJldHVybiAkZG9tTm9kZVtldmVudEZ1bmN0aW9uTmFtZV0uYXBwbHkoJGRvbU5vZGUsIHBhcmFtZXRlcilcbiAgICB9XG4gICAgLy8gZW5kcmVnaW9uXG59XG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiBoYW5kbGUgJCBleHRlbmRpbmdcbmlmICgnZm4nIGluICQpXG4gICAgJC5mbi5Ub29scyA9IGZ1bmN0aW9uKCk6YW55IHtcbiAgICAgICAgcmV0dXJuIChuZXcgVG9vbHMoKSkuY29udHJvbGxlcihUb29scywgYXJndW1lbnRzLCB0aGlzKVxuICAgIH1cbiQuVG9vbHMgPSBmdW5jdGlvbigpOmFueSB7XG4gICAgcmV0dXJuIChuZXcgVG9vbHMoKSkuY29udHJvbGxlcihUb29scywgYXJndW1lbnRzKVxufVxuJC5Ub29scy5jbGFzcyA9IFRvb2xzXG4vLyAvIHJlZ2lvbiBwcm9wIGZpeCBmb3IgY29tbWVudHMgYW5kIHRleHQgbm9kZXNcbmlmICgnZm4nIGluICQpIHtcbiAgICBjb25zdCBuYXRpdmVQcm9wRnVuY3Rpb24gPSAkLmZuLnByb3BcbiAgICAvKipcbiAgICAgKiBKUXVlcnkncyBuYXRpdmUgcHJvcCBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHByb3BlcnRpZXMgZm9yIHRleHQgbm9kZXMsXG4gICAgICogY29tbWVudHMgYW5kIGF0dHJpYnV0ZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0ga2V5IC0gTmFtZSBvZiBwcm9wZXJ0eSB0byByZXRyaWV2ZSBmcm9tIGN1cnJlbnQgZG9tIG5vZGUuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gc2V0IGZvciBnaXZlbiBwcm9wZXJ0eSBieSBuYW1lLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdmFsdWUgaWYgdXNlZCBhcyBnZXR0ZXIgb3IgY3VycmVudCBkb20gbm9kZSBpZiB1c2VkIGFzXG4gICAgICogc2V0dGVyLlxuICAgICAqL1xuICAgICQuZm4ucHJvcCA9IGZ1bmN0aW9uKGtleTpzdHJpbmcsIHZhbHVlOmFueSk6YW55IHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHRoaXMubGVuZ3RoICYmIFtcbiAgICAgICAgICAgICcjdGV4dCcsICcjY29tbWVudCdcbiAgICAgICAgXS5pbmNsdWRlcyh0aGlzWzBdLm5vZGVOYW1lKSAmJiBrZXkgaW4gdGhpc1swXSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF1ba2V5XVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzWzBdW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVByb3BGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxufVxuLy8gLyBlbmRyZWdpb25cbi8vIGVuZHJlZ2lvblxuLy8gcmVnaW9uIHZpbSBtb2RsaW5lXG4vLyB2aW06IHNldCB0YWJzdG9wPTQgc2hpZnR3aWR0aD00IGV4cGFuZHRhYjpcbi8vIHZpbTogZm9sZG1ldGhvZD1tYXJrZXIgZm9sZG1hcmtlcj1yZWdpb24sZW5kcmVnaW9uOlxuLy8gZW5kcmVnaW9uXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBpbmRleC5qc1xuICoqLyIsInVuZGVmaW5lZFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIFxuICoqLyJdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQXFEQTtBQUNBO0FBQ0E7QUF0REE7QUFDQTtBQXFEQTtBQUNBO0FDQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QURFQTtBQUFBO0FDQUE7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QURDQTtBQUNBO0FDRUE7QUFDQTtBQUNBO0FBM0JBO0FBQ0E7QUFEQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBREVBO0FDRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0E7QUE2R0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFUQTtBQUNBO0FBMEJBO0FBUUE7QUFBQTtBQUFBO0FBTEE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFUQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQXpLQTtBQUNBO0FBQ0E7OztBQTJLQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFBQTs7OztBQUlBO0FBRUE7Ozs7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBOzs7O0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUVBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQXVIQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBUkE7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFKQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUxBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBOERBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFjQTs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFNQTtBQUNBOzs7Ozs7Ozs7QUFzQkE7Ozs7OztBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUhBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFaQTtBQWVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQTZDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQWFBO0FBRUE7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFFQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUF5RUE7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBNDJEQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQXVEQTs7Ozs7Ozs7OztBQVdBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQXR2RkE7QUFDQTtBQUNBOzs7OztBQUtBO0FBRUE7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBSUE7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFKQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUdBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUE4SEE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7O0FBaUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7QUFQQTtBQVdBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFqQkE7QUFzQkE7QUFHQTtBQUdBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFpQ0E7QUFDQTtBQUVBO0FBS0E7OztBQXFCQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQVhBO0FBWUE7QUFBQTtBQUNBO0FBREE7QUFJQTs7O0FBbURBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7OztBQXVEQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7Ozs7QUFJQTtBQVJBO0FBVUE7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBOzs7QUFtREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFFQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQStEQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVNBO0FBRUE7QUFDQTtBQURBO0FBUUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBSUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBVkE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUNBO0FBRUE7QUF4QkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUFDQTtBQURBO0FBSUE7QUFkQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBS0E7QUFMQTtBQUFBO0FBS0E7QUFKQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFEQTtBQU1BO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVNBO0FBeEJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUF5QkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBS0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUF6Q0E7QUF6QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBa0VBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBS0E7QUF0QkE7QUE0QkE7QUFDQTs7Ozs7Ozs7Ozs7QUFTQTtBQUlBO0FBRkE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFFQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBSUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUVBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFEQTtBQUlBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBcUJBO0FBTUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVVBO0FBRUE7QUFDQTtBQUlBO0FBTEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU1BO0FBQUE7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBVEE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUVBO0FBS0E7QUF4QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFEQTtBQUdBO0FBQ0E7QUFJQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQVRBO0FBWUE7QUFsQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBRUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU9BO0FBRUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFSQTtBQVdBO0FBZkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBRUE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQS9DQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUErQ0E7QUFoREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXFEQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBT0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBSUE7QUFDQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFhQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQWFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQWNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUEvQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWdEQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBU0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFTQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFTQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFHQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBR0E7QUFFQTtBQUVBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7OztBQUdBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7O0FBV0E7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7O0FBV0E7QUFBQTtBQUFBO0FBSUE7Ozs7Ozs7Ozs7O0FBV0E7QUFBQTtBQUFBO0FBSUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBR0E7QUFIQTtBQVFBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBSkE7QUFPQTtBQUVBO0FBQ0E7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7Ozs7QUFTQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFBQTtBQUxBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUZBO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7O0FBK0RBO0FBQ0E7QUFDQTtBQUNBO0FBbmlHQTtBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQU5BO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBQ0E7QUFsQkE7QUEwQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQXhFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWtpR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/YzNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ function(module, exports) {

	eval("if(typeof __WEBPACK_EXTERNAL_MODULE_3__ === 'undefined') {var e = new Error(\"Cannot find module \\\"jQuery\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiPzBjYjgiXSwic291cmNlc0NvbnRlbnQiOlsiaWYodHlwZW9mIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fID09PSAndW5kZWZpbmVkJykge3ZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlIFxcXCJqUXVlcnlcXFwiXCIpOyBlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7IHRocm93IGU7fVxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwialF1ZXJ5XCJcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ])
});
;