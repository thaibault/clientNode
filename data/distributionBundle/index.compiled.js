(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("babel-runtime/core-js/get-iterator"), require("babel-runtime/core-js/json/stringify"), require("babel-runtime/core-js/map"), require("babel-runtime/core-js/object/get-prototype-of"), require("babel-runtime/helpers/classCallCheck"), require("babel-runtime/helpers/createClass"), require("babel-runtime/helpers/slicedToArray"), require("babel-runtime/helpers/typeof"), (function webpackLoadOptionalExternalModule() { try { return require('jquery'); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define("clientnode", ["babel-runtime/core-js/get-iterator", "babel-runtime/core-js/json/stringify", "babel-runtime/core-js/map", "babel-runtime/core-js/object/get-prototype-of", "babel-runtime/helpers/classCallCheck", "babel-runtime/helpers/createClass", "babel-runtime/helpers/slicedToArray", "babel-runtime/helpers/typeof", 'jquery'], factory);
	else if(typeof exports === 'object')
		exports["clientnode"] = factory(require("babel-runtime/core-js/get-iterator"), require("babel-runtime/core-js/json/stringify"), require("babel-runtime/core-js/map"), require("babel-runtime/core-js/object/get-prototype-of"), require("babel-runtime/helpers/classCallCheck"), require("babel-runtime/helpers/createClass"), require("babel-runtime/helpers/slicedToArray"), require("babel-runtime/helpers/typeof"), (function webpackLoadOptionalExternalModule() { try { return require('jquery'); } catch(e) {} }()));
	else
		root['clientnode'] = factory(root["babel-runtime/core-js/get-iterator"], root["babel-runtime/core-js/json/stringify"], root["babel-runtime/core-js/map"], root["babel-runtime/core-js/object/get-prototype-of"], root["babel-runtime/helpers/classCallCheck"], root["babel-runtime/helpers/createClass"], root["babel-runtime/helpers/slicedToArray"], root["babel-runtime/helpers/typeof"], root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_11__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*******************!*\
  !*** multi index ***!
  \*******************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! index.js */1);


/***/ },
/* 1 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global, module) {\n// #!/usr/bin/env node\n// -*- coding: utf-8 -*-\n/** @module clientnode */\n'use strict';\n/* !\n    region header\n    [Project page](http://torben.website/clientnode)\n\n    Copyright Torben Sickert (info[\"~at~\"]torben.website) 16.12.2012\n\n    License\n    -------\n\n    This library written by Torben Sickert stand under a creative commons\n    naming 3.0 unported license.\n    See http://creativecommons.org/licenses/by/3.0/deed.de\n    endregion\n*/\n// region imports\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.$ = exports.globalContext = undefined;\n\nvar _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ 4);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _slicedToArray2 = __webpack_require__(/*! babel-runtime/helpers/slicedToArray */ 9);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _map = __webpack_require__(/*! babel-runtime/core-js/map */ 5);\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ 6);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ 3);\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ 7);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ 8);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ 10);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// endregion\n// region determine context\n\n// endregion\n// region types\nvar globalContext = exports.globalContext = function () {\n    if (typeof window === 'undefined') {\n        if (typeof global === 'undefined') return  false ? {} : module;\n        if ('window' in global) return global.window;\n        return global;\n    }\n    return window;\n}();\n/* eslint-disable no-use-before-define */\nvar $ = exports.$ = function () {\n    /* eslint-enable no-use-before-define */\n    var _$ = void 0;\n    if ('$' in globalContext && globalContext.$ !== null) _$ = globalContext.$;else {\n        var _ret = function () {\n            if (!('$' in globalContext)) try {\n                return {\n                    v: __webpack_require__(/*! jquery */ 11)\n                };\n            } catch (error) {}\n            var selector = 'document' in globalContext && 'querySelectorAll' in globalContext.document ? globalContext.document.querySelectorAll : function () {\n                return null;\n            };\n            _$ = function $(parameter) {\n                if (typeof parameter === 'string') {\n                    var $domNodes = selector.apply(globalContext.document, arguments);\n                    if ('fn' in _$) for (var _key in _$.fn) {\n                        if (_$.fn.hasOwnProperty(_key))\n                            // IgnoreTypeCheck\n                            $domNodes[_key] = _$.fn[_key].bind($domNodes);\n                    }return $domNodes;\n                }\n                /* eslint-disable no-use-before-define */\n                if (Tools.isFunction(parameter) && 'document' in globalContext)\n                    /* eslint-enable no-use-before-define */\n                    globalContext.document.addEventListener('DOMContentLoaded', parameter);\n                return parameter;\n            };\n            _$.fn = {};\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === \"object\") return _ret.v;\n    }\n    return _$;\n}();\nif (!('global' in $)) $.global = globalContext;\nif (!('context' in $) && 'document' in $.global) $.contest = $.global.document;\n// endregion\n// region plugins/classes\n/**\n * This plugin provides such interface logic like generic controller logic for\n * integrating plugins into $, mutual exclusion for depending gui elements,\n * logging additional string, array or function handling. A set of helper\n * functions to parse option objects dom trees or handle events is also\n * provided.\n * @property static:abbreviations - Lists all known abbreviation for proper\n * camel case to delimited and back conversion.\n * @property static:animationEndEventNames - Saves a string with all css3\n * browser specific animation end event names.\n * @property static:keyCode - Saves a mapping from key codes to their\n * corresponding name.\n * @property static:maximalSupportedInternetExplorerVersion - Saves currently\n * minimal supported internet explorer version. Saves zero if no internet\n * explorer present.\n * @property static:transitionEndEventNames - Saves a string with all css3\n * browser specific transition end event names.\n * @property static:consoleMethodNames - This variable contains a collection of\n * methods usually binded to the console object.\n * @property static:_javaScriptDependentContentHandled - Indicates whether\n * javaScript dependent content where hide or shown.\n * @property static:_name - Defines this class name to allow retrieving them\n * after name mangling.\n * @property $domNode - $-extended dom node if one was given to the constructor\n * method.\n * @property _options - Options given to the constructor.\n * @property _defaultOptions - Fallback options if not overwritten by the\n * options given to the constructor method.\n * @property _defaultOptions.logging {boolean} - Indicates whether logging\n * should be active.\n * @property _defaultOptions.domNodeSelectorPrefix {string} - Selector prefix\n * for all needed dom nodes.\n * @property _defaultOptions.domNode {Object.<string, string>} - Mapping of\n * names to needed dom nodes referenced by there selector.\n * @property _defaultOptions.domNode.hideJavaScriptEnabled {string} - Selector\n * to dom nodes which should be hidden if javaScript is available.\n * @property _defaultOptions.domNode.showJavaScriptEnabled {string} - Selector\n * to dom nodes which should be visible if javaScript is available.\n * @property _locks - Mapping of lock descriptions to there corresponding\n * callbacks.\n */\n\nvar Tools = function () {\n    // endregion\n    // region public methods\n    // / region special\n    /**\n     * This method should be overwritten normally. It is triggered if current\n     * object is created via the \"new\" keyword. The dom node selector prefix\n     * enforces to not globally select any dom nodes which aren't in the\n     * expected scope of this plugin. \"{1}\" will be automatically replaced with\n     * this plugin name suffix (\"tools\"). You don't have to use \"{1}\" but it\n     * can help you to write code which is more reconcilable with the dry\n     * concept.\n     * @param $domNode - $-extended dom node to use as reference in various\n     * methods.\n     * @param options - Options to change runtime behavior.\n     * @param defaultOptions - Default options to ensure to be present in any\n     * options instance.\n     * @param locks - Mapping of a lock description to callbacks for calling\n     * when given lock should be released.\n     * @returns Returns nothing but if invoked with \"new\" an instance of this\n     * class will be given back.\n     */\n\n    // endregion\n    // region dynamic properties\n    function Tools() {\n        var $domNode = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n        var defaultOptions = arguments.length <= 2 || arguments[2] === undefined ? {\n            logging: false, domNodeSelectorPrefix: 'body', domNode: {\n                hideJavaScriptEnabled: '.tools-hidden-on-javascript-enabled',\n                showJavaScriptEnabled: '.tools-visible-on-javascript-enabled'\n            }\n        } : arguments[2];\n        var locks = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n        (0, _classCallCheck3.default)(this, Tools);\n\n        if ($domNode) this.$domNode = $domNode;\n        this._options = options;\n        this._defaultOptions = defaultOptions;\n        this._locks = locks;\n        // Avoid errors in browsers that lack a console.\n        if (!('console' in $.global)) $.global.console = {};\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = (0, _getIterator3.default)(this.constructor.consoleMethodNames), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var methodName = _step.value;\n\n                if (!(methodName in $.global.console)) $.global.console[methodName] = this.constructor.noop;\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        if (!this.constructor._javaScriptDependentContentHandled && 'document' in $.global && 'filter' in $ && 'hide' in $ && 'show' in $) {\n            this.constructor._javaScriptDependentContentHandled = true;\n            $(this._defaultOptions.domNodeSelectorPrefix + ' ' + this._defaultOptions.domNode.hideJavaScriptEnabled).filter(function () {\n                return !$(this).data('javaScriptDependentContentHide');\n            }).data('javaScriptDependentContentHide', true).hide();\n            $(this._defaultOptions.domNodeSelectorPrefix + ' ' + this._defaultOptions.domNode.showJavaScriptEnabled).filter(function () {\n                return !$(this).data('javaScriptDependentContentShow');\n            }).data('javaScriptDependentContentShow', true).show();\n        }\n    }\n    /**\n     * This method could be overwritten normally. It acts like a destructor.\n     * @returns Returns the current instance.\n     */\n\n    // region static properties\n\n\n    (0, _createClass3.default)(Tools, [{\n        key: 'destructor',\n        value: function destructor() {\n            if ('off' in $.fn) this.off('*');\n            return this;\n        }\n        /**\n         * This method should be overwritten normally. It is triggered if current\n         * object was created via the \"new\" keyword and is called now.\n         * @param options - An options object.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'initialize',\n        value: function initialize() {\n            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n            /*\n                NOTE: We have to create a new options object instance to avoid\n                changing a static options object.\n            */\n            this._options = this.constructor.extendObject(true, {}, this._defaultOptions, this._options, options);\n            /*\n                The selector prefix should be parsed after extending options\n                because the selector would be overwritten otherwise.\n            */\n            this._options.domNodeSelectorPrefix = this.constructor.stringFormat(this._options.domNodeSelectorPrefix, this.constructor.stringCamelCaseToDelimited(this.constructor._name));\n            return this;\n        }\n        // / endregion\n        // / region object orientation\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Defines a generic controller for dom node aware plugins.\n         * @param object - The object or class to control. If \"object\" is a class\n         * an instance will be generated.\n         * @param parameter - The initially given arguments object.\n         * @param $domNode - Optionally a $-extended dom node to use as reference.\n         * @returns Returns whatever the initializer method returns.\n         */\n\n    }, {\n        key: 'controller',\n        value: function controller(object, parameter) {\n            var $domNode = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            if (typeof object === 'function') {\n                object = new object($domNode);\n                if (!object instanceof Tools) object = this.constructor.extendObject(true, new Tools(), object);\n            }\n            parameter = this.constructor.arrayMake(parameter);\n            if ($domNode && 'data' in $domNode && !$domNode.data(object.constructor._name))\n                // Attach extended object to the associated dom node.\n                $domNode.data(object.constructor._name, object);\n            if (parameter[0] in object) return object[parameter[0]].apply(object, parameter.slice(1));else if (parameter.length === 0 || (0, _typeof3.default)(parameter[0]) === 'object')\n                /*\n                    If an options object or no method name is given the initializer\n                    will be called.\n                */\n                return object.initialize.apply(object, parameter);\n            throw Error('Method \"' + parameter[0] + '\" does not exist on $-extended dom node ' + ('\"' + object.constructor._name + '\".'));\n        }\n        // / endregion\n        // / region mutual exclusion\n        /**\n         * Calling this method introduces a starting point for a critical area with\n         * potential race conditions. The area will be binded to given description\n         * string. So don't use same names for different areas.\n         * @param description - A short string describing the critical areas\n         * properties.\n         * @param callbackFunction - A procedure which should only be executed if\n         * the interpreter isn't in the given critical area. The lock description\n         * string will be given to the callback function.\n         * @param autoRelease - Release the lock after execution of given callback.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'acquireLock',\n        value: function acquireLock(description, callbackFunction) {\n            var _this = this;\n\n            var autoRelease = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n            var wrappedCallbackFunction = function wrappedCallbackFunction(description) {\n                callbackFunction(description);\n                if (autoRelease) _this.releaseLock(description);\n            };\n            if (this._locks.hasOwnProperty(description)) this._locks[description].push(wrappedCallbackFunction);else {\n                this._locks[description] = [];\n                wrappedCallbackFunction(description);\n            }\n            return this;\n        }\n        /**\n         * Calling this method  causes the given critical area to be finished and\n         * all functions given to \"this.acquireLock()\" will be executed in right\n         * order.\n         * @param description - A short string describing the critical areas\n         * properties.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'releaseLock',\n        value: function releaseLock(description) {\n            if (this._locks.hasOwnProperty(description)) if (this._locks[description].length) this._locks[description].shift()(description);else delete this._locks[description];\n            return this;\n        }\n        // / endregion\n        // / region boolean\n        /**\n         * Determines whether its argument represents a JavaScript number.\n         * @param object - Object to analyze.\n         * @returns A boolean value indicating whether given object is numeric\n         * like.\n         */\n\n    }, {\n        key: 'log',\n\n        // / endregion\n        // / region logging\n        /**\n         * Shows the given object's representation in the browsers console if\n         * possible or in a standalone alert-window as fallback.\n         * @param object - Any object to print.\n         * @param force - If set to \"true\" given input will be shown independently\n         * from current logging configuration or interpreter's console\n         * implementation.\n         * @param avoidAnnotation - If set to \"true\" given input has no module or\n         * log level specific annotations.\n         * @param level - Description of log messages importance.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n        value: function log(object) {\n            var force = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n            var avoidAnnotation = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n            var level = arguments.length <= 3 || arguments[3] === undefined ? 'info' : arguments[3];\n\n            if (this._options.logging || force || ['error', 'critical'].includes(level)) {\n                var message = void 0;\n                if (avoidAnnotation) message = object;else if (typeof object === 'string') {\n                    for (var _len = arguments.length, additionalArguments = Array(_len > 4 ? _len - 4 : 0), _key2 = 4; _key2 < _len; _key2++) {\n                        additionalArguments[_key2 - 4] = arguments[_key2];\n                    }\n\n                    additionalArguments.unshift(object);\n                    message = this.constructor._name + ' (' + level + '): ' + this.constructor.stringFormat.apply(this, additionalArguments);\n                } else if (this.constructor.isNumeric(object) || typeof object === 'boolean') message = this.constructor._name + ' (' + level + '): ' + object.toString();else {\n                    this.log(',--------------------------------------------,');\n                    this.log(object, force, true);\n                    this.log(\"'--------------------------------------------'\");\n                }\n                if (message) if (!('console' in $.global && level in $.global.console) || $.global.console[level] === this.constructor.noop) {\n                    if ('alert' in $.global) $.global.alert(message);\n                } else $.global.console[level](message);\n            }\n            return this;\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'info',\n        value: function info(object) {\n            for (var _len2 = arguments.length, additionalArguments = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {\n                additionalArguments[_key3 - 1] = arguments[_key3];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, false, false, 'info'].concat(additionalArguments));\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'debug',\n        value: function debug(object) {\n            for (var _len3 = arguments.length, additionalArguments = Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {\n                additionalArguments[_key4 - 1] = arguments[_key4];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, false, false, 'debug'].concat(additionalArguments));\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'error',\n        value: function error(object) {\n            for (var _len4 = arguments.length, additionalArguments = Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {\n                additionalArguments[_key5 - 1] = arguments[_key5];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, true, false, 'error'].concat(additionalArguments));\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'critical',\n        value: function critical(object) {\n            for (var _len5 = arguments.length, additionalArguments = Array(_len5 > 1 ? _len5 - 1 : 0), _key6 = 1; _key6 < _len5; _key6++) {\n                additionalArguments[_key6 - 1] = arguments[_key6];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, true, false, 'warn'].concat(additionalArguments));\n        }\n        /**\n         * Wrapper method for the native console method usually provided by\n         * interpreter.\n         * @param object - Any object to print.\n         * @param additionalArguments - Additional arguments are used for string\n         * formating.\n         * @returns Returns the current instance.\n         */\n\n    }, {\n        key: 'warn',\n        value: function warn(object) {\n            for (var _len6 = arguments.length, additionalArguments = Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {\n                additionalArguments[_key7 - 1] = arguments[_key7];\n            }\n\n            // IgnoreTypeCheck\n            return this.log.apply(this, [object, false, false, 'warn'].concat(additionalArguments));\n        }\n        /**\n         * Dumps a given object in a human readable format.\n         * @param object - Any object to show.\n         * @param level - Number of levels to dig into given object recursively.\n         * @param currentLevel - Maximal number of recursive function calls to\n         * represent given object.\n         * @returns Returns the serialized version of given object.\n         */\n\n    }, {\n        key: 'getText',\n\n        // / endregion\n        // / region dom node\n        /**\n         * Get text content of current element without it children's text contents.\n         * @returns The text string.\n         */\n        value: function getText() {\n            return this.$domNode.clone().children().remove().end().text();\n        }\n        /**\n         * Normalizes class name order of current dom node.\n         * @returns Current instance.\n         */\n\n    }, {\n        key: 'normalizeClassNames',\n        value: function normalizeClassNames() {\n            this.$domNode.find('*').addBack().each(function () {\n                var $thisDomNode = $(this);\n                if ($thisDomNode.attr('class')) {\n                    var sortedClassNames = $thisDomNode.attr('class').split(' ').sort() || [];\n                    $thisDomNode.attr('class', '');\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = (0, _getIterator3.default)(sortedClassNames), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var _className = _step2.value;\n\n                            $thisDomNode.addClass(_className);\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                } else if ($thisDomNode.is('[class]')) $thisDomNode.removeAttr('class');\n            });\n            return this;\n        }\n        /**\n         * Normalizes style attributes order of current dom node.\n         * @returns Returns current instance.\n         */\n\n    }, {\n        key: 'normalizeStyles',\n        value: function normalizeStyles() {\n            var self = this;\n            this.$domNode.find('*').addBack().each(function () {\n                var $thisDomNode = $(this);\n                var serializedStyles = $thisDomNode.attr('style');\n                if (serializedStyles) {\n                    var sortedStyles = self.constructor.stringCompressStyleValue(serializedStyles).split(';').sort() || [];\n                    $thisDomNode.attr('style', '');\n                    var _iteratorNormalCompletion3 = true;\n                    var _didIteratorError3 = false;\n                    var _iteratorError3 = undefined;\n\n                    try {\n                        for (var _iterator3 = (0, _getIterator3.default)(sortedStyles), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                            var style = _step3.value;\n\n                            $thisDomNode.css.apply($thisDomNode, style.trim().split(':'));\n                        }\n                    } catch (err) {\n                        _didIteratorError3 = true;\n                        _iteratorError3 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                _iterator3.return();\n                            }\n                        } finally {\n                            if (_didIteratorError3) {\n                                throw _iteratorError3;\n                            }\n                        }\n                    }\n\n                    $thisDomNode.attr('style', self.constructor.stringCompressStyleValue($thisDomNode.attr('style')));\n                } else if ($thisDomNode.is('[style]')) $thisDomNode.removeAttr('style');\n            });\n            return this;\n        }\n        /**\n         * Checks whether given html or text strings are equal.\n         * @param first - First html, selector to dom node or text to compare.\n         * @param second - Second html, selector to dom node  or text to compare.\n         * @param forceHTMLString - Indicates whether given contents are\n         * interpreted as html string (otherwise an automatic detection will be\n         * triggered).\n         * @returns Returns true if both dom representations are equivalent.\n         */\n\n    }, {\n        key: 'getPositionRelativeToViewport',\n\n        /**\n         * Determines where current dom node is relative to current view port\n         * position.\n         * @param delta - Allows deltas for \"top\", \"left\", \"bottom\" and \"right\" for\n         * determining positions.\n         * @returns Returns one of \"above\", \"left\", \"below\", \"right\" or \"in\".\n         */\n        value: function getPositionRelativeToViewport() {\n            var delta = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n            delta = this.constructor.extendObject({ top: 0, left: 0, bottom: 0, right: 0 }, delta);\n            if ('window' in $.global && this.$domNode && this.$domNode.length && this.$domNode[0]) {\n                var $window = $($.global.window);\n                var rectangle = this.$domNode[0].getBoundingClientRect();\n                if (rectangle.top + delta.top < 0) return 'above';\n                if (rectangle.left + delta.left < 0) return 'left';\n                if ($window.height() < rectangle.bottom + delta.bottom) return 'below';\n                if ($window.width() < rectangle.right + delta.right) return 'right';\n            }\n            return 'in';\n        }\n        /**\n         * Generates a directive name corresponding selector string.\n         * @param directiveName - The directive name.\n         * @returns Returns generated selector.\n         */\n\n    }, {\n        key: 'removeDirective',\n\n        /**\n         * Removes a directive name corresponding class or attribute.\n         * @param directiveName - The directive name.\n         * @returns Returns current dom node.\n         */\n        value: function removeDirective(directiveName) {\n            var delimitedName = this.constructor.stringCamelCaseToDelimited(directiveName);\n            return this.$domNode.removeClass(delimitedName).removeAttr(delimitedName).removeAttr('data-' + delimitedName).removeAttr('x-' + delimitedName).removeAttr(delimitedName.replace('-', ':')).removeAttr(delimitedName.replace('-', '_'));\n        }\n        /**\n         * Determines a normalized camel case directive name representation.\n         * @param directiveName - The directive name.\n         * @returns Returns the corresponding name.\n         */\n\n    }, {\n        key: 'getDirectiveValue',\n\n        /**\n         * Determines a directive attribute value.\n         * @param directiveName - The directive name.\n         * @returns Returns the corresponding attribute value or \"null\" if no\n         * attribute value exists.\n         */\n        value: function getDirectiveValue(directiveName) {\n            var delimitedName = this.constructor.stringCamelCaseToDelimited(directiveName);\n            var _arr = [delimitedName, 'data-' + delimitedName, 'x-' + delimitedName, delimitedName.replace('-', '\\\\:')];\n            for (var _i = 0; _i < _arr.length; _i++) {\n                var _attributeName = _arr[_i];\n                var _value = this.$domNode.attr(_attributeName);\n                if (_value !== undefined) return _value;\n            }\n            return null;\n        }\n        /**\n         * Removes a selector prefix from a given selector. This methods searches\n         * in the options object for a given \"domNodeSelectorPrefix\".\n         * @param domNodeSelector - The dom node selector to slice.\n         * @returns Returns the sliced selector.\n         */\n\n    }, {\n        key: 'sliceDomNodeSelectorPrefix',\n        value: function sliceDomNodeSelectorPrefix(domNodeSelector) {\n            if ('domNodeSelectorPrefix' in this._options && domNodeSelector.startsWith(this._options.domNodeSelectorPrefix)) return domNodeSelector.substring(this._options.domNodeSelectorPrefix.length).trim();\n            return domNodeSelector;\n        }\n        /**\n         * Determines the dom node name of a given dom node string.\n         * @param domNodeSelector - A given to dom node selector to determine its\n         * name.\n         * @returns Returns The dom node name.\n         * @example\n         * // returns 'div'\n         * $.Tools.getDomNodeName('&lt;div&gt;')\n         * @example\n         * // returns 'div'\n         * $.Tools.getDomNodeName('&lt;div&gt;&lt;/div&gt;')\n         * @example\n         * // returns 'br'\n         * $.Tools.getDomNodeName('&lt;br/&gt;')\n         */\n\n    }, {\n        key: 'grabDomNode',\n\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Converts an object of dom selectors to an array of $ wrapped dom nodes.\n         * Note if selector description as one of \"class\" or \"id\" as suffix element\n         * will be ignored.\n         * @param domNodeSelectors - An object with dom node selectors.\n         * @param wrapperDomNode - A dom node to be the parent or wrapper of all\n         * retrieved dom nodes.\n         * @returns Returns All $ wrapped dom nodes corresponding to given\n         * selectors.\n         */\n        value: function grabDomNode(domNodeSelectors, wrapperDomNode) {\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            var domNodes = {};\n            if (domNodeSelectors) if (wrapperDomNode) {\n                var $wrapperDomNode = $(wrapperDomNode);\n                for (var _name in domNodeSelectors) {\n                    if (domNodeSelectors.hasOwnProperty(_name)) domNodes[_name] = $wrapperDomNode.find(domNodeSelectors[_name]);\n                }\n            } else for (var _name2 in domNodeSelectors) {\n                if (domNodeSelectors.hasOwnProperty(_name2)) {\n                    var match = domNodeSelectors[_name2].match(', *');\n                    if (match) {\n                        var _iteratorNormalCompletion4 = true;\n                        var _didIteratorError4 = false;\n                        var _iteratorError4 = undefined;\n\n                        try {\n                            for (var _iterator4 = (0, _getIterator3.default)(domNodeSelectors[_name2].split(match[0])), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                                var _selectorPart = _step4.value;\n\n                                domNodeSelectors[_name2] += ', ' + this.normalizeDomNodeSelector(_selectorPart);\n                            }\n                        } catch (err) {\n                            _didIteratorError4 = true;\n                            _iteratorError4 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                    _iterator4.return();\n                                }\n                            } finally {\n                                if (_didIteratorError4) {\n                                    throw _iteratorError4;\n                                }\n                            }\n                        }\n                    }domNodes[_name2] = $(this.normalizeDomNodeSelector(domNodeSelectors[_name2]));\n                }\n            }if (this._options.domNodeSelectorPrefix) domNodes.parent = $(this._options.domNodeSelectorPrefix);\n            if ('window' in $.global) domNodes.window = $($.global.window);\n            if ('document' in $.global) domNodes.document = $($.global.document);\n            return domNodes;\n        }\n        // / endregion\n        // / region scope\n        /**\n         * Overwrites all inherited variables from parent scope with \"undefined\".\n         * @param scope - A scope where inherited names will be removed.\n         * @param prefixesToIgnore - Name prefixes to ignore during deleting names\n         * in given scope.\n         * @returns The isolated scope.\n         */\n\n    }, {\n        key: 'getMethod',\n\n        // / endregion\n        // / region function\n        /**\n         * Methods given by this method has the plugin scope referenced with\n         * \"this\". Otherwise \"this\" usually points to the object the given method\n         * was attached to. If \"method\" doesn't match string arguments are passed\n         * through a wrapper function with \"context\" setted as \"scope\" or \"this\" if\n         * nothing is provided.\n         * @param method - A method name of given scope.\n         * @param scope - A given scope.\n         * @param additionalArguments - A list of additional arguments to forward\n         * to given function, when it should be called.\n         * @returns Returns the given methods return value.\n         */\n        value: function getMethod(method) {\n            for (var _len7 = arguments.length, additionalArguments = Array(_len7 > 2 ? _len7 - 2 : 0), _key8 = 2; _key8 < _len7; _key8++) {\n                additionalArguments[_key8 - 2] = arguments[_key8];\n            }\n\n            var scope = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n            /*\n                This following outcomment line would be responsible for a bug in\n                yuicompressor. Because of declaration of arguments the parser\n                things that arguments is a local variable and could be renamed. It\n                doesn't care about that the magic arguments object is necessary to\n                generate the arguments array in this context.\n                 var arguments = this.constructor.arrayMake(arguments)\n            */\n            if (!scope) scope = this;\n            if (typeof method === 'string' && (typeof scope === 'undefined' ? 'undefined' : (0, _typeof3.default)(scope)) === 'object') return function () {\n                if (!scope[method] && typeof method === 'string') throw Error('Method \"' + method + '\" doesn\\'t exists in \"' + scope + '\".');\n                return scope[method].apply(scope, additionalArguments.concat(this.constructor.arrayMake(arguments)));\n            };\n            var self = this;\n            return function () {\n                // IgnoreTypeCheck\n                return method.apply(scope, self.constructor.arrayMake(arguments).concat(additionalArguments));\n            };\n        }\n        /**\n         * Implements the identity function.\n         * @param value - A value to return.\n         * @returns Returns the given value.\n         */\n\n    }, {\n        key: 'fireEvent',\n\n        /**\n         * Searches for internal event handler methods and runs them by default. In\n         * addition this method searches for a given event method by the options\n         * object. Additional arguments are forwarded to respective event\n         * functions.\n         * @param eventName - An event name.\n         * @param callOnlyOptionsMethod - Prevents from trying to call an internal\n         * event handler.\n         * @param scope - The scope from where the given event handler should be\n         * called.\n         * @param additionalArguments - Additional arguments to forward to\n         * corresponding event handlers.\n         * @returns - Returns \"true\" if an options event handler was called and\n         * \"false\" otherwise.\n         */\n        value: function fireEvent(eventName) {\n            var callOnlyOptionsMethod = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n            var scope = arguments.length <= 2 || arguments[2] === undefined ? this : arguments[2];\n\n            var eventHandlerName = 'on' + this.constructor.stringCapitalize(eventName);\n\n            for (var _len8 = arguments.length, additionalArguments = Array(_len8 > 3 ? _len8 - 3 : 0), _key9 = 3; _key9 < _len8; _key9++) {\n                additionalArguments[_key9 - 3] = arguments[_key9];\n            }\n\n            if (!callOnlyOptionsMethod) if (eventHandlerName in scope) scope[eventHandlerName].apply(scope, additionalArguments);else if ('_' + eventHandlerName in scope) scope['_' + eventHandlerName].apply(scope, additionalArguments);\n            if (scope._options && eventHandlerName in scope._options) {\n                scope._options[eventHandlerName].apply(scope, additionalArguments);\n                return true;\n            }\n            return false;\n        }\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * A wrapper method for \"$.on()\". It sets current plugin name as event\n         * scope if no scope is given. Given arguments are modified and passed\n         * through \"$.on()\".\n         * @returns Returns $'s grabbed dom node.\n         */\n\n    }, {\n        key: 'on',\n        value: function on() {\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            return this._bindEventHelper(arguments, false);\n        }\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * A wrapper method fo \"$.off()\". It sets current plugin name as event\n         * scope if no scope is given. Given arguments are modified and passed\n         * through \"$.off()\".\n         * @returns Returns $'s grabbed dom node.\n         */\n\n    }, {\n        key: 'off',\n        value: function off() {\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            return this._bindEventHelper(arguments, true, 'off');\n        }\n        // / endregion\n        // / region object\n        /**\n         * Determine the internal JavaScript [[Class]] of an object.\n         * @param object - Object to analyze.\n         * @returns Name of determined class.\n         */\n\n    }, {\n        key: 'normalizeDomNodeSelector',\n\n        /**\n         * Converts a dom selector to a prefixed dom selector string.\n         * @param selector - A dom node selector.\n         * @returns Returns given selector prefixed.\n         */\n        value: function normalizeDomNodeSelector(selector) {\n            var domNodeSelectorPrefix = '';\n            if (this._options.domNodeSelectorPrefix) domNodeSelectorPrefix = this._options.domNodeSelectorPrefix + ' ';\n            if (!(selector.startsWith(domNodeSelectorPrefix) || selector.trim().startsWith('<'))) selector = domNodeSelectorPrefix + selector;\n            return selector.trim();\n        }\n        // / endregion\n        // / region number\n        /**\n         * Checks if given object is java scripts native \"Number.NaN\" object.\n         * @param object - Object to Check.\n         * @returns Returns whether given value is not a number or not.\n         */\n\n    }, {\n        key: 'sendToExternalURL',\n\n        /**\n         * Send given data to a temporary created iframe.\n         * @param url - URL to send to data to.\n         * @param data - Data holding object to send data to.\n         * @param requestType - The forms action attribute value. If nothing is\n         * provided \"post\" will be used as default.\n         * @param removeAfterLoad - Indicates if created iframe should be removed\n         * right after load event.\n         * @returns Returns the dynamically created iframe.\n         */\n        value: function sendToExternalURL(url, data) {\n            var requestType = arguments.length <= 2 || arguments[2] === undefined ? 'post' : arguments[2];\n            var removeAfterLoad = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n            var $iFrameDomNode = $('<iframe>').attr('name', this.constructor._name.charAt(0).toLowerCase() + this.constructor._name.substring(1) + new Date().getTime()).hide();\n            this.$domNode.after($iFrameDomNode);\n            return this.constructor.sendToIFrame($iFrameDomNode, url, data, requestType, removeAfterLoad);\n        }\n        // / endregion\n        // endregion\n        // region protected\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Helper method for attach event handler methods and their event handler\n         * remove pendants.\n         * @param parameter - Arguments object given to methods like \"bind()\" or\n         * \"unbind()\".\n         * @param removeEvent - Indicates if \"unbind()\" or \"bind()\" was given.\n         * @param eventFunctionName - Name of function to wrap.\n         * @returns Returns $'s wrapped dom node.\n         */\n\n    }, {\n        key: '_bindEventHelper',\n        value: function _bindEventHelper(parameter) {\n            var removeEvent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n            var eventFunctionName = arguments.length <= 2 || arguments[2] === undefined ? 'on' : arguments[2];\n\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            var $domNode = $(parameter[0]);\n            if (this.constructor.determineType(parameter[1]) === 'object' && !removeEvent) {\n                for (var eventType in parameter[1]) {\n                    if (parameter[1].hasOwnProperty(eventType))\n                        // IgnoreTypeCheck\n                        this[eventFunctionName]($domNode, eventType, parameter[1][eventType]);\n                }return $domNode;\n            }\n            parameter = this.constructor.arrayMake(parameter).slice(1);\n            if (parameter.length === 0) parameter.push('');\n            if (!parameter[0].includes('.')) parameter[0] += '.' + this.constructor._name;\n            if (removeEvent) return $domNode[eventFunctionName].apply($domNode, parameter);\n            return $domNode[eventFunctionName].apply($domNode, parameter);\n        }\n        // endregion\n\n    }], [{\n        key: 'isNumeric',\n        value: function isNumeric(object) {\n            var type = Tools.determineType(object);\n            /*\n                NOTE: \"parseFloat\" \"NaNs\" numeric-cast false positives (\"\") but\n                misinterprets leading-number strings, particularly hex literals\n                (\"0x...\") subtraction forces infinities to NaN.\n            */\n            return ['number', 'string'].includes(type) && !isNaN(object - parseFloat(object));\n        }\n        /**\n         * Determine whether the argument is a window.\n         * @param object - Object to check for.\n         * @returns Boolean value indicating the result.\n         */\n\n    }, {\n        key: 'isWindow',\n        value: function isWindow(object) {\n            return ![undefined, null].includes(object) && (typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) === 'object' && 'window' in object && object === object.window;\n        }\n        /**\n         * Checks if given object is similar to an array and can be handled like an\n         * array.\n         * @param object - Object to check behavior for.\n         * @returns A boolean value indicating whether given object is array like.\n         */\n\n    }, {\n        key: 'isArrayLike',\n        value: function isArrayLike(object) {\n            var length = void 0;\n            try {\n                length = Boolean(object) && 'length' in object && object.length;\n            } catch (error) {\n                return false;\n            }\n            var type = Tools.determineType(object);\n            if (type === 'function' || Tools.isWindow(object)) return false;\n            if (type === 'array' || length === 0) return true;\n            if (typeof length === 'number' && length > 0) try {\n                /* eslint-disable no-unused-expressions */\n                object[length - 1];\n                /* eslint-enable no-unused-expressions */\n                return true;\n            } catch (error) {}\n            return false;\n        }\n        /**\n         * Checks whether one of the given pattern matches given string.\n         * @param target - Target to check in pattern for.\n         * @param pattern - List of pattern to check for.\n         * @returns Value \"true\" if given object is matches by at leas one of the\n         * given pattern and \"false\" otherwise.\n         */\n\n    }, {\n        key: 'isAnyMatching',\n        value: function isAnyMatching(target, pattern) {\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = (0, _getIterator3.default)(pattern), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var currentPattern = _step5.value;\n\n                    if (typeof currentPattern === 'string') {\n                        if (currentPattern === target) return true;\n                    } else if (currentPattern.test(target)) return true;\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            return false;\n        }\n        /**\n         * Checks whether given object is a plain native object.\n         * @param object - Object to check.\n         * @returns Value \"true\" if given object is a plain javaScript object and\n         * \"false\" otherwise.\n         */\n\n    }, {\n        key: 'isPlainObject',\n        value: function isPlainObject(object) {\n            return (typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) === 'object' && object !== null && (0, _getPrototypeOf2.default)(object) === Object.prototype;\n        }\n        /**\n         * Checks whether given object is a function.\n         * @param object - Object to check.\n         * @returns Value \"true\" if given object is a function and \"false\"\n         * otherwise.\n         */\n\n    }, {\n        key: 'isFunction',\n        value: function isFunction(object) {\n            return Boolean(object) && {}.toString.call(object) === '[object Function]';\n        }\n        // / endregion\n        // / region language fixes\n        /**\n         * This method fixes an ugly javaScript bug. If you add a mouseout event\n         * listener to a dom node the given handler will be called each time any\n         * dom node inside the observed dom node triggers a mouseout event. This\n         * methods guarantees that the given event handler is only called if the\n         * observed dom node was leaved.\n         * @param eventHandler - The mouse out event handler.\n         * @returns Returns the given function wrapped by the workaround logic.\n         */\n\n    }, {\n        key: 'mouseOutEventHandlerFix',\n        value: function mouseOutEventHandlerFix(eventHandler) {\n            var self = this;\n            return function (event) {\n                var relatedTarget = event.toElement;\n                if ('relatedTarget' in event) relatedTarget = event.relatedTarget;\n                while (relatedTarget && relatedTarget.tagName !== 'BODY') {\n                    if (relatedTarget === this) return;\n                    relatedTarget = relatedTarget.parentNode;\n                }\n                return eventHandler.apply(self, arguments);\n            };\n        }\n    }, {\n        key: 'show',\n        value: function show(object) {\n            var level = arguments.length <= 1 || arguments[1] === undefined ? 3 : arguments[1];\n            var currentLevel = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n            var output = '';\n            if (Tools.determineType(object) === 'object') {\n                for (var _key10 in object) {\n                    if (object.hasOwnProperty(_key10)) {\n                        output += _key10.toString() + ': ';\n                        if (currentLevel <= level) output += Tools.show(object[_key10], level, currentLevel + 1);else output += '' + object[_key10];\n                        output += '\\n';\n                    }\n                }return output.trim();\n            }\n            output = ('' + object).trim();\n            return output + ' (Type: \"' + Tools.determineType(object) + '\")';\n        }\n    }, {\n        key: 'isEquivalentDom',\n        value: function isEquivalentDom(first, second) {\n            var forceHTMLString = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n            if (first === second) return true;\n            if (first && second) {\n                var detemermineHTMLPattern = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\n                var inputs = { first: first, second: second };\n                var $domNodes = {\n                    first: $('<dummy>'), second: $('<dummy>')\n                };\n                /*\n                    NOTE: Assume that strings that start \"<\" and end with \">\" are\n                    markup and skip the more expensive regular expression check.\n                */\n                var _arr2 = ['first', 'second'];\n                for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n                    var type = _arr2[_i2];\n                    if (typeof inputs[type] === 'string' && (forceHTMLString || inputs[type].startsWith('<') && inputs[type].endsWith('>') && inputs[type].length >= 3 || detemermineHTMLPattern.test(inputs[type]))) $domNodes[type] = $('<div>' + inputs[type] + '</div>');else try {\n                        var $selectedDomNode = $(inputs[type]);\n                        if ($selectedDomNode.length) $domNodes[type] = $('<div>').append($selectedDomNode.clone());else return false;\n                    } catch (error) {\n                        return false;\n                    }\n                }if ($domNodes.first.length && $domNodes.first.length === $domNodes.second.length) {\n                    $domNodes.first = $domNodes.first.Tools('normalizeClassNames').$domNode.Tools('normalizeStyles').$domNode;\n                    $domNodes.second = $domNodes.second.Tools('normalizeClassNames').$domNode.Tools('normalizeStyles').$domNode;\n                    var index = 0;\n                    var _iteratorNormalCompletion6 = true;\n                    var _didIteratorError6 = false;\n                    var _iteratorError6 = undefined;\n\n                    try {\n                        for (var _iterator6 = (0, _getIterator3.default)($domNodes.first), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                            var _domNode = _step6.value;\n\n                            if (!_domNode.isEqualNode($domNodes.second[index])) return false;\n                        }\n                    } catch (err) {\n                        _didIteratorError6 = true;\n                        _iteratorError6 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                _iterator6.return();\n                            }\n                        } finally {\n                            if (_didIteratorError6) {\n                                throw _iteratorError6;\n                            }\n                        }\n                    }\n\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'generateDirectiveSelector',\n        value: function generateDirectiveSelector(directiveName) {\n            var delimitedName = Tools.stringCamelCaseToDelimited(directiveName);\n            return delimitedName + ', .' + delimitedName + ', [' + delimitedName + '], ' + ('[data-' + delimitedName + '], [x-' + delimitedName + ']') + (delimitedName.includes('-') ? ', [' + delimitedName.replace(/-/g, '\\\\:') + '], ' + ('[' + delimitedName.replace(/-/g, '_') + ']') : '');\n        }\n    }, {\n        key: 'getNormalizedDirectiveName',\n        value: function getNormalizedDirectiveName(directiveName) {\n            var _arr3 = ['-', ':', '_'];\n\n            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n                var delimiter = _arr3[_i3];\n                var prefixFound = false;\n                var _arr5 = ['data' + delimiter, 'x' + delimiter];\n                for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n                    var prefix = _arr5[_i5];\n                    if (directiveName.startsWith(prefix)) {\n                        directiveName = directiveName.substring(prefix.length);\n                        prefixFound = true;\n                        break;\n                    }\n                }if (prefixFound) break;\n            }\n            var _arr4 = ['-', ':', '_'];\n            for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n                var _delimiter = _arr4[_i4];\n                directiveName = Tools.stringDelimitedToCamelCase(directiveName, _delimiter);\n            }return directiveName;\n        }\n    }, {\n        key: 'getDomNodeName',\n        value: function getDomNodeName(domNodeSelector) {\n            var match = domNodeSelector.match(new RegExp('^<?([a-zA-Z]+).*>?.*'));\n            if (match) return match[1];\n            return null;\n        }\n    }, {\n        key: 'isolateScope',\n        value: function isolateScope(scope) {\n            var prefixesToIgnore = arguments.length <= 1 || arguments[1] === undefined ? ['$', '_'] : arguments[1];\n\n            for (var _name3 in scope) {\n                if (!(prefixesToIgnore.includes(_name3.charAt(0)) || ['this', 'constructor'].includes(_name3) || scope.hasOwnProperty(_name3)))\n                    /*\n                        NOTE: Delete (\"delete $scope[name]\") doesn't destroy the\n                        automatic lookup to parent scope.\n                    */\n                    scope[_name3] = undefined;\n            }return scope;\n        }\n        /**\n         * Generates a unique name in given scope (usefull for jsonp requests).\n         * @param prefix - A prefix which will be preprended to uniqe name.\n         * @param suffix - A suffix which will be preprended to uniqe name.\n         * @param scope - A scope where the name should be unique.\n         * @param initialUniqueName - An initial scope name to use if not exists.\n         * @returns The function name.\n         */\n\n    }, {\n        key: 'determineUniqueScopeName',\n        value: function determineUniqueScopeName() {\n            var prefix = arguments.length <= 0 || arguments[0] === undefined ? 'callback' : arguments[0];\n            var suffix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n            var scope = arguments.length <= 2 || arguments[2] === undefined ? $.global : arguments[2];\n            var initialUniqueName = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];\n\n            if (initialUniqueName.length && !(initialUniqueName in scope)) return initialUniqueName;\n            var uniqueName = prefix + suffix;\n            while (true) {\n                uniqueName = prefix + parseInt(Math.random() * Math.pow(10, 10), 10) + suffix;\n                if (!(uniqueName in scope)) break;\n            }\n            return uniqueName;\n        }\n    }, {\n        key: 'identity',\n        value: function identity(value) {\n            return value;\n        }\n        /**\n         * Inverted filter helper to inverse each given filter.\n         * @param filter - A function that filters an array.\n         * @returns The inverted filter.\n         */\n\n    }, {\n        key: 'invertArrayFilter',\n        value: function invertArrayFilter(filter) {\n            return function (data) {\n                if (data) {\n                    var filteredData = filter.apply(this, arguments);\n                    var result = [];\n                    /* eslint-disable curly */\n                    if (filteredData.length) {\n                        var _iteratorNormalCompletion7 = true;\n                        var _didIteratorError7 = false;\n                        var _iteratorError7 = undefined;\n\n                        try {\n                            for (var _iterator7 = (0, _getIterator3.default)(data), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                                var date = _step7.value;\n\n                                if (!filteredData.includes(date)) result.push(date);\n                            }\n                        } catch (err) {\n                            _didIteratorError7 = true;\n                            _iteratorError7 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                    _iterator7.return();\n                                }\n                            } finally {\n                                if (_didIteratorError7) {\n                                    throw _iteratorError7;\n                                }\n                            }\n                        }\n                    } else\n                        /* eslint-enable curly */\n                        result = data;\n                    return result;\n                }\n                return data;\n            };\n        }\n        // / endregion\n        // / region event\n        /**\n         * Prevents event functions from triggering to often by defining a minimal\n         * span between each function call. Additional arguments given to this\n         * function will be forwarded to given event function call. The function\n         * wrapper returns null if current function will be omitted due to\n         * debounceing.\n         * @param eventFunction - The function to call debounced.\n         * @param thresholdInMilliseconds - The minimum time span between each\n         * function call.\n         * @param additionalArguments - Additional arguments to forward to given\n         * function.\n         * @returns Returns the wrapped method.\n         */\n\n    }, {\n        key: 'debounce',\n        value: function debounce(eventFunction) {\n            for (var _len9 = arguments.length, additionalArguments = Array(_len9 > 2 ? _len9 - 2 : 0), _key11 = 2; _key11 < _len9; _key11++) {\n                additionalArguments[_key11 - 2] = arguments[_key11];\n            }\n\n            var thresholdInMilliseconds = arguments.length <= 1 || arguments[1] === undefined ? 600 : arguments[1];\n\n            var lock = false;\n            var waitingCallArguments = null;\n            var timeoutID = null;\n            return function () {\n                var _this2 = this;\n\n                var parameter = Tools.arrayMake(arguments);\n                if (lock) waitingCallArguments = parameter.concat(additionalArguments || []);else {\n                    lock = true;\n                    timeoutID = setTimeout(function () {\n                        lock = false;\n                        if (waitingCallArguments) {\n                            eventFunction.apply(_this2, waitingCallArguments);\n                            waitingCallArguments = null;\n                        }\n                    }, thresholdInMilliseconds);\n                    eventFunction.apply(this, parameter.concat(additionalArguments || []));\n                }\n                return timeoutID;\n            };\n        }\n    }, {\n        key: 'determineType',\n        value: function determineType() {\n            var object = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\n            if ([undefined, null].includes(object)) return '' + object;\n            if (['object', 'function'].includes(typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) && 'toString' in object) {\n                var stringRepresentation = Tools.classToTypeMapping.toString.call(object);\n                if (Tools.classToTypeMapping.hasOwnProperty(stringRepresentation)) return Tools.classToTypeMapping[stringRepresentation];\n            }\n            return typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object);\n        }\n        /**\n         * Replaces given pattern in each value in given object recursively with\n         * given string replacement.\n         * @param object - Object to convert substrings in.\n         * @param pattern - Regular expression to replace.\n         * @param replacement - String to use as replacement for found patterns.\n         * @returns Converted object with replaced patterns.\n         */\n\n    }, {\n        key: 'convertSubstringInPlainObject',\n        value: function convertSubstringInPlainObject(object, pattern, replacement) {\n            for (var _key12 in object) {\n                if (object.hasOwnProperty(_key12)) if (Tools.isPlainObject(object[_key12])) object[_key12] = Tools.convertSubstringInPlainObject(object[_key12], pattern, replacement);else if (typeof object[_key12] === 'string') object[_key12] = object[_key12].replace(pattern, replacement);\n            }return object;\n        }\n        /**\n         * Extends given target object with given sources object. As target and\n         * sources many expandable types are allowed but target and sources have to\n         * to come from the same type.\n         * @param targetOrDeepIndicator - Maybe the target or deep indicator.\n         * @param _targetAndOrSources - Target and at least one source object.\n         * @returns Returns given target extended with all given sources.\n         */\n\n    }, {\n        key: 'extendObject',\n        value: function extendObject(targetOrDeepIndicator) {\n            for (var _len10 = arguments.length, _targetAndOrSources = Array(_len10 > 1 ? _len10 - 1 : 0), _key13 = 1; _key13 < _len10; _key13++) {\n                _targetAndOrSources[_key13 - 1] = arguments[_key13];\n            }\n\n            var index = 1;\n            var deep = false;\n            var target = void 0;\n            if (typeof targetOrDeepIndicator === 'boolean') {\n                // Handle a deep copy situation and skip deep indicator and target.\n                deep = targetOrDeepIndicator;\n                target = arguments[index];\n                index = 2;\n            } else target = targetOrDeepIndicator;\n            var mergeValue = function mergeValue(key, value, targetValue) {\n                if (value === targetValue) return targetValue;\n                // Recurse if we're merging plain objects or maps.\n                if (deep && value && (Tools.isPlainObject(value) || value instanceof _map2.default)) {\n                    var clone = void 0;\n                    if (value instanceof _map2.default) clone = targetValue && targetValue instanceof _map2.default ? targetValue : new _map2.default();else clone = targetValue && Tools.isPlainObject(targetValue) ? targetValue : {};\n                    return Tools.extendObject(deep, clone, value);\n                }\n                return value;\n            };\n            while (index < arguments.length) {\n                var source = arguments[index];\n                var targetType = typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target);\n                var sourceType = typeof source === 'undefined' ? 'undefined' : (0, _typeof3.default)(source);\n                if (target instanceof _map2.default) targetType += ' Map';\n                if (source instanceof _map2.default) sourceType += ' Map';\n                if (targetType === sourceType && target !== source) {\n                    if (target instanceof _map2.default && source instanceof _map2.default) {\n                        var _iteratorNormalCompletion8 = true;\n                        var _didIteratorError8 = false;\n                        var _iteratorError8 = undefined;\n\n                        try {\n                            for (var _iterator8 = (0, _getIterator3.default)(source), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                                var _step8$value = (0, _slicedToArray3.default)(_step8.value, 2);\n\n                                var _key14 = _step8$value[0];\n                                var _value2 = _step8$value[1];\n\n                                target.set(_key14, mergeValue(_key14, _value2, target.get(_key14)));\n                            }\n                        } catch (err) {\n                            _didIteratorError8 = true;\n                            _iteratorError8 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                                    _iterator8.return();\n                                }\n                            } finally {\n                                if (_didIteratorError8) {\n                                    throw _iteratorError8;\n                                }\n                            }\n                        }\n                    } else if (target !== null && !Array.isArray(target) && (typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && source !== null && !Array.isArray(source) && (typeof source === 'undefined' ? 'undefined' : (0, _typeof3.default)(source)) === 'object') {\n                        for (var _key15 in source) {\n                            if (source.hasOwnProperty(_key15)) target[_key15] = mergeValue(_key15, source[_key15], target[_key15]);\n                        }\n                    } else target = source;\n                } else target = source;\n                index += 1;\n            }\n            return target;\n        }\n        /**\n         * Removes a proxies from given data structure recursivley.\n         * @param object - Object to proxy.\n         * @param seenObjects - Tracks all already processed obejcts to avoid\n         * endless loops (usually only needed for internal prupose).\n         * @returns Returns given object unwrapped from a dynamic proxy.\n         */\n\n    }, {\n        key: 'unwrapProxy',\n        value: function unwrapProxy(object) {\n            var seenObjects = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n            if (object !== null && (typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) === 'object') {\n                while (object.__target__) {\n                    object = object.__target__;\n                }var index = seenObjects.indexOf(object);\n                if (index !== -1) return seenObjects[index];\n                seenObjects.push(object);\n                if (Array.isArray(object)) {\n                    var _index = 0;\n                    var _iteratorNormalCompletion9 = true;\n                    var _didIteratorError9 = false;\n                    var _iteratorError9 = undefined;\n\n                    try {\n                        for (var _iterator9 = (0, _getIterator3.default)(object), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                            var _value3 = _step9.value;\n\n                            object[_index] = Tools.unwrapProxy(_value3, seenObjects);\n                            _index += 1;\n                        }\n                    } catch (err) {\n                        _didIteratorError9 = true;\n                        _iteratorError9 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                                _iterator9.return();\n                            }\n                        } finally {\n                            if (_didIteratorError9) {\n                                throw _iteratorError9;\n                            }\n                        }\n                    }\n                } else if (object instanceof _map2.default) {\n                    var _iteratorNormalCompletion10 = true;\n                    var _didIteratorError10 = false;\n                    var _iteratorError10 = undefined;\n\n                    try {\n                        for (var _iterator10 = (0, _getIterator3.default)(object), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                            var _step10$value = (0, _slicedToArray3.default)(_step10.value, 2);\n\n                            var _key16 = _step10$value[0];\n                            var _value4 = _step10$value[1];\n\n                            object.set(_key16, Tools.unwrapProxy(_value4, seenObjects));\n                        }\n                    } catch (err) {\n                        _didIteratorError10 = true;\n                        _iteratorError10 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                                _iterator10.return();\n                            }\n                        } finally {\n                            if (_didIteratorError10) {\n                                throw _iteratorError10;\n                            }\n                        }\n                    }\n                } else for (var _key17 in object) {\n                    if (object.hasOwnProperty(_key17)) object[_key17] = Tools.unwrapProxy(object[_key17], seenObjects);\n                }\n            }\n            return object;\n        }\n        /**\n         * Adds dynamic getter and setter to any given data structure such as maps.\n         * @param object - Object to proxy.\n         * @param getterWrapper - Function to wrap each property get.\n         * @param setterWrapper - Function to wrap each property set.\n         * @param getterMethodName - Method name to get a stored value by key.\n         * @param setterMethodName - Method name to set a stored value by key.\n         * @param containesMethodName - Method name to indicate if a key is stored\n         * in given data structure.\n         * @param deep - Indicates to perform a deep wrapping of specified types.\n         * performed via \"value instanceof type\".).\n         * @param typesToExtend - Types which should be extended (Checks are\n         * performed via \"value instanceof type\".).\n         * @returns Returns given object wrapped with a dynamic getter proxy.\n         */\n\n    }, {\n        key: 'addDynamicGetterAndSetter',\n        value: function addDynamicGetterAndSetter(object) {\n            var getterWrapper = arguments.length <= 1 || arguments[1] === undefined ? function (value) {\n                return value;\n            } : arguments[1];\n            var setterWrapper = arguments.length <= 2 || arguments[2] === undefined ? function (key, value) {\n                return value;\n            } : arguments[2];\n            var getterMethodName = arguments.length <= 3 || arguments[3] === undefined ? '[]' : arguments[3];\n            var setterMethodName = arguments.length <= 4 || arguments[4] === undefined ? '[]' : arguments[4];\n            var containesMethodName = arguments.length <= 5 || arguments[5] === undefined ? 'hasOwnProperty' : arguments[5];\n            var deep = arguments.length <= 6 || arguments[6] === undefined ? true : arguments[6];\n            var typesToExtend = arguments.length <= 7 || arguments[7] === undefined ? [Object] : arguments[7];\n\n            if (deep) if (object instanceof _map2.default) {\n                var _iteratorNormalCompletion11 = true;\n                var _didIteratorError11 = false;\n                var _iteratorError11 = undefined;\n\n                try {\n                    for (var _iterator11 = (0, _getIterator3.default)(object), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                        var _step11$value = (0, _slicedToArray3.default)(_step11.value, 2);\n\n                        var _key18 = _step11$value[0];\n                        var _value5 = _step11$value[1];\n\n                        object.set(_key18, Tools.addDynamicGetterAndSetter(_value5, getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend));\n                    }\n                } catch (err) {\n                    _didIteratorError11 = true;\n                    _iteratorError11 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                            _iterator11.return();\n                        }\n                    } finally {\n                        if (_didIteratorError11) {\n                            throw _iteratorError11;\n                        }\n                    }\n                }\n            } else if ((typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) === 'object' && object !== null) {\n                for (var _key19 in object) {\n                    if (object.hasOwnProperty(_key19)) object[_key19] = Tools.addDynamicGetterAndSetter(object[_key19], getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend);\n                }\n            } else if (Array.isArray(object)) {\n                var index = 0;\n                var _iteratorNormalCompletion12 = true;\n                var _didIteratorError12 = false;\n                var _iteratorError12 = undefined;\n\n                try {\n                    for (var _iterator12 = (0, _getIterator3.default)(object), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                        var _value6 = _step12.value;\n\n                        object[index] = Tools.addDynamicGetterAndSetter(_value6, getterWrapper, setterWrapper, getterMethodName, setterMethodName, containesMethodName, deep, typesToExtend);\n                        index += 1;\n                    }\n                } catch (err) {\n                    _didIteratorError12 = true;\n                    _iteratorError12 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                            _iterator12.return();\n                        }\n                    } finally {\n                        if (_didIteratorError12) {\n                            throw _iteratorError12;\n                        }\n                    }\n                }\n            }\n            var _iteratorNormalCompletion13 = true;\n            var _didIteratorError13 = false;\n            var _iteratorError13 = undefined;\n\n            try {\n                for (var _iterator13 = (0, _getIterator3.default)(typesToExtend), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                    var type = _step13.value;\n\n                    if (object instanceof type) {\n                        if (object.__target__) return object;\n                        var handler = {};\n                        if (containesMethodName) handler.has = function (target, name) {\n                            if (containesMethodName === '[]') return name in target;\n                            return target[containesMethodName](name);\n                        };\n                        if (containesMethodName && getterMethodName) handler.get = function (target, name) {\n                            if (name === '__target__') return target;\n                            if (typeof target[name] === 'function') return target[name].bind(target);\n                            if (target[containesMethodName](name)) {\n                                if (getterMethodName === '[]') return getterWrapper(target[name]);\n                                return getterWrapper(target[getterMethodName](name));\n                            }\n                            return target[name];\n                        };\n                        if (setterMethodName) handler.set = function (target, name, value) {\n                            if (setterMethodName === '[]') target[name] = setterWrapper(name, value);else target[setterMethodName](name, setterWrapper(name, value));\n                        };\n                        // IgnoreTypeCheck\n                        return new Proxy(object, handler);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError13 = true;\n                _iteratorError13 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                        _iterator13.return();\n                    }\n                } finally {\n                    if (_didIteratorError13) {\n                        throw _iteratorError13;\n                    }\n                }\n            }\n\n            return object;\n        }\n        /**\n         * Searches for nested mappings with given indicator key and resolves\n         * marked values. Additionally all objects are wrapped with a proxy to\n         * dynamically resolve nested properties.\n         * @param object - Given mapping to resolve.\n         * @param parameterDescription - Array of scope names.\n         * @param parameter - Array of values for given scope names. If there is\n         * one missing given object will be added.\n         * @param deep - Indicates whether to perform a recursive resolving.\n         * @param evaluationIndicatorKey - Indicator property name to mark a value\n         * to evaluate.\n         * @param executionIndicatorKey - Indicator property name to mark a value\n         * to evaluate.\n         * @returns Evaluated given mapping.\n         */\n\n    }, {\n        key: 'resolveDynamicDataStructure',\n        value: function resolveDynamicDataStructure(object) {\n            var parameterDescription = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n            var parameter = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n            var deep = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n            var evaluationIndicatorKey = arguments.length <= 4 || arguments[4] === undefined ? '__evaluate__' : arguments[4];\n            var executionIndicatorKey = arguments.length <= 5 || arguments[5] === undefined ? '__execute__' : arguments[5];\n\n            if (object === null || (typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) !== 'object') return object;\n            var configuration = object;\n            if (deep && configuration && !configuration.__target__) configuration = Tools.addDynamicGetterAndSetter(Tools.copyLimitedRecursively(object), function (value) {\n                return Tools.resolveDynamicDataStructure(value, parameterDescription, parameter, false, evaluationIndicatorKey, executionIndicatorKey);\n            }, function (key, value) {\n                return value;\n            }, '[]', '');\n            if (parameterDescription.length > parameter.length) parameter.push(configuration);\n            if (Array.isArray(object) && deep) {\n                var index = 0;\n                var _iteratorNormalCompletion14 = true;\n                var _didIteratorError14 = false;\n                var _iteratorError14 = undefined;\n\n                try {\n                    for (var _iterator14 = (0, _getIterator3.default)(object), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                        var _value7 = _step14.value;\n\n                        object[index] = Tools.resolveDynamicDataStructure(_value7, parameterDescription, parameter, deep, evaluationIndicatorKey, executionIndicatorKey);\n                        index += 1;\n                    }\n                } catch (err) {\n                    _didIteratorError14 = true;\n                    _iteratorError14 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                            _iterator14.return();\n                        }\n                    } finally {\n                        if (_didIteratorError14) {\n                            throw _iteratorError14;\n                        }\n                    }\n                }\n            } else for (var _key20 in object) {\n                if (object.hasOwnProperty(_key20)) if ([evaluationIndicatorKey, executionIndicatorKey].includes(_key20)) try {\n                    return Tools.resolveDynamicDataStructure(new (\n                    // IgnoreTypeCheck\n                    Function.prototype.bind.apply(Function, [null].concat(parameterDescription).concat((_key20 === evaluationIndicatorKey ? 'return ' : '') + object[_key20])))().apply(null, parameter), parameterDescription, parameter, false, evaluationIndicatorKey, executionIndicatorKey);\n                } catch (error) {\n                    throw Error('Error during ' + (_key20 === evaluationIndicatorKey ? 'executing' : 'evaluating') + (' \"' + object[_key20] + '\": ' + error));\n                } else if (deep) object[_key20] = Tools.resolveDynamicDataStructure(object[_key20], parameterDescription, parameter, deep, evaluationIndicatorKey, executionIndicatorKey);\n            }return object;\n        }\n        /**\n         * Converts given object into its serialized json representation by\n         * replacing circular references with a given provided value.\n         * @param object - Object to serialize.\n         * @param determineCicularReferenceValue - Callback to create a fallback\n         * value depending on given redundant value.\n         * @param numberOfSpaces - Number of spaces to use for string formatting.\n         */\n\n    }, {\n        key: 'convertCircularObjectToJSON',\n        value: function convertCircularObjectToJSON(object) {\n            var determineCicularReferenceValue = arguments.length <= 1 || arguments[1] === undefined ? function () {\n                return '__circularReference__';\n            } : arguments[1];\n            var numberOfSpaces = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n            var seenObjects = [];\n            return (0, _stringify2.default)(object, function (key, value) {\n                if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && value !== null) {\n                    if (seenObjects.includes(value)) return determineCicularReferenceValue(key, value, seenObjects);\n                    seenObjects.push(value);\n                    return value;\n                }\n                return value;\n            }, numberOfSpaces);\n        }\n        /**\n         * Converts given plain object and all nested found objects to\n         * corresponding map.\n         * @param object - Object to convert to.\n         * @param deep - Indicates whether to perform a recursive conversion.\n         * @returns Given object as map.\n         */\n\n    }, {\n        key: 'convertPlainObjectToMap',\n        value: function convertPlainObjectToMap(object) {\n            var deep = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n            if ((typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) === 'object' && Tools.isPlainObject(object)) {\n                var newObject = new _map2.default();\n                for (var _key21 in object) {\n                    if (object.hasOwnProperty(_key21)) {\n                        if (deep) object[_key21] = Tools.convertPlainObjectToMap(object[_key21], deep);\n                        newObject.set(_key21, object[_key21]);\n                    }\n                }return newObject;\n            }\n            if (deep) if (Array.isArray(object)) {\n                var index = 0;\n                var _iteratorNormalCompletion15 = true;\n                var _didIteratorError15 = false;\n                var _iteratorError15 = undefined;\n\n                try {\n                    for (var _iterator15 = (0, _getIterator3.default)(object), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                        var _value8 = _step15.value;\n\n                        object[index] = Tools.convertPlainObjectToMap(_value8, deep);\n                        index += 1;\n                    }\n                } catch (err) {\n                    _didIteratorError15 = true;\n                    _iteratorError15 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion15 && _iterator15.return) {\n                            _iterator15.return();\n                        }\n                    } finally {\n                        if (_didIteratorError15) {\n                            throw _iteratorError15;\n                        }\n                    }\n                }\n            } else if (object instanceof _map2.default) {\n                var _iteratorNormalCompletion16 = true;\n                var _didIteratorError16 = false;\n                var _iteratorError16 = undefined;\n\n                try {\n                    for (var _iterator16 = (0, _getIterator3.default)(object), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                        var _step16$value = (0, _slicedToArray3.default)(_step16.value, 2);\n\n                        var _key22 = _step16$value[0];\n                        var _value9 = _step16$value[1];\n\n                        object.set(_key22, Tools.convertPlainObjectToMap(_value9, deep));\n                    }\n                } catch (err) {\n                    _didIteratorError16 = true;\n                    _iteratorError16 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion16 && _iterator16.return) {\n                            _iterator16.return();\n                        }\n                    } finally {\n                        if (_didIteratorError16) {\n                            throw _iteratorError16;\n                        }\n                    }\n                }\n            }\n            return object;\n        }\n        /**\n         * Converts given map and all nested found maps objects to corresponding\n         * object.\n         * @param object - Map to convert to.\n         * @param deep - Indicates whether to perform a recursive conversion.\n         * @returns Given map as object.\n         */\n\n    }, {\n        key: 'convertMapToPlainObject',\n        value: function convertMapToPlainObject(object) {\n            var deep = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n            if (object instanceof _map2.default) {\n                var newObject = {};\n                var _iteratorNormalCompletion17 = true;\n                var _didIteratorError17 = false;\n                var _iteratorError17 = undefined;\n\n                try {\n                    for (var _iterator17 = (0, _getIterator3.default)(object), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n                        var _step17$value = (0, _slicedToArray3.default)(_step17.value, 2);\n\n                        var _key23 = _step17$value[0];\n                        var _value10 = _step17$value[1];\n\n                        if (deep) _value10 = Tools.convertMapToPlainObject(_value10, deep);\n                        newObject['' + _key23] = _value10;\n                    }\n                } catch (err) {\n                    _didIteratorError17 = true;\n                    _iteratorError17 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion17 && _iterator17.return) {\n                            _iterator17.return();\n                        }\n                    } finally {\n                        if (_didIteratorError17) {\n                            throw _iteratorError17;\n                        }\n                    }\n                }\n\n                return newObject;\n            }\n            if (deep) if ((typeof object === 'undefined' ? 'undefined' : (0, _typeof3.default)(object)) === 'object' && Tools.isPlainObject(object)) {\n                for (var _key24 in object) {\n                    if (object.hasOwnProperty(_key24)) object[_key24] = Tools.convertMapToPlainObject(object[_key24], deep);\n                }\n            } else if (Array.isArray(object)) {\n                var index = 0;\n                var _iteratorNormalCompletion18 = true;\n                var _didIteratorError18 = false;\n                var _iteratorError18 = undefined;\n\n                try {\n                    for (var _iterator18 = (0, _getIterator3.default)(object), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n                        var _value11 = _step18.value;\n\n                        object[index] = Tools.convertMapToPlainObject(_value11, deep);\n                        index += 1;\n                    }\n                } catch (err) {\n                    _didIteratorError18 = true;\n                    _iteratorError18 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion18 && _iterator18.return) {\n                            _iterator18.return();\n                        }\n                    } finally {\n                        if (_didIteratorError18) {\n                            throw _iteratorError18;\n                        }\n                    }\n                }\n            }\n            return object;\n        }\n        /**\n         * Iterates given objects own properties in sorted fashion. For\n         * each key value pair given iterator function will be called with\n         * value and key as arguments.\n         * @param object - Object to iterate.\n         * @param iterator - Function to execute for each key value pair. Value\n         * will be the first and key will be the second argument.\n         * @param context - The \"this\" binding for given iterator function.\n         * @returns List of given sorted keys.\n         */\n\n    }, {\n        key: 'forEachSorted',\n        value: function forEachSorted(object, iterator, context) {\n            var keys = Tools.sort(object);\n            var _iteratorNormalCompletion19 = true;\n            var _didIteratorError19 = false;\n            var _iteratorError19 = undefined;\n\n            try {\n                for (var _iterator19 = (0, _getIterator3.default)(keys), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n                    var _key25 = _step19.value;\n\n                    if (object instanceof _map2.default) iterator.call(context, object.get(_key25), _key25);else if (Array.isArray(object) || object instanceof Object) iterator.call(context, object[_key25], _key25);\n                }\n            } catch (err) {\n                _didIteratorError19 = true;\n                _iteratorError19 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion19 && _iterator19.return) {\n                        _iterator19.return();\n                    }\n                } finally {\n                    if (_didIteratorError19) {\n                        throw _iteratorError19;\n                    }\n                }\n            }\n\n            return keys;\n        }\n        /**\n         * Sort given objects keys.\n         * @param object - Object which keys should be sorted.\n         * @returns Sorted list of given keys.\n         */\n\n    }, {\n        key: 'sort',\n        value: function sort(object) {\n            var keys = [];\n            if (Array.isArray(object)) for (var index = 0; index < object.length; index++) {\n                keys.push(index);\n            } else if (object instanceof _map2.default) {\n                var _iteratorNormalCompletion20 = true;\n                var _didIteratorError20 = false;\n                var _iteratorError20 = undefined;\n\n                try {\n                    for (var _iterator20 = (0, _getIterator3.default)(object), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n                        var _keyValuePair = _step20.value;\n\n                        keys.push(_keyValuePair[0]);\n                    }\n                } catch (err) {\n                    _didIteratorError20 = true;\n                    _iteratorError20 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion20 && _iterator20.return) {\n                            _iterator20.return();\n                        }\n                    } finally {\n                        if (_didIteratorError20) {\n                            throw _iteratorError20;\n                        }\n                    }\n                }\n            } else if (object instanceof Object) for (var _key26 in object) {\n                if (object.hasOwnProperty(_key26)) keys.push(_key26);\n            }return keys.sort();\n        }\n        /**\n         * Returns true if given items are equal for given property list. If\n         * property list isn't set all properties will be checked. All keys which\n         * starts with one of the exception prefixes will be omitted.\n         * @param firstValue - First object to compare.\n         * @param secondValue - Second object to compare.\n         * @param properties - Property names to check. Check all if \"null\" is\n         * selected (default).\n         * @param deep - Recursion depth negative values means infinitely deep\n         * (default).\n         * @param exceptionPrefixes - Property prefixes which indicates properties\n         * to ignore.\n         * @param ignoreFunctions - Indicates whether functions have to be\n         * identical to interpret is as equal. If set to \"true\" two functions will\n         * be assumed to be equal (default).\n         * @returns Value \"true\" if both objects are equal and \"false\" otherwise.\n         */\n\n    }, {\n        key: 'equals',\n        value: function equals(firstValue, secondValue) {\n            var properties = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n            var deep = arguments.length <= 3 || arguments[3] === undefined ? -1 : arguments[3];\n            var exceptionPrefixes = arguments.length <= 4 || arguments[4] === undefined ? ['$', '_'] : arguments[4];\n            var ignoreFunctions = arguments.length <= 5 || arguments[5] === undefined ? true : arguments[5];\n\n            if (ignoreFunctions && Tools.isFunction(firstValue) && Tools.isFunction(secondValue) || firstValue === secondValue || Tools.numberIsNotANumber(firstValue) && Tools.numberIsNotANumber(secondValue) || firstValue instanceof RegExp && secondValue instanceof RegExp && firstValue.toString() === secondValue.toString() || firstValue instanceof Date && secondValue instanceof Date && (isNaN(firstValue.getTime()) && isNaN(secondValue.getTime()) || !isNaN(firstValue.getTime()) && !isNaN(secondValue.getTime()) && firstValue.getTime() === secondValue.getTime())) return true;\n            if (Tools.isPlainObject(firstValue) && Tools.isPlainObject(secondValue) && !(firstValue instanceof RegExp || secondValue instanceof RegExp) || Array.isArray(firstValue) && Array.isArray(secondValue) && firstValue.length === secondValue.length) {\n                var _arr6 = [[firstValue, secondValue], [secondValue, firstValue]];\n\n                for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n                    var _arr6$_i = (0, _slicedToArray3.default)(_arr6[_i6], 2);\n\n                    var first = _arr6$_i[0];\n                    var second = _arr6$_i[1];\n\n                    var firstIsArray = Array.isArray(first);\n                    if (firstIsArray && !Array.isArray(second) || first.length !== second.length) return false;\n                    var equal = true;\n                    if (firstIsArray) {\n                        var index = 0;\n                        var _iteratorNormalCompletion21 = true;\n                        var _didIteratorError21 = false;\n                        var _iteratorError21 = undefined;\n\n                        try {\n                            for (var _iterator21 = (0, _getIterator3.default)(first), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n                                var _value12 = _step21.value;\n\n                                if (deep !== 0 && !Tools.equals(_value12, second[index], properties, deep - 1, exceptionPrefixes)) equal = false;\n                                index += 1;\n                            }\n                        } catch (err) {\n                            _didIteratorError21 = true;\n                            _iteratorError21 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion21 && _iterator21.return) {\n                                    _iterator21.return();\n                                }\n                            } finally {\n                                if (_didIteratorError21) {\n                                    throw _iteratorError21;\n                                }\n                            }\n                        }\n                    } else for (var _key27 in first) {\n                        if (first.hasOwnProperty(_key27)) {\n                            if (!equal || properties && !properties.includes(_key27)) break;\n                            var doBreak = false;\n                            var _iteratorNormalCompletion22 = true;\n                            var _didIteratorError22 = false;\n                            var _iteratorError22 = undefined;\n\n                            try {\n                                for (var _iterator22 = (0, _getIterator3.default)(exceptionPrefixes), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n                                    var exceptionPrefix = _step22.value;\n\n                                    if (_key27.toString().startsWith(exceptionPrefix)) {\n                                        doBreak = true;\n                                        break;\n                                    }\n                                }\n                            } catch (err) {\n                                _didIteratorError22 = true;\n                                _iteratorError22 = err;\n                            } finally {\n                                try {\n                                    if (!_iteratorNormalCompletion22 && _iterator22.return) {\n                                        _iterator22.return();\n                                    }\n                                } finally {\n                                    if (_didIteratorError22) {\n                                        throw _iteratorError22;\n                                    }\n                                }\n                            }\n\n                            if (doBreak) break;\n                            if (deep !== 0 && !Tools.equals(first[_key27], second[_key27], properties, deep - 1, exceptionPrefixes)) equal = false;\n                        }\n                    }if (!equal) return false;\n                }\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Copies given object (of any type) into optionally given destination.\n         * @param source - Object to copy.\n         * @param recursionLimit - Specifies how deep we should traverse into given\n         * object recursively.\n         * @param destination - Target to copy source to.\n         * @param stackSource - Internally used to avoid traversing loops.\n         * @param stackDestination - Internally used to avoid traversing loops and\n         * referencing them correctly.\n         * @param recursionLevel - Internally used to track current recursion\n         * level in given source data structure.\n         * @returns Value \"true\" if both objects are equal and \"false\" otherwise.\n         */\n\n    }, {\n        key: 'copyLimitedRecursively',\n        value: function copyLimitedRecursively(source) {\n            var recursionLimit = arguments.length <= 1 || arguments[1] === undefined ? -1 : arguments[1];\n            var destination = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n            var stackSource = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];\n            var stackDestination = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];\n            var recursionLevel = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n\n            if (destination) {\n                if (source === destination) throw Error(\"Can't copy because source and destination are identical.\");\n                if (recursionLimit !== -1 && recursionLimit < recursionLevel) return null;\n                if (![undefined, null].includes(source) && (typeof source === 'undefined' ? 'undefined' : (0, _typeof3.default)(source)) === 'object') {\n                    var index = stackSource.indexOf(source);\n                    if (index !== -1) return stackDestination[index];\n                    stackSource.push(source);\n                    stackDestination.push(destination);\n                }\n                var copyValue = function copyValue(value) {\n                    var result = Tools.copyLimitedRecursively(value, recursionLimit, null, stackSource, stackDestination, recursionLevel + 1);\n                    if (![undefined, null].includes(value) && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object') {\n                        stackSource.push(value);\n                        stackDestination.push(result);\n                    }\n                    return result;\n                };\n                if (Array.isArray(source)) {\n                    var _iteratorNormalCompletion23 = true;\n                    var _didIteratorError23 = false;\n                    var _iteratorError23 = undefined;\n\n                    try {\n                        for (var _iterator23 = (0, _getIterator3.default)(source), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {\n                            var _item = _step23.value;\n\n                            destination.push(copyValue(_item));\n                        }\n                    } catch (err) {\n                        _didIteratorError23 = true;\n                        _iteratorError23 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion23 && _iterator23.return) {\n                                _iterator23.return();\n                            }\n                        } finally {\n                            if (_didIteratorError23) {\n                                throw _iteratorError23;\n                            }\n                        }\n                    }\n                }if (source instanceof _map2.default) {\n                    var _iteratorNormalCompletion24 = true;\n                    var _didIteratorError24 = false;\n                    var _iteratorError24 = undefined;\n\n                    try {\n                        for (var _iterator24 = (0, _getIterator3.default)(source), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {\n                            var _step24$value = (0, _slicedToArray3.default)(_step24.value, 2);\n\n                            var _key28 = _step24$value[0];\n                            var _value13 = _step24$value[1];\n\n                            destination.set(_key28, copyValue(_value13));\n                        }\n                    } catch (err) {\n                        _didIteratorError24 = true;\n                        _iteratorError24 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion24 && _iterator24.return) {\n                                _iterator24.return();\n                            }\n                        } finally {\n                            if (_didIteratorError24) {\n                                throw _iteratorError24;\n                            }\n                        }\n                    }\n                } else for (var _key29 in source) {\n                    if (source.hasOwnProperty(_key29)) destination[_key29] = copyValue(source[_key29]);\n                }\n            } else if (source) {\n                if (Array.isArray(source)) return Tools.copyLimitedRecursively(source, recursionLimit, [], stackSource, stackDestination, recursionLevel);\n                if (source instanceof _map2.default) return Tools.copyLimitedRecursively(source, recursionLimit, new _map2.default(), stackSource, stackDestination, recursionLevel);\n                if (Tools.determineType(source) === 'date') return new Date(source.getTime());\n                if (Tools.determineType(source) === 'regexp') {\n                    destination = new RegExp(source.source, source.toString().match(/[^\\/]*$/)[0]);\n                    destination.lastIndex = source.lastIndex;\n                    return destination;\n                }\n                if (![undefined, null].includes(source) && (typeof source === 'undefined' ? 'undefined' : (0, _typeof3.default)(source)) === 'object') return Tools.copyLimitedRecursively(source, recursionLimit, {}, stackSource, stackDestination, recursionLevel);\n            }\n            return destination || source;\n        }\n        // / endregion\n        // / region array\n        /**\n         * Merge the contents of two arrays together into the first array.\n         * @param target - Target array.\n         * @param source - Source array.\n         * @returns Target array with merged given source one.\n         */\n\n    }, {\n        key: 'arrayMerge',\n        value: function arrayMerge(target, source) {\n            var length = Number(source.length);\n            var sourceIndex = 0;\n            var targetIndex = target.length;\n            for (; sourceIndex < length; sourceIndex++) {\n                target[targetIndex++] = source[sourceIndex];\n            }target.length = targetIndex;\n            return target;\n        }\n        /**\n         * Converts given object into an array.\n         * @param object - Target to convert.\n         * @returns Generated array.\n         */\n\n    }, {\n        key: 'arrayMake',\n        value: function arrayMake(object) {\n            var result = [];\n            if (![null, undefined].includes(result)) if (Tools.isArrayLike(Object(object))) Tools.arrayMerge(result, typeof object === 'string' ? [object] : object);else result.push(object);\n            return result;\n        }\n        /**\n         * Makes all values in given iterable unique by removing duplicates (The\n         * first occurrences will be left).\n         * @param data - Array like object.\n         * @returns Sliced version of given object.\n         */\n\n    }, {\n        key: 'arrayUnique',\n        value: function arrayUnique(data) {\n            var result = [];\n            var _iteratorNormalCompletion25 = true;\n            var _didIteratorError25 = false;\n            var _iteratorError25 = undefined;\n\n            try {\n                for (var _iterator25 = (0, _getIterator3.default)(data), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {\n                    var _value14 = _step25.value;\n\n                    if (!result.includes(_value14)) result.push(_value14);\n                }\n            } catch (err) {\n                _didIteratorError25 = true;\n                _iteratorError25 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion25 && _iterator25.return) {\n                        _iterator25.return();\n                    }\n                } finally {\n                    if (_didIteratorError25) {\n                        throw _iteratorError25;\n                    }\n                }\n            }\n\n            return result;\n        }\n        /**\n         * Summarizes given property of given item list.\n         * @param data - Array of objects with given property name.\n         * @param propertyName - Property name to summarize.\n         * @param defaultValue - Value to return if property values doesn't match.\n         * @returns Summarized array.\n         */\n\n    }, {\n        key: 'arrayAggregatePropertyIfEqual',\n        value: function arrayAggregatePropertyIfEqual(data, propertyName) {\n            var defaultValue = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n\n            var result = defaultValue;\n            if (data && data.length && data[0].hasOwnProperty(propertyName)) {\n                result = data[0][propertyName];\n                var _iteratorNormalCompletion26 = true;\n                var _didIteratorError26 = false;\n                var _iteratorError26 = undefined;\n\n                try {\n                    for (var _iterator26 = (0, _getIterator3.default)(data), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {\n                        var item = _step26.value;\n\n                        if (item[propertyName] !== result) return defaultValue;\n                    }\n                } catch (err) {\n                    _didIteratorError26 = true;\n                    _iteratorError26 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion26 && _iterator26.return) {\n                            _iterator26.return();\n                        }\n                    } finally {\n                        if (_didIteratorError26) {\n                            throw _iteratorError26;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n        /**\n         * Deletes every item witch has only empty attributes for given property\n         * names. If given property names are empty each attribute will be\n         * considered. The empty string, \"null\" and \"undefined\" will be interpreted\n         * as empty.\n         * @param data - Data to filter.\n         * @param propertyNames - Properties to consider.\n         * @returns Given data without empty items.\n         */\n\n    }, {\n        key: 'arrayDeleteEmptyItems',\n        value: function arrayDeleteEmptyItems(data) {\n            var propertyNames = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n            if (!data) return data;\n            var result = [];\n            var _iteratorNormalCompletion27 = true;\n            var _didIteratorError27 = false;\n            var _iteratorError27 = undefined;\n\n            try {\n                for (var _iterator27 = (0, _getIterator3.default)(data), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {\n                    var item = _step27.value;\n\n                    var empty = true;\n                    for (var propertyName in item) {\n                        if (item.hasOwnProperty(propertyName)) if (!['', null, undefined].includes(item[propertyName]) && (!propertyNames.length || propertyNames.includes(propertyName))) {\n                            empty = false;\n                            break;\n                        }\n                    }if (!empty) result.push(item);\n                }\n            } catch (err) {\n                _didIteratorError27 = true;\n                _iteratorError27 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion27 && _iterator27.return) {\n                        _iterator27.return();\n                    }\n                } finally {\n                    if (_didIteratorError27) {\n                        throw _iteratorError27;\n                    }\n                }\n            }\n\n            return result;\n        }\n        /**\n         * Extracts all properties from all items wich occur in given property\n         * names.\n         * @param data - Data where each item should be sliced.\n         * @param propertyNames - Property names to extract.\n         * @returns Data with sliced items.\n         */\n\n    }, {\n        key: 'arrayExtract',\n        value: function arrayExtract(data, propertyNames) {\n            var result = [];\n            var _iteratorNormalCompletion28 = true;\n            var _didIteratorError28 = false;\n            var _iteratorError28 = undefined;\n\n            try {\n                for (var _iterator28 = (0, _getIterator3.default)(data), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {\n                    var item = _step28.value;\n\n                    var newItem = {};\n                    var _iteratorNormalCompletion29 = true;\n                    var _didIteratorError29 = false;\n                    var _iteratorError29 = undefined;\n\n                    try {\n                        for (var _iterator29 = (0, _getIterator3.default)(propertyNames), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {\n                            var propertyName = _step29.value;\n\n                            if (item.hasOwnProperty(propertyName)) newItem[propertyName] = item[propertyName];\n                        }\n                    } catch (err) {\n                        _didIteratorError29 = true;\n                        _iteratorError29 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion29 && _iterator29.return) {\n                                _iterator29.return();\n                            }\n                        } finally {\n                            if (_didIteratorError29) {\n                                throw _iteratorError29;\n                            }\n                        }\n                    }\n\n                    result.push(newItem);\n                }\n            } catch (err) {\n                _didIteratorError28 = true;\n                _iteratorError28 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion28 && _iterator28.return) {\n                        _iterator28.return();\n                    }\n                } finally {\n                    if (_didIteratorError28) {\n                        throw _iteratorError28;\n                    }\n                }\n            }\n\n            return result;\n        }\n        /**\n         * Extracts all values which matches given regular expression.\n         * @param data - Data to filter.\n         * @param regularExpression - Pattern to match for.\n         * @returns Filtered data.\n         */\n\n    }, {\n        key: 'arrayExtractIfMatches',\n        value: function arrayExtractIfMatches(data, regularExpression) {\n            var result = [];\n            var _iteratorNormalCompletion30 = true;\n            var _didIteratorError30 = false;\n            var _iteratorError30 = undefined;\n\n            try {\n                for (var _iterator30 = (0, _getIterator3.default)(data), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {\n                    var _value15 = _step30.value;\n\n                    if ((typeof regularExpression === 'string' ? new RegExp(regularExpression) : regularExpression).test(_value15)) result.push(_value15);\n                }\n            } catch (err) {\n                _didIteratorError30 = true;\n                _iteratorError30 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion30 && _iterator30.return) {\n                        _iterator30.return();\n                    }\n                } finally {\n                    if (_didIteratorError30) {\n                        throw _iteratorError30;\n                    }\n                }\n            }\n\n            return result;\n        }\n        /**\n         * Filters given data if given property is set or not.\n         * @param data - Data to filter.\n         * @param propertyName - Property name to check for existence.\n         * @returns Given data without the items which doesn't have specified\n         * property.\n         */\n\n    }, {\n        key: 'arrayExtractIfPropertyExists',\n        value: function arrayExtractIfPropertyExists(data, propertyName) {\n            if (data && propertyName) {\n                var result = [];\n                var _iteratorNormalCompletion31 = true;\n                var _didIteratorError31 = false;\n                var _iteratorError31 = undefined;\n\n                try {\n                    for (var _iterator31 = (0, _getIterator3.default)(data), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {\n                        var item = _step31.value;\n\n                        var exists = false;\n                        for (var _key30 in item) {\n                            if (_key30 === propertyName && item.hasOwnProperty(_key30) && ![undefined, null].includes(item[_key30])) {\n                                exists = true;\n                                break;\n                            }\n                        }if (exists) result.push(item);\n                    }\n                } catch (err) {\n                    _didIteratorError31 = true;\n                    _iteratorError31 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion31 && _iterator31.return) {\n                            _iterator31.return();\n                        }\n                    } finally {\n                        if (_didIteratorError31) {\n                            throw _iteratorError31;\n                        }\n                    }\n                }\n\n                return result;\n            }\n            return data;\n        }\n        /**\n         * Extract given data where specified property value matches given\n         * patterns.\n         * @param data - Data to filter.\n         * @param propertyPattern - Mapping of property names to pattern.\n         * @returns Filtered data.\n         */\n\n    }, {\n        key: 'arrayExtractIfPropertyMatches',\n        value: function arrayExtractIfPropertyMatches(data, propertyPattern) {\n            if (data && propertyPattern) {\n                var result = [];\n                var _iteratorNormalCompletion32 = true;\n                var _didIteratorError32 = false;\n                var _iteratorError32 = undefined;\n\n                try {\n                    for (var _iterator32 = (0, _getIterator3.default)(data), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {\n                        var item = _step32.value;\n\n                        var matches = true;\n                        for (var propertyName in propertyPattern) {\n                            if (!(propertyPattern[propertyName] instanceof RegExp ? propertyPattern[propertyName] : new RegExp(propertyPattern[propertyName])).test(item[propertyName])) {\n                                matches = false;\n                                break;\n                            }\n                        }if (matches) result.push(item);\n                    }\n                } catch (err) {\n                    _didIteratorError32 = true;\n                    _iteratorError32 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion32 && _iterator32.return) {\n                            _iterator32.return();\n                        }\n                    } finally {\n                        if (_didIteratorError32) {\n                            throw _iteratorError32;\n                        }\n                    }\n                }\n\n                return result;\n            }\n            return data;\n        }\n        /**\n         * Determines all objects which exists in \"firstSet\" and in \"secondSet\".\n         * Object key which will be compared are given by \"keys\". If an empty array\n         * is given each key will be compared. If an object is given corresponding\n         * initial data key will be mapped to referenced new data key.\n         * @param firstSet - Referenced data to check for.\n         * @param secondSet - Data to check for existence.\n         * @param keys - Keys to define equality.\n         * @param strict - The strict parameter indicates whether \"null\" and\n         * \"undefined\" should be interpreted as equal (takes only effect if given\n         * keys aren't empty).\n         * @returns Data which does exit in given initial data.\n         */\n\n    }, {\n        key: 'arrayIntersect',\n        value: function arrayIntersect(firstSet, secondSet) {\n            var keys = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n            var strict = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n            var containingData = [];\n            var _iteratorNormalCompletion33 = true;\n            var _didIteratorError33 = false;\n            var _iteratorError33 = undefined;\n\n            try {\n                var _loop = function _loop() {\n                    var initialItem = _step33.value;\n\n                    if (Tools.isPlainObject(initialItem)) {\n                        var _iteratorNormalCompletion34 = true;\n                        var _didIteratorError34 = false;\n                        var _iteratorError34 = undefined;\n\n                        try {\n                            var _loop2 = function _loop2() {\n                                var newItem = _step34.value;\n\n                                var exists = true;\n                                var iterateGivenKeys = void 0;\n                                var keysAreAnArray = Array.isArray(keys);\n                                if (Tools.isPlainObject(keys) || keysAreAnArray && keys.length) iterateGivenKeys = true;else {\n                                    iterateGivenKeys = false;\n                                    keys = initialItem;\n                                }\n                                var handle = function handle(firstSetKey, secondSetKey) {\n                                    if (keysAreAnArray && iterateGivenKeys) firstSetKey = secondSetKey;else if (!iterateGivenKeys) secondSetKey = firstSetKey;\n                                    if (newItem[secondSetKey] !== initialItem[firstSetKey] && (strict || !([null, undefined].includes(newItem[secondSetKey]) && [null, undefined].includes(initialItem[firstSetKey])))) {\n                                        exists = false;\n                                        return false;\n                                    }\n                                };\n                                if (Array.isArray(keys)) {\n                                    var index = 0;\n                                    var _iteratorNormalCompletion35 = true;\n                                    var _didIteratorError35 = false;\n                                    var _iteratorError35 = undefined;\n\n                                    try {\n                                        for (var _iterator35 = (0, _getIterator3.default)(keys), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {\n                                            var _key31 = _step35.value;\n\n                                            if (handle(index, _key31) === false) break;\n                                            index += 1;\n                                        }\n                                    } catch (err) {\n                                        _didIteratorError35 = true;\n                                        _iteratorError35 = err;\n                                    } finally {\n                                        try {\n                                            if (!_iteratorNormalCompletion35 && _iterator35.return) {\n                                                _iterator35.return();\n                                            }\n                                        } finally {\n                                            if (_didIteratorError35) {\n                                                throw _iteratorError35;\n                                            }\n                                        }\n                                    }\n                                } else for (var _key32 in keys) {\n                                    if (keys.hasOwnProperty(_key32)) if (handle(_key32, keys[_key32]) === false) break;\n                                }if (exists) {\n                                    containingData.push(initialItem);\n                                    return 'break';\n                                }\n                            };\n\n                            for (var _iterator34 = (0, _getIterator3.default)(secondSet), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {\n                                var _ret3 = _loop2();\n\n                                if (_ret3 === 'break') break;\n                            }\n                        } catch (err) {\n                            _didIteratorError34 = true;\n                            _iteratorError34 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion34 && _iterator34.return) {\n                                    _iterator34.return();\n                                }\n                            } finally {\n                                if (_didIteratorError34) {\n                                    throw _iteratorError34;\n                                }\n                            }\n                        }\n                    } else if (secondSet.includes(initialItem)) containingData.push(initialItem);\n                };\n\n                for (var _iterator33 = (0, _getIterator3.default)(firstSet), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {\n                    _loop();\n                }\n            } catch (err) {\n                _didIteratorError33 = true;\n                _iteratorError33 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion33 && _iterator33.return) {\n                        _iterator33.return();\n                    }\n                } finally {\n                    if (_didIteratorError33) {\n                        throw _iteratorError33;\n                    }\n                }\n            }\n\n            return containingData;\n        }\n        /**\n         * Creates a list of items within given range.\n         * @param range - Array of lower and upper bounds. If only one value is\n         * given lower bound will be assumed to be zero. Both integers have to be\n         * positive and will be contained in the resulting array.\n         * @param step - Space between two consecutive values.\n         * @returns Produced array of integers.\n         */\n\n    }, {\n        key: 'arrayMakeRange',\n        value: function arrayMakeRange(range) {\n            var step = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n\n            var index = void 0;\n            var higherBound = void 0;\n            if (range.length === 1) {\n                index = 0;\n                higherBound = parseInt(range[0], 10);\n            } else if (range.length === 2) {\n                index = parseInt(range[0], 10);\n                higherBound = parseInt(range[1], 10);\n            } else return range;\n            var result = [index];\n            while (index <= higherBound - step) {\n                index += step;\n                result.push(index);\n            }\n            return result;\n        }\n        /**\n         * Sums up given property of given item list.\n         * @param data - The objects with specified property to sum up.\n         * @param propertyName - Property name to sum up its value.\n         * @returns The aggregated value.\n         */\n\n    }, {\n        key: 'arraySumUpProperty',\n        value: function arraySumUpProperty(data, propertyName) {\n            var result = 0;\n            if (Array.isArray(data) && data.length) {\n                var _iteratorNormalCompletion36 = true;\n                var _didIteratorError36 = false;\n                var _iteratorError36 = undefined;\n\n                try {\n                    for (var _iterator36 = (0, _getIterator3.default)(data), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {\n                        var _item2 = _step36.value;\n\n                        if (_item2.hasOwnProperty(propertyName)) result += parseFloat(_item2[propertyName] || 0);\n                    }\n                } catch (err) {\n                    _didIteratorError36 = true;\n                    _iteratorError36 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion36 && _iterator36.return) {\n                            _iterator36.return();\n                        }\n                    } finally {\n                        if (_didIteratorError36) {\n                            throw _iteratorError36;\n                        }\n                    }\n                }\n            }return result;\n        }\n        /**\n         * Adds an item to another item as array connection (many to one).\n         * @param item - Item where the item should be appended to.\n         * @param target - Target to add to given item.\n         * @param name - Name of the target connection.\n         * @param checkIfExists - Indicates if duplicates are allowed in resulting\n         * list (will result in linear runtime instead of constant one).\n         * @returns Item with the appended target.\n         */\n\n    }, {\n        key: 'arrayAppendAdd',\n        value: function arrayAppendAdd(item, target, name) {\n            var checkIfExists = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n            if (item.hasOwnProperty(name)) {\n                if (!(checkIfExists && item[name].includes(target))) item[name].push(target);\n            } else item[name] = [target];\n            return item;\n        }\n        /**\n         * Removes given target on given list.\n         * @param list - Array to splice.\n         * @param target - Target to remove from given list.\n         * @param strict - Indicates whether to fire an exception if given target\n         * doesn't exists given list.\n         * @returns Item with the appended target.\n         */\n\n    }, {\n        key: 'arrayRemove',\n        value: function arrayRemove(list, target) {\n            var strict = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n            if (Array.isArray(list)) {\n                var index = list.indexOf(target);\n                if (index === -1) {\n                    if (strict) throw Error(\"Given target doesn't exists in given list.\");\n                } else\n                    /* eslint-disable max-statements-per-line */\n                    list.splice(index, 1);\n                /* eslint-enable max-statements-per-line */\n            } else if (strict) throw Error(\"Given target isn't an array.\");\n            return list;\n        }\n        // / endregion\n        // / region string\n        // // region url handling\n        /**\n         * Translates given string into the regular expression validated\n         * representation.\n         * @param value - String to convert.\n         * @param excludeSymbols - Symbols not to escape.\n         * @returns Converted string.\n         */\n\n    }, {\n        key: 'stringConvertToValidRegularExpression',\n        value: function stringConvertToValidRegularExpression(value) {\n            var excludeSymbols = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n            // NOTE: This is only for performance improvements.\n            if (value.length === 1 && !Tools.specialRegexSequences.includes(value)) return value;\n            // The escape sequence must also be escaped; but at first.\n            if (!excludeSymbols.includes('\\\\')) value.replace(/\\\\/g, '\\\\\\\\');\n            var _iteratorNormalCompletion37 = true;\n            var _didIteratorError37 = false;\n            var _iteratorError37 = undefined;\n\n            try {\n                for (var _iterator37 = (0, _getIterator3.default)(Tools.specialRegexSequences), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {\n                    var replace = _step37.value;\n\n                    if (!excludeSymbols.includes(replace)) value = value.replace(new RegExp('\\\\' + replace, 'g'), '\\\\' + replace);\n                }\n            } catch (err) {\n                _didIteratorError37 = true;\n                _iteratorError37 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion37 && _iterator37.return) {\n                        _iterator37.return();\n                    }\n                } finally {\n                    if (_didIteratorError37) {\n                        throw _iteratorError37;\n                    }\n                }\n            }\n\n            return value;\n        }\n        /**\n         * Translates given name into a valid javaScript one.\n         * @param name - Name to convert.\n         * @param allowedSymbols - String of symbols which should be allowed within\n         * a variable name (not the first character).\n         * @returns Converted name is returned.\n         */\n\n    }, {\n        key: 'stringConvertToValidVariableName',\n        value: function stringConvertToValidVariableName(name) {\n            var allowedSymbols = arguments.length <= 1 || arguments[1] === undefined ? '0-9a-zA-Z_$' : arguments[1];\n\n            return name.toString().replace(/^[^a-zA-Z_$]+/, '').replace(new RegExp('[^' + allowedSymbols + ']+([a-zA-Z0-9])', 'g'), function (fullMatch, firstLetter) {\n                return firstLetter.toUpperCase();\n            });\n        }\n        /**\n         * This method is intended for encoding *key* or *value* parts of query\n         * component. We need a custom method because \"encodeURIComponent()\" is too\n         * aggressive and encodes stuff that doesn't have to be encoded per\n         * \"http://tools.ietf.org/html/rfc3986:\".\n         * @param url - URL to encode.\n         * @param encodeSpaces - Indicates whether given url should encode\n         * whitespaces as \"+\" or \"%20\".\n         * @returns Encoded given url.\n         */\n\n    }, {\n        key: 'stringEncodeURIComponent',\n        value: function stringEncodeURIComponent(url, encodeSpaces) {\n            return encodeURIComponent(url).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, encodeSpaces ? '%20' : '+');\n        }\n        /**\n         * Appends a path selector to the given path if there isn't one yet.\n         * @param path - The path for appending a selector.\n         * @param pathSeparator - The selector for appending to path.\n         * @returns The appended path.\n         */\n\n    }, {\n        key: 'stringAddSeparatorToPath',\n        value: function stringAddSeparatorToPath(path) {\n            var pathSeparator = arguments.length <= 1 || arguments[1] === undefined ? '/' : arguments[1];\n\n            path = path.trim();\n            if (path.substr(-1) !== pathSeparator && path.length) return path + pathSeparator;\n            return path;\n        }\n        /**\n         * Checks if given path has given path prefix.\n         * @param prefix - Path prefix to search for.\n         * @param path - Path to search in.\n         * @param separator - Delimiter to use in path (default is the posix\n         * conform slash).\n         * @returns Value \"true\" if given prefix occur and \"false\" otherwise.\n         */\n\n    }, {\n        key: 'stringHasPathPrefix',\n        value: function stringHasPathPrefix() {\n            var prefix = arguments.length <= 0 || arguments[0] === undefined ? '/admin' : arguments[0];\n            var path = arguments.length <= 1 || arguments[1] === undefined ? 'location' in $.global && $.global.location.pathname || '' : arguments[1];\n            var separator = arguments.length <= 2 || arguments[2] === undefined ? '/' : arguments[2];\n\n            if (typeof prefix === 'string') {\n                if (!prefix.endsWith(separator)) prefix += separator;\n                return path === prefix.substring(0, prefix.length - separator.length) || path.startsWith(prefix);\n            }\n            return false;\n        }\n        /**\n         * Extracts domain name from given url. If no explicit domain name given\n         * current domain name will be assumed. If no parameter given current\n         * domain name will be determined.\n         * @param url - The url to extract domain from.\n         * @param fallback - The fallback host name if no one exits in given url\n         * (default is current hostname).\n         * @returns Extracted domain.\n         */\n\n    }, {\n        key: 'stringGetDomainName',\n        value: function stringGetDomainName() {\n            var url = arguments.length <= 0 || arguments[0] === undefined ? 'location' in $.global && $.global.location.href || '' : arguments[0];\n            var fallback = arguments.length <= 1 || arguments[1] === undefined ? 'location' in $.global && $.global.location.hostname || '' : arguments[1];\n\n            var result = /^([a-z]*:?\\/\\/)?([^/]+?)(?::[0-9]+)?(?:\\/.*|$)/i.exec(url);\n            if (result && result.length > 2 && result[1] && result[2]) return result[2];\n            return fallback;\n        }\n        /**\n         * Extracts port number from given url. If no explicit port number given\n         * and no fallback is defined current port number will be assumed for local\n         * links. For external links 80 will be assumed for http protocol or 443\n         * for https.\n         * @param url - The url to extract port from.\n         * @param fallback - Fallback port number if no explicit one was found.\n         * Default is derived from current protocol name.\n         * @param parameter - Additional parameter for checking if given url is an\n         * internal url. Given url and this parameter will be forwarded to the\n         * \"stringIsInternalURL()\" method.\n         * @returns Extracted port number.\n         */\n\n    }, {\n        key: 'stringGetPortNumber',\n        value: function stringGetPortNumber() {\n            var url = arguments.length <= 0 || arguments[0] === undefined ? 'location' in $.global && $.global.location.href || '' : arguments[0];\n            var fallback = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n            var parameter = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\n            var result = /^(?:[a-z]*:?\\/\\/[^/]+?)?(?:[^/]+?):([0-9]+)/i.exec(url);\n            if (result && result.length > 1) return parseInt(result[1], 10);\n            if (fallback !== null) return fallback;\n            if (Tools.stringIsInternalURL.apply(this, [url].concat(parameter)) && 'location' in $.global && $.global.location.port && parseInt($.global.location.port, 10)) return parseInt($.global.location.port, 10);\n            return Tools.stringGetProtocolName(url) === 'https' ? 443 : 80;\n        }\n        /**\n         * Extracts protocol name from given url. If no explicit url is given,\n         * current protocol will be assumed. If no parameter given current protocol\n         * number will be determined.\n         * @param url - The url to extract protocol from.\n         * @param fallback - Fallback port to use if no protocol exists in given\n         * url (default is current protocol).\n         * returns Extracted protocol.\n         */\n\n    }, {\n        key: 'stringGetProtocolName',\n        value: function stringGetProtocolName() {\n            var url = arguments.length <= 0 || arguments[0] === undefined ? 'location' in $.global && $.global.location.href || '' : arguments[0];\n            var fallback = arguments.length <= 1 || arguments[1] === undefined ? 'location' in $.global && $.global.location.protocol.substring(0, $.global.location.protocol.length - 1) || '' : arguments[1];\n\n            var result = /^([a-z]+):\\/\\//i.exec(url);\n            if (result && result.length > 1 && result[1]) return result[1];\n            return fallback;\n        }\n        /**\n         * Read a page's GET URL variables and return them as an associative array\n         * and preserves ordering.\n         * @param keyToGet - If key given the corresponding value is returned and\n         * full object otherwise.\n         * @param givenInput - An alternative input to the url search parameter. If\n         * \"#\" is given the complete current hash tag will be interpreted as url\n         * and search parameter will be extracted from there. If \"&\" is given\n         * classical search parameter and hash parameter will be taken in account.\n         * If a search string is given this will be analyzed. The default is to\n         * take given search part into account.\n         * @param subDelimiter - Defines which sequence indicates the start of\n         * parameter in a hash part of the url.\n         * @param hashedPathIndicator - If defined and given hash starts with this\n         * indicator given hash will be interpreted as path containing search and\n         * hash parts.\n         * @param givenSearch - Search part to take into account defaults to\n         * current url search part.\n         * @param givenHash - Hash part to take into account defaults to current\n         * url hash part.\n         * @returns Returns the current get array or requested value. If requested\n         * key doesn't exist \"undefined\" is returned.\n         */\n\n    }, {\n        key: 'stringGetURLVariable',\n        value: function stringGetURLVariable(keyToGet, givenInput) {\n            var subDelimiter = arguments.length <= 2 || arguments[2] === undefined ? '$' : arguments[2];\n            var hashedPathIndicator = arguments.length <= 3 || arguments[3] === undefined ? '!' : arguments[3];\n            var givenSearch = arguments[4];\n            var givenHash = arguments.length <= 5 || arguments[5] === undefined ? 'location' in $.global && $.global.location.hash || '' : arguments[5];\n\n            // region set search and hash\n            var hash = givenHash ? givenHash : '#';\n            var search = '';\n            if (givenSearch) search = givenSearch;else if (hashedPathIndicator && hash.startsWith(hashedPathIndicator)) {\n                var subHashStartIndex = hash.indexOf('#');\n                var pathAndSearch = void 0;\n                if (subHashStartIndex === -1) {\n                    pathAndSearch = hash.substring(hashedPathIndicator.length);\n                    hash = '';\n                } else {\n                    pathAndSearch = hash.substring(hashedPathIndicator.length, subHashStartIndex);\n                    hash = hash.substring(subHashStartIndex);\n                }\n                var subSearchStartIndex = pathAndSearch.indexOf('?');\n                if (subSearchStartIndex !== -1) search = pathAndSearch.substring(subSearchStartIndex);\n            } else if ('location' in $.global) search = $.global.location.search || '';\n            var input = givenInput ? givenInput : search;\n            // endregion\n            // region determine data from search and hash if specified\n            var both = input === '&';\n            if (both || input === '#') {\n                var decodedHash = '';\n                try {\n                    decodedHash = decodeURIComponent(hash);\n                } catch (error) {}\n                var subDelimiterIndex = decodedHash.indexOf(subDelimiter);\n                if (subDelimiterIndex === -1) input = '';else {\n                    input = decodedHash.substring(subDelimiterIndex);\n                    if (input.startsWith(subDelimiter)) input = input.substring(subDelimiter.length);\n                }\n            } else if (input.startsWith('?')) input = input.substring('?'.length);\n            var data = input ? input.split('&') : [];\n            search = search.substring('?'.length);\n            if (both && search) data = data.concat(search.split('&'));\n            // endregion\n            // region construct data structure\n            var variables = [];\n            var _iteratorNormalCompletion38 = true;\n            var _didIteratorError38 = false;\n            var _iteratorError38 = undefined;\n\n            try {\n                for (var _iterator38 = (0, _getIterator3.default)(data), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {\n                    var _value16 = _step38.value;\n\n                    var keyValuePair = _value16.split('=');\n                    var _key33 = void 0;\n                    try {\n                        _key33 = decodeURIComponent(keyValuePair[0]);\n                    } catch (error) {\n                        _key33 = '';\n                    }\n                    try {\n                        _value16 = decodeURIComponent(keyValuePair[1]);\n                    } catch (error) {\n                        _value16 = '';\n                    }\n                    variables.push(_key33);\n                    // IgnoreTypeCheck\n                    variables[_key33] = _value16;\n                }\n                // endregion\n            } catch (err) {\n                _didIteratorError38 = true;\n                _iteratorError38 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion38 && _iterator38.return) {\n                        _iterator38.return();\n                    }\n                } finally {\n                    if (_didIteratorError38) {\n                        throw _iteratorError38;\n                    }\n                }\n            }\n\n            if (keyToGet)\n                // IgnoreTypeCheck\n                return variables[keyToGet];\n            return variables;\n        }\n        /**\n         * Checks if given url points to another domain than second given url. If\n         * no second given url provided current url will be assumed.\n         * @param firstURL - URL to check against second url.\n         * @param secondURL - URL to check against first url.\n         * @returns Returns \"true\" if given first url has same domain as given\n         * second (or current).\n         */\n\n    }, {\n        key: 'stringIsInternalURL',\n        value: function stringIsInternalURL(firstURL) {\n            var secondURL = arguments.length <= 1 || arguments[1] === undefined ? 'location' in $.global && $.global.location.href || '' : arguments[1];\n\n            var explicitDomainName = Tools.stringGetDomainName(firstURL, false);\n            var explicitProtocolName = Tools.stringGetProtocolName(firstURL, false);\n            var explicitPortNumber = Tools.stringGetPortNumber(firstURL, false);\n            return (!explicitDomainName || explicitDomainName === Tools.stringGetDomainName(secondURL)) && (!explicitProtocolName || explicitProtocolName === Tools.stringGetProtocolName(secondURL)) && (!explicitPortNumber || explicitPortNumber === Tools.stringGetPortNumber(secondURL));\n        }\n        /**\n         * Normalized given website url.\n         * @param url - Uniform resource locator to normalize.\n         * @returns Normalized result.\n         */\n\n    }, {\n        key: 'stringNormalizeURL',\n        value: function stringNormalizeURL(url) {\n            if (url) {\n                url = url.replace(/^:?\\/+/, '').replace(/\\/+$/, '').trim();\n                if (url.startsWith('http')) return url;\n                return 'http://' + url;\n            }\n            return '';\n        }\n        /**\n         * Represents given website url.\n         * @param url - Uniform resource locator to represent.\n         * @returns Represented result.\n         */\n\n    }, {\n        key: 'stringRepresentURL',\n        value: function stringRepresentURL(url) {\n            if (typeof url === 'string') return url.replace(/^(https?)?:?\\/+/, '').replace(/\\/+$/, '').trim();\n            return '';\n        }\n        // // endregion\n        /**\n         * Compresses given style attribute value.\n         * @param styleValue - Style value to compress.\n         * @returns The compressed value.\n         */\n\n    }, {\n        key: 'stringCompressStyleValue',\n        value: function stringCompressStyleValue(styleValue) {\n            return styleValue.replace(/ *([:;]) */g, '$1').replace(/ +/g, ' ').replace(/^;+/, '').replace(/;+$/, '').trim();\n        }\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Converts a camel cased string to its delimited string version.\n         * @param string - The string to format.\n         * @param delimiter - Delimiter string\n         * @param abbreviations - Collection of shortcut words to represent upper\n         * cased.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringCamelCaseToDelimited',\n        value: function stringCamelCaseToDelimited(string) {\n            var delimiter = arguments.length <= 1 || arguments[1] === undefined ? '-' : arguments[1];\n            var abbreviations = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            if (!abbreviations) abbreviations = Tools.abbreviations;\n            var escapedDelimiter = Tools.stringGetRegularExpressionValidated(delimiter);\n            if (abbreviations.length) {\n                var abbreviationPattern = '';\n                var _iteratorNormalCompletion39 = true;\n                var _didIteratorError39 = false;\n                var _iteratorError39 = undefined;\n\n                try {\n                    for (var _iterator39 = (0, _getIterator3.default)(abbreviations), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {\n                        var abbreviation = _step39.value;\n\n                        if (abbreviationPattern) abbreviationPattern += '|';\n                        abbreviationPattern += abbreviation.toUpperCase();\n                    }\n                } catch (err) {\n                    _didIteratorError39 = true;\n                    _iteratorError39 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion39 && _iterator39.return) {\n                            _iterator39.return();\n                        }\n                    } finally {\n                        if (_didIteratorError39) {\n                            throw _iteratorError39;\n                        }\n                    }\n                }\n\n                string = string.replace(new RegExp('(' + abbreviationPattern + ')(' + abbreviationPattern + ')', 'g'), '$1' + delimiter + '$2');\n            }\n            string = string.replace(new RegExp('([^' + escapedDelimiter + '])([A-Z][a-z]+)', 'g'), '$1' + delimiter + '$2');\n            return string.replace(new RegExp('([a-z0-9])([A-Z])', 'g'), '$1' + delimiter + '$2').toLowerCase();\n        }\n        /* eslint-disable jsdoc/require-description-complete-sentence */\n        /**\n         * Converts a string to its capitalize representation.\n         * @param string - The string to format.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringCapitalize',\n        value: function stringCapitalize(string) {\n            /* eslint-enable jsdoc/require-description-complete-sentence */\n            return string.charAt(0).toUpperCase() + string.substring(1);\n        }\n        /**\n         * Converts a delimited string to its camel case representation.\n         * @param string - The string to format.\n         * @param delimiter - Delimiter string to use.\n         * @param abbreviations - Collection of shortcut words to represent upper\n         * cased.\n         * @param preserveWrongFormattedAbbreviations - If set to \"True\" wrong\n         * formatted camel case abbreviations will be ignored.\n         * @param removeMultipleDelimiter - Indicates whether a series of delimiter\n         * should be consolidated.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringDelimitedToCamelCase',\n        value: function stringDelimitedToCamelCase(string) {\n            var delimiter = arguments.length <= 1 || arguments[1] === undefined ? '-' : arguments[1];\n            var abbreviations = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n            var preserveWrongFormattedAbbreviations = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n            var removeMultipleDelimiter = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n\n            var escapedDelimiter = Tools.stringGetRegularExpressionValidated(delimiter);\n            if (!abbreviations) abbreviations = Tools.abbreviations;\n            var abbreviationPattern = void 0;\n            if (preserveWrongFormattedAbbreviations) abbreviationPattern = abbreviations.join('|');else {\n                abbreviationPattern = '';\n                var _iteratorNormalCompletion40 = true;\n                var _didIteratorError40 = false;\n                var _iteratorError40 = undefined;\n\n                try {\n                    for (var _iterator40 = (0, _getIterator3.default)(abbreviations), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {\n                        var abbreviation = _step40.value;\n\n                        if (abbreviationPattern) abbreviationPattern += '|';\n                        abbreviationPattern += Tools.stringCapitalize(abbreviation) + '|' + abbreviation;\n                    }\n                } catch (err) {\n                    _didIteratorError40 = true;\n                    _iteratorError40 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion40 && _iterator40.return) {\n                            _iterator40.return();\n                        }\n                    } finally {\n                        if (_didIteratorError40) {\n                            throw _iteratorError40;\n                        }\n                    }\n                }\n            }\n            var stringStartsWithDelimiter = false;\n            if (string.startsWith(delimiter)) {\n                string = string.substring(delimiter.length);\n                stringStartsWithDelimiter = true;\n            }\n            string = string.replace(new RegExp('(' + escapedDelimiter + ')(' + abbreviationPattern + ')' + ('(' + escapedDelimiter + '|$)'), 'g'), function (fullMatch, before, abbreviation, after) {\n                return before + abbreviation.toUpperCase() + after;\n            });\n            if (removeMultipleDelimiter) escapedDelimiter = '(?:' + escapedDelimiter + ')+';\n            string = string.replace(new RegExp(escapedDelimiter + '([a-zA-Z0-9])', 'g'), function (fullMatch, firstLetter) {\n                return firstLetter.toUpperCase();\n            });\n            if (stringStartsWithDelimiter) string = delimiter + string;\n            return string;\n        }\n        /**\n         * Performs a string formation. Replaces every placeholder \"{i}\" with the\n         * i'th argument.\n         * @param string - The string to format.\n         * @param additionalArguments - Additional arguments are interpreted as\n         * replacements for string formating.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringFormat',\n        value: function stringFormat(string) {\n            for (var _len11 = arguments.length, additionalArguments = Array(_len11 > 1 ? _len11 - 1 : 0), _key34 = 1; _key34 < _len11; _key34++) {\n                additionalArguments[_key34 - 1] = arguments[_key34];\n            }\n\n            additionalArguments.unshift(string);\n            var index = 0;\n            var _iteratorNormalCompletion41 = true;\n            var _didIteratorError41 = false;\n            var _iteratorError41 = undefined;\n\n            try {\n                for (var _iterator41 = (0, _getIterator3.default)(additionalArguments), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {\n                    var _value17 = _step41.value;\n\n                    string = string.replace(new RegExp('\\\\{' + index + '\\\\}', 'gm'), '' + _value17);\n                    index += 1;\n                }\n            } catch (err) {\n                _didIteratorError41 = true;\n                _iteratorError41 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion41 && _iterator41.return) {\n                        _iterator41.return();\n                    }\n                } finally {\n                    if (_didIteratorError41) {\n                        throw _iteratorError41;\n                    }\n                }\n            }\n\n            return string;\n        }\n        /**\n         * Validates the current string for using in a regular expression pattern.\n         * Special regular expression chars will be escaped.\n         * @param string - The string to format.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringGetRegularExpressionValidated',\n        value: function stringGetRegularExpressionValidated(string) {\n            return string.replace(/([\\\\|.*$^+[\\]()?\\-{}])/g, '\\\\$1');\n        }\n        /**\n         * Converts a string to its lower case representation.\n         * @param string - The string to format.\n         * @returns The formatted string.\n         */\n\n    }, {\n        key: 'stringLowerCase',\n        value: function stringLowerCase(string) {\n            return string.charAt(0).toLowerCase() + string.substring(1);\n        }\n        /**\n         * Wraps given mark strings in given target with given marker.\n         * @param target - String to search for marker.\n         * @param mark - String to search in target for.\n         * @param marker - HTML template string to mark.\n         * @param caseSensitive - Indicates whether case takes a role during\n         * searching.\n         * @returns Processed result.\n         */\n\n    }, {\n        key: 'stringMark',\n        value: function stringMark(target, mark) {\n            var marker = arguments.length <= 2 || arguments[2] === undefined ? '<span class=\"tools-mark\">{1}</span>' : arguments[2];\n            var caseSensitive = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n            if (target && mark) {\n                target = target.trim();\n                mark = mark.trim();\n                var offset = 0;\n                var searchTarget = target;\n                if (!caseSensitive) searchTarget = searchTarget.toLowerCase();\n                if (!caseSensitive) mark = mark.toLowerCase();\n                while (true) {\n                    var index = searchTarget.indexOf(mark, offset);\n                    if (index === -1) break;else {\n                        target = target.substring(0, index) + Tools.stringFormat(marker, target.substr(index, mark.length)) + target.substring(index + mark.length);\n                        if (!caseSensitive) searchTarget = target.toLowerCase();\n                        offset = index + (marker.length - '{1}'.length) + mark.length;\n                    }\n                }\n            }\n            return target;\n        }\n        /**\n         * Implements the md5 hash algorithm.\n         * @param value - Value to calculate md5 hash for.\n         * @param onlyAscii - Set to true if given input has ascii characters only\n         * to get more performance.\n         * @returns Calculated md5 hash value.\n         */\n\n    }, {\n        key: 'stringMD5',\n        value: function stringMD5(value) {\n            var onlyAscii = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n            var hexCharacters = '0123456789abcdef'.split('');\n            // region sub helper\n            /**\n             * This function is much faster, so if possible we use it. Some IEs\n             * are the only ones I know of that need the idiotic second function,\n             * generated by an if clause in the end.\n             * @param first - First operand to add.\n             * @param second - Second operant to add.\n             * @returns The sum of both given operands.\n            */\n            var unsignedModule2PowerOf32Addition = function unsignedModule2PowerOf32Addition(first, second) {\n                return first + second & 0xFFFFFFFF;\n            };\n            // / region primary functions needed for the algorithm\n            /*\n             * Implements the basic operation for each round of the algorithm.\n             */\n            var cmn = function cmn(q, a, b, x, s, t) {\n                a = unsignedModule2PowerOf32Addition(unsignedModule2PowerOf32Addition(a, q), unsignedModule2PowerOf32Addition(x, t));\n                return unsignedModule2PowerOf32Addition(a << s | a >>> 32 - s, b);\n            };\n            /**\n             * First algorithm part.\n             * @param a - Operand.\n             * @param b - Operand.\n             * @param c - Operand.\n             * @param d - Operand.\n             * @param x - Operand.\n             * @param s - Operand.\n             * @param t - Operand.\n             * @returns Result.\n             */\n            var ff = function ff(a, b, c, d, x, s, t) {\n                return cmn(b & c | ~b & d, a, b, x, s, t);\n            };\n            /**\n             * Second algorithm part.\n             * @param a - Operand.\n             * @param b - Operand.\n             * @param c - Operand.\n             * @param d - Operand.\n             * @param x - Operand.\n             * @param s - Operand.\n             * @param t - Operand.\n             * @returns Result.\n             */\n            var gg = function gg(a, b, c, d, x, s, t) {\n                return cmn(b & d | c & ~d, a, b, x, s, t);\n            };\n            /**\n             * Third algorithm part.\n             * @param a - Operand.\n             * @param b - Operand.\n             * @param c - Operand.\n             * @param d - Operand.\n             * @param x - Operand.\n             * @param s - Operand.\n             * @param t - Operand.\n             * @returns Result.\n             */\n            var hh = function hh(a, b, c, d, x, s, t) {\n                return cmn(b ^ c ^ d, a, b, x, s, t);\n            };\n            /**\n             * Fourth algorithm part.\n             * @param a - Operand.\n             * @param b - Operand.\n             * @param c - Operand.\n             * @param d - Operand.\n             * @param x - Operand.\n             * @param s - Operand.\n             * @param t - Operand.\n             * @returns Result.\n             */\n            var ii = function ii(a, b, c, d, x, s, t) {\n                return cmn(c ^ (b | ~d), a, b, x, s, t);\n            };\n            /**\n             * Performs all 16 needed steps.\n             * @param state - Current state.\n             * @param blocks - Blocks to cycle through.\n             * @returns Returns given state.\n             */\n            var cycle = function cycle(state, blocks) {\n                var a = state[0];\n                var b = state[1];\n                var c = state[2];\n                var d = state[3];\n                // region round 1\n                a = ff(a, b, c, d, blocks[0], 7, -680876936);\n                d = ff(d, a, b, c, blocks[1], 12, -389564586);\n                c = ff(c, d, a, b, blocks[2], 17, 606105819);\n                b = ff(b, c, d, a, blocks[3], 22, -1044525330);\n\n                a = ff(a, b, c, d, blocks[4], 7, -176418897);\n                d = ff(d, a, b, c, blocks[5], 12, 1200080426);\n                c = ff(c, d, a, b, blocks[6], 17, -1473231341);\n                b = ff(b, c, d, a, blocks[7], 22, -45705983);\n\n                a = ff(a, b, c, d, blocks[8], 7, 1770035416);\n                d = ff(d, a, b, c, blocks[9], 12, -1958414417);\n                c = ff(c, d, a, b, blocks[10], 17, -42063);\n                b = ff(b, c, d, a, blocks[11], 22, -1990404162);\n\n                a = ff(a, b, c, d, blocks[12], 7, 1804603682);\n                d = ff(d, a, b, c, blocks[13], 12, -40341101);\n                c = ff(c, d, a, b, blocks[14], 17, -1502002290);\n                b = ff(b, c, d, a, blocks[15], 22, 1236535329);\n                // endregion\n                // region round 2\n                a = gg(a, b, c, d, blocks[1], 5, -165796510);\n                d = gg(d, a, b, c, blocks[6], 9, -1069501632);\n                c = gg(c, d, a, b, blocks[11], 14, 643717713);\n                b = gg(b, c, d, a, blocks[0], 20, -373897302);\n\n                a = gg(a, b, c, d, blocks[5], 5, -701558691);\n                d = gg(d, a, b, c, blocks[10], 9, 38016083);\n                c = gg(c, d, a, b, blocks[15], 14, -660478335);\n                b = gg(b, c, d, a, blocks[4], 20, -405537848);\n\n                a = gg(a, b, c, d, blocks[9], 5, 568446438);\n                d = gg(d, a, b, c, blocks[14], 9, -1019803690);\n                c = gg(c, d, a, b, blocks[3], 14, -187363961);\n                b = gg(b, c, d, a, blocks[8], 20, 1163531501);\n\n                a = gg(a, b, c, d, blocks[13], 5, -1444681467);\n                d = gg(d, a, b, c, blocks[2], 9, -51403784);\n                c = gg(c, d, a, b, blocks[7], 14, 1735328473);\n                b = gg(b, c, d, a, blocks[12], 20, -1926607734);\n                // endregion\n                // region round 3\n                a = hh(a, b, c, d, blocks[5], 4, -378558);\n                d = hh(d, a, b, c, blocks[8], 11, -2022574463);\n                c = hh(c, d, a, b, blocks[11], 16, 1839030562);\n                b = hh(b, c, d, a, blocks[14], 23, -35309556);\n\n                a = hh(a, b, c, d, blocks[1], 4, -1530992060);\n                d = hh(d, a, b, c, blocks[4], 11, 1272893353);\n                c = hh(c, d, a, b, blocks[7], 16, -155497632);\n                b = hh(b, c, d, a, blocks[10], 23, -1094730640);\n\n                a = hh(a, b, c, d, blocks[13], 4, 681279174);\n                d = hh(d, a, b, c, blocks[0], 11, -358537222);\n                c = hh(c, d, a, b, blocks[3], 16, -722521979);\n                b = hh(b, c, d, a, blocks[6], 23, 76029189);\n\n                a = hh(a, b, c, d, blocks[9], 4, -640364487);\n                d = hh(d, a, b, c, blocks[12], 11, -421815835);\n                c = hh(c, d, a, b, blocks[15], 16, 530742520);\n                b = hh(b, c, d, a, blocks[2], 23, -995338651);\n                // endregion\n                // region round 4\n                a = ii(a, b, c, d, blocks[0], 6, -198630844);\n                d = ii(d, a, b, c, blocks[7], 10, 1126891415);\n                c = ii(c, d, a, b, blocks[14], 15, -1416354905);\n                b = ii(b, c, d, a, blocks[5], 21, -57434055);\n\n                a = ii(a, b, c, d, blocks[12], 6, 1700485571);\n                d = ii(d, a, b, c, blocks[3], 10, -1894986606);\n                c = ii(c, d, a, b, blocks[10], 15, -1051523);\n                b = ii(b, c, d, a, blocks[1], 21, -2054922799);\n\n                a = ii(a, b, c, d, blocks[8], 6, 1873313359);\n                d = ii(d, a, b, c, blocks[15], 10, -30611744);\n                c = ii(c, d, a, b, blocks[6], 15, -1560198380);\n                b = ii(b, c, d, a, blocks[13], 21, 1309151649);\n\n                a = ii(a, b, c, d, blocks[4], 6, -145523070);\n                d = ii(d, a, b, c, blocks[11], 10, -1120210379);\n                c = ii(c, d, a, b, blocks[2], 15, 718787259);\n                b = ii(b, c, d, a, blocks[9], 21, -343485551);\n                // endregion\n                state[0] = unsignedModule2PowerOf32Addition(a, state[0]);\n                state[1] = unsignedModule2PowerOf32Addition(b, state[1]);\n                state[2] = unsignedModule2PowerOf32Addition(c, state[2]);\n                state[3] = unsignedModule2PowerOf32Addition(d, state[3]);\n                return state;\n            };\n            // / endregion\n            /**\n             * Converts given character to its corresponding hex code\n             * representation.\n             * @param character - Character to convert.\n             * @returns Converted hex code string.\n             */\n            var convertCharactorToHexCode = function convertCharactorToHexCode(character) {\n                var hexString = '';\n                for (var round = 0; round < 4; round++) {\n                    hexString += hexCharacters[character >> round * 8 + 4 & 0x0F] + hexCharacters[character >> round * 8 & 0x0F];\n                }return hexString;\n            };\n            /**\n             * Converts given byte array to its corresponding hex code as string.\n             * @param value - Array of characters to convert.\n             * @returns Converted hex code.\n             */\n            var convertToHexCode = function convertToHexCode(value) {\n                for (var index = 0; index < value.length; index++) {\n                    value[index] = convertCharactorToHexCode(value[index]);\n                }return value.join('');\n            };\n            /**\n             * There needs to be support for unicode here, unless we pretend that\n             * we can redefine the md5 algorithm for multi-byte characters\n             * (perhaps by adding every four 16-bit characters and shortening the\n             * sum to 32 bits). Otherwise I suggest performing md5 as if every\n             * character was two bytes--e.g., 0040 0025 = @%--but then how will an\n             * ordinary md5 sum be matched? There is no way to standardize text\n             * to something like utf-8 before transformation; speed cost is\n             * utterly prohibitive. The JavaScript standard itself needs to look\n             * at this: it should start providing access to strings as preformed\n             * utf-8 8-bit unsigned value arrays.\n             * @param value - Value to process with each block.\n             * @returns Converted byte array.\n             */\n            var handleBlock = function handleBlock(value) {\n                var blocks = [];\n                for (var blockNumber = 0; blockNumber < 64; blockNumber += 4) {\n                    blocks[blockNumber >> 2] = value.charCodeAt(blockNumber) + (value.charCodeAt(blockNumber + 1) << 8) + (value.charCodeAt(blockNumber + 2) << 16) + (value.charCodeAt(blockNumber + 3) << 24);\n                }return blocks;\n            };\n            // endregion\n            /**\n             * Triggers the main algorithm to calculate the md5 representation of\n             * given value.\n             * @param value - String to convert to its md5 representation.\n             * @returns Array of blocks.\n             */\n            var main = function main(value) {\n                var length = value.length;\n                var state = [1732584193, -271733879, -1732584194, 271733878];\n                var blockNumber = void 0;\n                for (blockNumber = 64; blockNumber <= value.length; blockNumber += 64) {\n                    cycle(state, handleBlock(value.substring(blockNumber - 64, blockNumber)));\n                }value = value.substring(blockNumber - 64);\n                var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n                for (blockNumber = 0; blockNumber < value.length; blockNumber++) {\n                    tail[blockNumber >> 2] |= value.charCodeAt(blockNumber) << (blockNumber % 4 << 3);\n                }tail[blockNumber >> 2] |= 0x80 << (blockNumber % 4 << 3);\n                if (blockNumber > 55) {\n                    cycle(state, tail);\n                    for (var index = 0; index < 16; index++) {\n                        tail[index] = 0;\n                    }\n                }\n                tail[14] = length * 8;\n                cycle(state, tail);\n                return state;\n            };\n            // region final call\n            if (convertToHexCode(main('hello')) !== '5d41402abc4b2a76b9719d911017c592')\n                /**\n                 * This function is much faster, so if possible we use it. Some IEs\n                 * are the only ones I know of that need the idiotic second\n                 * function, generated by an if clause in the end.\n                 * @private\n                 * @param first - First operand to add.\n                 * @param second - Second operant to add.\n                 * @returns The sum of both given operands.\n                */\n                unsignedModule2PowerOf32Addition = function unsignedModule2PowerOf32Addition(first, second) {\n                    var lsw = (first & 0xFFFF) + (second & 0xFFFF);\n                    var msw = (first >> 16) + (second >> 16) + (lsw >> 16);\n                    return msw << 16 | lsw & 0xFFFF;\n                };\n            // IgnoreTypeCheck\n            return convertToHexCode(main(onlyAscii ? value : unescape(encodeURIComponent(value))));\n            // endregion\n        }\n        /**\n         * Normalizes given phone number for automatic dialing mechanisms.\n         * @param phoneNumber - Number to normalize.\n         * @returns Normalized number.\n         */\n\n    }, {\n        key: 'stringNormalizePhoneNumber',\n        value: function stringNormalizePhoneNumber(phoneNumber) {\n            if (typeof phoneNumber === 'string' || typeof phoneNumber === 'number') return ('' + phoneNumber).replace(/[^0-9]*\\+/, '00').replace(/[^0-9]+/g, '');\n            return '';\n        }\n        /**\n         * Represents given phone number. NOTE: Currently only support german phone\n         * numbers.\n         * @param phoneNumber - Number to format.\n         * @returns Formatted number.\n         */\n\n    }, {\n        key: 'stringRepresentPhoneNumber',\n        value: function stringRepresentPhoneNumber(phoneNumber) {\n            if (['number', 'string'].includes(Tools.determineType(phoneNumber)) && phoneNumber) {\n                // Represent country code and leading area code zero.\n                phoneNumber = ('' + phoneNumber).replace(/^(00|\\+)([0-9]+)-([0-9-]+)$/, '+$2 (0) $3');\n                // Add German country code if not exists.\n                phoneNumber = phoneNumber.replace(/^0([1-9][0-9-]+)$/, '+49 (0) $1');\n                // Separate area code from base number.\n                phoneNumber = phoneNumber.replace(/^([^-]+)-([0-9-]+)$/, '$1 / $2');\n                // Partition base number in one triple and tuples or tuples only.\n                return phoneNumber.replace(/^(.*?)([0-9]+)(-?[0-9]*)$/, function (match, prefix, number, suffix) {\n                    return prefix + (number.length % 2 === 0 ? number.replace(/([0-9]{2})/g, '$1 ') : number.replace(/^([0-9]{3})([0-9]+)$/, function (match, triple, rest) {\n                        return triple + ' ' + rest.replace(/([0-9]{2})/g, '$1 ').trim();\n                    }) + suffix).trim();\n                }).trim();\n            }\n            return '';\n        }\n        /**\n         * Decodes all html symbols in text nodes in given html string.\n         * @param htmlString - HTML string to decode.\n         * @returns Decoded html string.\n         */\n\n    }, {\n        key: 'stringDecodeHTMLEntities',\n        value: function stringDecodeHTMLEntities(htmlString) {\n            if ('document' in $.global) {\n                var textareaDomNode = $.global.document.createElement('textarea');\n                textareaDomNode.innerHTML = htmlString;\n                return textareaDomNode.value;\n            }\n            return null;\n        }\n    }, {\n        key: 'numberIsNotANumber',\n        value: function numberIsNotANumber(object) {\n            return Tools.determineType(object) === 'number' && isNaN(object);\n        }\n        /**\n         * Rounds a given number accurate to given number of digits.\n         * @param number - The number to round.\n         * @param digits - The number of digits after comma.\n         * @returns Returns the rounded number.\n         */\n\n    }, {\n        key: 'numberRound',\n        value: function numberRound(number) {\n            var digits = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n            return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);\n        }\n        // / endregion\n        // / region data transfer\n        /**\n         * Send given data to a given iframe.\n         * @param target - Name of the target iframe or the target iframe itself.\n         * @param url - URL to send to data to.\n         * @param data - Data holding object to send data to.\n         * @param requestType - The forms action attribute value. If nothing is\n         * provided \"post\" will be used as default.\n         * @param removeAfterLoad - Indicates if created iframe should be removed\n         * right after load event. Only works if an iframe object is given instead\n         * of a simple target name.\n         * @returns Returns the given target.\n         */\n\n    }, {\n        key: 'sendToIFrame',\n        value: function sendToIFrame(target, url, data) {\n            var requestType = arguments.length <= 3 || arguments[3] === undefined ? 'post' : arguments[3];\n            var removeAfterLoad = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n\n            var targetName = typeof target === 'string' ? target : target.attr('name');\n            var $formDomNode = $('<form>').attr({\n                action: url,\n                method: requestType,\n                target: targetName\n            });\n            for (var _name4 in data) {\n                if (data.hasOwnProperty(_name4)) $formDomNode.append($('<input>').attr({\n                    type: 'hidden',\n                    name: _name4,\n                    value: data[_name4]\n                }));\n            }$formDomNode.submit().remove();\n            if (removeAfterLoad && (typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && 'on' in target)\n                // IgnoreTypeCheck\n                target.on('load', function () {\n                    return target.remove();\n                });\n            return targetName;\n        }\n    }]);\n    return Tools;\n}();\n// endregion\n// region handle $ extending\n\n\nTools.abbreviations = ['html', 'id', 'url', 'us', 'de', 'api', 'href'];\nTools.animationEndEventNames = 'animationend webkitAnimationEnd ' + 'oAnimationEnd MSAnimationEnd';\nTools.classToTypeMapping = {\n    '[object Array]': 'array',\n    '[object Boolean]': 'boolean',\n    '[object Date]': 'date',\n    '[object Error]': 'error',\n    '[object Function]': 'function',\n    '[object Number]': 'number',\n    '[object Object]': 'object',\n    '[object RegExp]': 'regexp',\n    '[object String]': 'string'\n};\nTools.keyCode = {\n    BACKSPACE: 8,\n    COMMA: 188,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    LEFT: 37,\n    NUMPAD_ADD: 107,\n    NUMPAD_DECIMAL: 110,\n    NUMPAD_DIVIDE: 111,\n    NUMPAD_ENTER: 108,\n    NUMPAD_MULTIPLY: 106,\n    NUMPAD_SUBTRACT: 109,\n    PAGE_DOWN: 34,\n    PAGE_UP: 33,\n    PERIOD: 190,\n    RIGHT: 39,\n    SPACE: 32,\n    TAB: 9,\n    UP: 38\n};\n\nTools.maximalSupportedInternetExplorerVersion = function () {\n    if (!('document' in $.global)) return 0;\n    var div = $.global.document.createElement('div');\n    var version = void 0;\n    for (version = 0; version < 10; version++) {\n        /*\n            NOTE: We split html comment sequences to avoid wrong\n            interpretation if this code is embedded in markup.\n            NOTE: Internet Explorer 9 and lower sometimes doesn't\n            understand conditional comments wich doesn't starts with a\n            whitespace. If the conditional markup isn't in a commend.\n            Otherwise there shouldn't be any whitespace!\n        */\n        /* eslint-disable no-useless-concat */\n        div.innerHTML = '<!' + ('--[if gt IE ' + version + ']><i></i><![e') + 'ndif]-' + '->';\n        /* eslint-enable no-useless-concat */\n        if (div.getElementsByTagName('i').length === 0) break;\n    }\n    // Try special detection for internet explorer 10 and 11.\n    if (version === 0 && 'navigator' in $.global) if ($.global.navigator.appVersion.includes('MSIE 10')) return 10;else if ($.global.navigator.userAgent.includes('Trident') && $.global.navigator.userAgent.includes('rv:11')) return 11;\n    return version;\n}();\n\nTools.noop = 'noop' in $ ? $.noop : function () {};\nTools.specialRegexSequences = ['-', '[', ']', '(', ')', '^', '$', '*', '+', '.', '{', '}'];\nTools.transitionEndEventNames = 'transitionend ' + 'webkitTransitionEnd oTransitionEnd MSTransitionEnd';\nTools.consoleMethodNames = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];\nTools._javaScriptDependentContentHandled = false;\nTools._name = 'Tools';\nexports.default = Tools;\nif ('fn' in $) $.fn.Tools = function () {\n    return new Tools().controller(Tools, arguments, this);\n};\n$.Tools = function () {\n    return new Tools().controller(Tools, arguments);\n};\n$.Tools.class = Tools;\n// / region prop fix for comments and text nodes\nif ('fn' in $) {\n    (function () {\n        var nativePropFunction = $.fn.prop;\n        /**\n         * JQuery's native prop implementation ignores properties for text nodes,\n         * comments and attribute nodes.\n         * @param key - Name of property to retrieve from current dom node.\n         * @param value - Value to set for given property by name.\n         * @returns Returns value if used as getter or current dom node if used as\n         * setter.\n         */\n        $.fn.prop = function (key, value) {\n            if (arguments.length < 3 && this.length && ['#text', '#comment'].includes(this[0].nodeName) && key in this[0]) {\n                if (arguments.length === 1) return this[0][key];\n                if (arguments.length === 2) {\n                    this[0][key] = value;\n                    return this;\n                }\n            }\n            return nativePropFunction.apply(this, arguments);\n        };\n    })();\n}\n// / endregion\n// endregion\n// region vim modline\n// vim: set tabstop=4 shiftwidth=4 expandtab:\n// vim: foldmethod=marker foldmarker=region,endregion:\n// endregion\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/webpack/buildin/module.js */ 2)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9pbmRleC5qcz8xNjg3Iiwid2VicGFjazovLy8/ZDQxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLy8gIyEvdXNyL2Jpbi9lbnYgbm9kZVxuLy8gLSotIGNvZGluZzogdXRmLTggLSotXG4vKiogQG1vZHVsZSBjbGllbnRub2RlICovXG4ndXNlIHN0cmljdCdcbi8qICFcbiAgICByZWdpb24gaGVhZGVyXG4gICAgW1Byb2plY3QgcGFnZV0oaHR0cDovL3RvcmJlbi53ZWJzaXRlL2NsaWVudG5vZGUpXG5cbiAgICBDb3B5cmlnaHQgVG9yYmVuIFNpY2tlcnQgKGluZm9bXCJ+YXR+XCJddG9yYmVuLndlYnNpdGUpIDE2LjEyLjIwMTJcblxuICAgIExpY2Vuc2VcbiAgICAtLS0tLS0tXG5cbiAgICBUaGlzIGxpYnJhcnkgd3JpdHRlbiBieSBUb3JiZW4gU2lja2VydCBzdGFuZCB1bmRlciBhIGNyZWF0aXZlIGNvbW1vbnNcbiAgICBuYW1pbmcgMy4wIHVucG9ydGVkIGxpY2Vuc2UuXG4gICAgU2VlIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LzMuMC9kZWVkLmRlXG4gICAgZW5kcmVnaW9uXG4qL1xuLy8gcmVnaW9uIGltcG9ydHNcbmltcG9ydCB0eXBlIHtEb21Ob2RlLCBQbGFpbk9iamVjdH0gZnJvbSAnd2Vib3B0aW1pemVyL3R5cGUnXG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiB0eXBlc1xuZXhwb3J0IHR5cGUgR2V0dGVyRnVuY3Rpb24gPSAoa2V5T3JWYWx1ZTphbnkpID0+IGFueVxuZXhwb3J0IHR5cGUgU2V0dGVyRnVuY3Rpb24gPSAoa2V5OmFueSwgdmFsdWU6YW55KSA9PiBhbnlcbmV4cG9ydCB0eXBlIFBvc2l0aW9uID0ge1xuICAgIHRvcD86bnVtYmVyO1xuICAgIGxlZnQ/Om51bWJlcjtcbiAgICByaWdodD86bnVtYmVyO1xuICAgIGJvdHRvbT86bnVtYmVyO1xufVxuZXhwb3J0IHR5cGUgUmVsYXRpdmVQb3NpdGlvbiA9ICdpbid8J2Fib3ZlJ3wnbGVmdCd8J2JlbG93J3wncmlnaHQnXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICAgIGRvbU5vZGVTZWxlY3RvclByZWZpeDpzdHJpbmc7XG4gICAgW2tleTpzdHJpbmddOmFueTtcbn1cbmV4cG9ydCB0eXBlIExvY2tDYWxsYmFja0Z1bmN0aW9uID0gKGRlc2NyaXB0aW9uOnN0cmluZykgPT4gdm9pZFxuZXhwb3J0IHR5cGUgJERvbU5vZGUgPSB7XG4gICAgW2tleTpudW1iZXJ8c3RyaW5nXTpEb21Ob2RlO1xuICAgIGFkZENsYXNzKGNsYXNzTmFtZTpzdHJpbmcpOiREb21Ob2RlO1xuICAgIGFkZEJhY2soKTokRG9tTm9kZTtcbiAgICBhZnRlcihkb21Ob2RlOmFueSk6JERvbU5vZGU7XG4gICAgYXBwZW5kKGRvbU5vZGU6YW55KTokRG9tTm9kZTtcbiAgICBhdHRyKGF0dHJpYnV0ZU5hbWU6c3RyaW5nfHtba2V5OnN0cmluZ106c3RyaW5nfSwgdmFsdWU6YW55KTphbnk7XG4gICAgZGF0YShrZXk6c3RyaW5nLCB2YWx1ZTphbnkpOmFueTtcbiAgICBlYWNoKCk6JERvbU5vZGU7XG4gICAgZmluZChmaWx0ZXI6YW55KTokRG9tTm9kZTtcbiAgICBoZWlnaHQoKTpudW1iZXI7XG4gICAgaXMoc2VsZWN0b3I6c3RyaW5nKTpib29sZWFuO1xuICAgIHJlbW92ZSgpOiREb21Ob2RlO1xuICAgIHJlbW92ZUF0dHIoYXR0cmlidXRlTmFtZTpzdHJpbmcpOiREb21Ob2RlO1xuICAgIHJlbW92ZUNsYXNzKGNsYXNzTmFtZTpzdHJpbmd8QXJyYXk8c3RyaW5nPik6JERvbU5vZGU7XG4gICAgc3VibWl0KCk6JERvbU5vZGU7XG4gICAgd2lkdGgoKTpudW1iZXI7XG4gICAgVG9vbHMoZnVuY3Rpb25OYW1lOnN0cmluZywgLi4uYWRkaXRpb25hbEFyZ3VtZW50czpBcnJheTxhbnk+KTphbnk7XG59XG5leHBvcnQgdHlwZSAkRGVmZXJyZWQ8VHlwZT4gPSB7XG4gICAgYWx3YXlzOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICByZXNvbHZlOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBkb25lOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBmYWlsOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBpc1JlamVjdGVkOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBpc1Jlc29sdmVkOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBub3RpZnk6KCkgPT4gJERlZmVycmVkPFR5cGU+O1xuICAgIG5vdGlmeVdpdGg6KCkgPT4gJERlZmVycmVkPFR5cGU+O1xuICAgIHByb2dyZXNzOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBwcm9taXNlOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICByZWplY3Q6KCkgPT4gJERlZmVycmVkPFR5cGU+O1xuICAgIHJlamVjdFdpdGg6KCkgPT4gJERlZmVycmVkPFR5cGU+O1xuICAgIHJlc29sdmVXaXRoOigpID0+ICREZWZlcnJlZDxUeXBlPjtcbiAgICBzdGF0ZTooKSA9PiAkRGVmZXJyZWQ8VHlwZT47XG4gICAgdGhlbjooKSA9PiAkRGVmZXJyZWQ8VHlwZT47XG59XG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiBkZXRlcm1pbmUgY29udGV4dFxuZXhwb3J0IGNvbnN0IGdsb2JhbENvbnRleHQ6T2JqZWN0ID0gKCgpOk9iamVjdCA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpID8ge30gOiBtb2R1bGVcbiAgICAgICAgaWYgKCd3aW5kb3cnIGluIGdsb2JhbClcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWwud2luZG93XG4gICAgICAgIHJldHVybiBnbG9iYWxcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvd1xufSkoKVxuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbmV4cG9ydCBjb25zdCAkID0gKCgpOmFueSA9PiB7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4gICAgbGV0ICQ6YW55XG4gICAgaWYgKCckJyBpbiBnbG9iYWxDb250ZXh0ICYmIGdsb2JhbENvbnRleHQuJCAhPT0gbnVsbClcbiAgICAgICAgJCA9IGdsb2JhbENvbnRleHQuJFxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoISgnJCcgaW4gZ2xvYmFsQ29udGV4dCkpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1aXJlKCdqcXVlcnknKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yOmFueSA9IChcbiAgICAgICAgICAgICdkb2N1bWVudCcgaW4gZ2xvYmFsQ29udGV4dCAmJlxuICAgICAgICAgICAgJ3F1ZXJ5U2VsZWN0b3JBbGwnIGluIGdsb2JhbENvbnRleHQuZG9jdW1lbnRcbiAgICAgICAgKSA/IGdsb2JhbENvbnRleHQuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCA6ICgpOm51bGwgPT4gbnVsbFxuICAgICAgICAkID0gZnVuY3Rpb24ocGFyYW1ldGVyOmFueSk6YW55IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRkb21Ob2RlczpBcnJheTxhbnk+ID0gc2VsZWN0b3IuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbENvbnRleHQuZG9jdW1lbnQsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICBpZiAoJ2ZuJyBpbiAkKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gJC5mbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmZuLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGRvbU5vZGVzW2tleV0gPSAkLmZuW2tleV0uYmluZCgkZG9tTm9kZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRkb21Ob2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbiAgICAgICAgICAgIGlmIChUb29scy5pc0Z1bmN0aW9uKHBhcmFtZXRlcikgJiYgJ2RvY3VtZW50JyBpbiBnbG9iYWxDb250ZXh0KVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuICAgICAgICAgICAgICAgIGdsb2JhbENvbnRleHQuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgJ0RPTUNvbnRlbnRMb2FkZWQnLCBwYXJhbWV0ZXIpXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyXG4gICAgICAgIH1cbiAgICAgICAgJC5mbiA9IHt9XG4gICAgfVxuICAgIHJldHVybiAkXG59KSgpXG5pZiAoISgnZ2xvYmFsJyBpbiAkKSlcbiAgICAkLmdsb2JhbCA9IGdsb2JhbENvbnRleHRcbmlmICghKCdjb250ZXh0JyBpbiAkKSAmJiAnZG9jdW1lbnQnIGluICQuZ2xvYmFsKVxuICAgICQuY29udGVzdCA9ICQuZ2xvYmFsLmRvY3VtZW50XG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiBwbHVnaW5zL2NsYXNzZXNcbi8qKlxuICogVGhpcyBwbHVnaW4gcHJvdmlkZXMgc3VjaCBpbnRlcmZhY2UgbG9naWMgbGlrZSBnZW5lcmljIGNvbnRyb2xsZXIgbG9naWMgZm9yXG4gKiBpbnRlZ3JhdGluZyBwbHVnaW5zIGludG8gJCwgbXV0dWFsIGV4Y2x1c2lvbiBmb3IgZGVwZW5kaW5nIGd1aSBlbGVtZW50cyxcbiAqIGxvZ2dpbmcgYWRkaXRpb25hbCBzdHJpbmcsIGFycmF5IG9yIGZ1bmN0aW9uIGhhbmRsaW5nLiBBIHNldCBvZiBoZWxwZXJcbiAqIGZ1bmN0aW9ucyB0byBwYXJzZSBvcHRpb24gb2JqZWN0cyBkb20gdHJlZXMgb3IgaGFuZGxlIGV2ZW50cyBpcyBhbHNvXG4gKiBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6YWJicmV2aWF0aW9ucyAtIExpc3RzIGFsbCBrbm93biBhYmJyZXZpYXRpb24gZm9yIHByb3BlclxuICogY2FtZWwgY2FzZSB0byBkZWxpbWl0ZWQgYW5kIGJhY2sgY29udmVyc2lvbi5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6YW5pbWF0aW9uRW5kRXZlbnROYW1lcyAtIFNhdmVzIGEgc3RyaW5nIHdpdGggYWxsIGNzczNcbiAqIGJyb3dzZXIgc3BlY2lmaWMgYW5pbWF0aW9uIGVuZCBldmVudCBuYW1lcy5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6a2V5Q29kZSAtIFNhdmVzIGEgbWFwcGluZyBmcm9tIGtleSBjb2RlcyB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBuYW1lLlxuICogQHByb3BlcnR5IHN0YXRpYzptYXhpbWFsU3VwcG9ydGVkSW50ZXJuZXRFeHBsb3JlclZlcnNpb24gLSBTYXZlcyBjdXJyZW50bHlcbiAqIG1pbmltYWwgc3VwcG9ydGVkIGludGVybmV0IGV4cGxvcmVyIHZlcnNpb24uIFNhdmVzIHplcm8gaWYgbm8gaW50ZXJuZXRcbiAqIGV4cGxvcmVyIHByZXNlbnQuXG4gKiBAcHJvcGVydHkgc3RhdGljOnRyYW5zaXRpb25FbmRFdmVudE5hbWVzIC0gU2F2ZXMgYSBzdHJpbmcgd2l0aCBhbGwgY3NzM1xuICogYnJvd3NlciBzcGVjaWZpYyB0cmFuc2l0aW9uIGVuZCBldmVudCBuYW1lcy5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6Y29uc29sZU1ldGhvZE5hbWVzIC0gVGhpcyB2YXJpYWJsZSBjb250YWlucyBhIGNvbGxlY3Rpb24gb2ZcbiAqIG1ldGhvZHMgdXN1YWxseSBiaW5kZWQgdG8gdGhlIGNvbnNvbGUgb2JqZWN0LlxuICogQHByb3BlcnR5IHN0YXRpYzpfamF2YVNjcmlwdERlcGVuZGVudENvbnRlbnRIYW5kbGVkIC0gSW5kaWNhdGVzIHdoZXRoZXJcbiAqIGphdmFTY3JpcHQgZGVwZW5kZW50IGNvbnRlbnQgd2hlcmUgaGlkZSBvciBzaG93bi5cbiAqIEBwcm9wZXJ0eSBzdGF0aWM6X25hbWUgLSBEZWZpbmVzIHRoaXMgY2xhc3MgbmFtZSB0byBhbGxvdyByZXRyaWV2aW5nIHRoZW1cbiAqIGFmdGVyIG5hbWUgbWFuZ2xpbmcuXG4gKiBAcHJvcGVydHkgJGRvbU5vZGUgLSAkLWV4dGVuZGVkIGRvbSBub2RlIGlmIG9uZSB3YXMgZ2l2ZW4gdG8gdGhlIGNvbnN0cnVjdG9yXG4gKiBtZXRob2QuXG4gKiBAcHJvcGVydHkgX29wdGlvbnMgLSBPcHRpb25zIGdpdmVuIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEBwcm9wZXJ0eSBfZGVmYXVsdE9wdGlvbnMgLSBGYWxsYmFjayBvcHRpb25zIGlmIG5vdCBvdmVyd3JpdHRlbiBieSB0aGVcbiAqIG9wdGlvbnMgZ2l2ZW4gdG8gdGhlIGNvbnN0cnVjdG9yIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSBfZGVmYXVsdE9wdGlvbnMubG9nZ2luZyB7Ym9vbGVhbn0gLSBJbmRpY2F0ZXMgd2hldGhlciBsb2dnaW5nXG4gKiBzaG91bGQgYmUgYWN0aXZlLlxuICogQHByb3BlcnR5IF9kZWZhdWx0T3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXgge3N0cmluZ30gLSBTZWxlY3RvciBwcmVmaXhcbiAqIGZvciBhbGwgbmVlZGVkIGRvbSBub2Rlcy5cbiAqIEBwcm9wZXJ0eSBfZGVmYXVsdE9wdGlvbnMuZG9tTm9kZSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IC0gTWFwcGluZyBvZlxuICogbmFtZXMgdG8gbmVlZGVkIGRvbSBub2RlcyByZWZlcmVuY2VkIGJ5IHRoZXJlIHNlbGVjdG9yLlxuICogQHByb3BlcnR5IF9kZWZhdWx0T3B0aW9ucy5kb21Ob2RlLmhpZGVKYXZhU2NyaXB0RW5hYmxlZCB7c3RyaW5nfSAtIFNlbGVjdG9yXG4gKiB0byBkb20gbm9kZXMgd2hpY2ggc2hvdWxkIGJlIGhpZGRlbiBpZiBqYXZhU2NyaXB0IGlzIGF2YWlsYWJsZS5cbiAqIEBwcm9wZXJ0eSBfZGVmYXVsdE9wdGlvbnMuZG9tTm9kZS5zaG93SmF2YVNjcmlwdEVuYWJsZWQge3N0cmluZ30gLSBTZWxlY3RvclxuICogdG8gZG9tIG5vZGVzIHdoaWNoIHNob3VsZCBiZSB2aXNpYmxlIGlmIGphdmFTY3JpcHQgaXMgYXZhaWxhYmxlLlxuICogQHByb3BlcnR5IF9sb2NrcyAtIE1hcHBpbmcgb2YgbG9jayBkZXNjcmlwdGlvbnMgdG8gdGhlcmUgY29ycmVzcG9uZGluZ1xuICogY2FsbGJhY2tzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29scyB7XG4gICAgLy8gcmVnaW9uIHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgc3RhdGljIGFiYnJldmlhdGlvbnM6QXJyYXk8c3RyaW5nPiA9IFtcbiAgICAgICAgJ2h0bWwnLCAnaWQnLCAndXJsJywgJ3VzJywgJ2RlJywgJ2FwaScsICdocmVmJ11cbiAgICBzdGF0aWMgYW5pbWF0aW9uRW5kRXZlbnROYW1lczpzdHJpbmcgPSAnYW5pbWF0aW9uZW5kIHdlYmtpdEFuaW1hdGlvbkVuZCAnICtcbiAgICAgICAgJ29BbmltYXRpb25FbmQgTVNBbmltYXRpb25FbmQnXG4gICAgc3RhdGljIGNsYXNzVG9UeXBlTWFwcGluZzp7W2tleTpzdHJpbmddOnN0cmluZ30gPSB7XG4gICAgICAgICdbb2JqZWN0IEFycmF5XSc6ICdhcnJheScsXG4gICAgICAgICdbb2JqZWN0IEJvb2xlYW5dJzogJ2Jvb2xlYW4nLFxuICAgICAgICAnW29iamVjdCBEYXRlXSc6ICdkYXRlJyxcbiAgICAgICAgJ1tvYmplY3QgRXJyb3JdJzogJ2Vycm9yJyxcbiAgICAgICAgJ1tvYmplY3QgRnVuY3Rpb25dJzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgJ1tvYmplY3QgTnVtYmVyXSc6ICdudW1iZXInLFxuICAgICAgICAnW29iamVjdCBPYmplY3RdJzogJ29iamVjdCcsXG4gICAgICAgICdbb2JqZWN0IFJlZ0V4cF0nOiAncmVnZXhwJyxcbiAgICAgICAgJ1tvYmplY3QgU3RyaW5nXSc6ICdzdHJpbmcnXG4gICAgfVxuICAgIHN0YXRpYyBrZXlDb2RlOntba2V5OnN0cmluZ106bnVtYmVyfSA9IHtcbiAgICAgICAgQkFDS1NQQUNFOiA4LFxuICAgICAgICBDT01NQTogMTg4LFxuICAgICAgICBERUxFVEU6IDQ2LFxuICAgICAgICBET1dOOiA0MCxcbiAgICAgICAgRU5EOiAzNSxcbiAgICAgICAgRU5URVI6IDEzLFxuICAgICAgICBFU0NBUEU6IDI3LFxuICAgICAgICBIT01FOiAzNixcbiAgICAgICAgTEVGVDogMzcsXG4gICAgICAgIE5VTVBBRF9BREQ6IDEwNyxcbiAgICAgICAgTlVNUEFEX0RFQ0lNQUw6IDExMCxcbiAgICAgICAgTlVNUEFEX0RJVklERTogMTExLFxuICAgICAgICBOVU1QQURfRU5URVI6IDEwOCxcbiAgICAgICAgTlVNUEFEX01VTFRJUExZOiAxMDYsXG4gICAgICAgIE5VTVBBRF9TVUJUUkFDVDogMTA5LFxuICAgICAgICBQQUdFX0RPV046IDM0LFxuICAgICAgICBQQUdFX1VQOiAzMyxcbiAgICAgICAgUEVSSU9EOiAxOTAsXG4gICAgICAgIFJJR0hUOiAzOSxcbiAgICAgICAgU1BBQ0U6IDMyLFxuICAgICAgICBUQUI6IDksXG4gICAgICAgIFVQOiAzOFxuICAgIH1cbiAgICBzdGF0aWMgbWF4aW1hbFN1cHBvcnRlZEludGVybmV0RXhwbG9yZXJWZXJzaW9uOm51bWJlciA9ICgoKTpudW1iZXIgPT4ge1xuICAgICAgICBpZiAoISgnZG9jdW1lbnQnIGluICQuZ2xvYmFsKSlcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIGNvbnN0IGRpdiA9ICQuZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGxldCB2ZXJzaW9uOm51bWJlclxuICAgICAgICBmb3IgKHZlcnNpb24gPSAwOyB2ZXJzaW9uIDwgMTA7IHZlcnNpb24rKykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBOT1RFOiBXZSBzcGxpdCBodG1sIGNvbW1lbnQgc2VxdWVuY2VzIHRvIGF2b2lkIHdyb25nXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0YXRpb24gaWYgdGhpcyBjb2RlIGlzIGVtYmVkZGVkIGluIG1hcmt1cC5cbiAgICAgICAgICAgICAgICBOT1RFOiBJbnRlcm5ldCBFeHBsb3JlciA5IGFuZCBsb3dlciBzb21ldGltZXMgZG9lc24ndFxuICAgICAgICAgICAgICAgIHVuZGVyc3RhbmQgY29uZGl0aW9uYWwgY29tbWVudHMgd2ljaCBkb2Vzbid0IHN0YXJ0cyB3aXRoIGFcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlLiBJZiB0aGUgY29uZGl0aW9uYWwgbWFya3VwIGlzbid0IGluIGEgY29tbWVuZC5cbiAgICAgICAgICAgICAgICBPdGhlcndpc2UgdGhlcmUgc2hvdWxkbid0IGJlIGFueSB3aGl0ZXNwYWNlIVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtY29uY2F0ICovXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gKFxuICAgICAgICAgICAgICAgICc8IScgKyBgLS1baWYgZ3QgSUUgJHt2ZXJzaW9ufV0+PGk+PC9pPjwhW2VgICsgJ25kaWZdLScgKyAnLT4nKVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11c2VsZXNzLWNvbmNhdCAqL1xuICAgICAgICAgICAgaWYgKGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSBzcGVjaWFsIGRldGVjdGlvbiBmb3IgaW50ZXJuZXQgZXhwbG9yZXIgMTAgYW5kIDExLlxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCAmJiAnbmF2aWdhdG9yJyBpbiAkLmdsb2JhbClcbiAgICAgICAgICAgIGlmICgkLmdsb2JhbC5uYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmNsdWRlcygnTVNJRSAxMCcpKVxuICAgICAgICAgICAgICAgIHJldHVybiAxMFxuICAgICAgICAgICAgZWxzZSBpZiAoJC5nbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgICAnVHJpZGVudCdcbiAgICAgICAgICAgICkgJiYgJC5nbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygncnY6MTEnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMTFcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICB9KSgpXG4gICAgc3RhdGljIG5vb3AgPSAoJ25vb3AnIGluICQpID8gJC5ub29wIDogKCk6dm9pZCA9PiB7fVxuICAgIHN0YXRpYyBzcGVjaWFsUmVnZXhTZXF1ZW5jZXM6QXJyYXk8c3RyaW5nPiA9IFtcbiAgICAgICAgJy0nLCAnWycsICddJywgJygnLCAnKScsICdeJywgJyQnLCAnKicsICcrJywgJy4nLCAneycsICd9J11cbiAgICBzdGF0aWMgdHJhbnNpdGlvbkVuZEV2ZW50TmFtZXM6c3RyaW5nID0gJ3RyYW5zaXRpb25lbmQgJyArXG4gICAgICAgICd3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIE1TVHJhbnNpdGlvbkVuZCdcbiAgICBzdGF0aWMgY29uc29sZU1ldGhvZE5hbWVzOkFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICdhc3NlcnQnLFxuICAgICAgICAnY2xlYXInLFxuICAgICAgICAnY291bnQnLFxuICAgICAgICAnZGVidWcnLFxuICAgICAgICAnZGlyJyxcbiAgICAgICAgJ2RpcnhtbCcsXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgICdleGNlcHRpb24nLFxuICAgICAgICAnZ3JvdXAnLFxuICAgICAgICAnZ3JvdXBDb2xsYXBzZWQnLFxuICAgICAgICAnZ3JvdXBFbmQnLFxuICAgICAgICAnaW5mbycsXG4gICAgICAgICdsb2cnLFxuICAgICAgICAnbWFya1RpbWVsaW5lJyxcbiAgICAgICAgJ3Byb2ZpbGUnLFxuICAgICAgICAncHJvZmlsZUVuZCcsXG4gICAgICAgICd0YWJsZScsXG4gICAgICAgICd0aW1lJyxcbiAgICAgICAgJ3RpbWVFbmQnLFxuICAgICAgICAndGltZVN0YW1wJyxcbiAgICAgICAgJ3RyYWNlJyxcbiAgICAgICAgJ3dhcm4nXG4gICAgXVxuICAgIHN0YXRpYyBfamF2YVNjcmlwdERlcGVuZGVudENvbnRlbnRIYW5kbGVkOmJvb2xlYW4gPSBmYWxzZVxuICAgIHN0YXRpYyBfbmFtZTpzdHJpbmcgPSAnVG9vbHMnXG4gICAgLy8gZW5kcmVnaW9uXG4gICAgLy8gcmVnaW9uIGR5bmFtaWMgcHJvcGVydGllc1xuICAgICRkb21Ob2RlOiREb21Ob2RlXG4gICAgX29wdGlvbnM6T3B0aW9uc1xuICAgIF9kZWZhdWx0T3B0aW9uczpQbGFpbk9iamVjdFxuICAgIF9sb2Nrczp7W2tleTpzdHJpbmddOkFycmF5PExvY2tDYWxsYmFja0Z1bmN0aW9uPn07XG4gICAgLy8gZW5kcmVnaW9uXG4gICAgLy8gcmVnaW9uIHB1YmxpYyBtZXRob2RzXG4gICAgLy8gLyByZWdpb24gc3BlY2lhbFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBub3JtYWxseS4gSXQgaXMgdHJpZ2dlcmVkIGlmIGN1cnJlbnRcbiAgICAgKiBvYmplY3QgaXMgY3JlYXRlZCB2aWEgdGhlIFwibmV3XCIga2V5d29yZC4gVGhlIGRvbSBub2RlIHNlbGVjdG9yIHByZWZpeFxuICAgICAqIGVuZm9yY2VzIHRvIG5vdCBnbG9iYWxseSBzZWxlY3QgYW55IGRvbSBub2RlcyB3aGljaCBhcmVuJ3QgaW4gdGhlXG4gICAgICogZXhwZWN0ZWQgc2NvcGUgb2YgdGhpcyBwbHVnaW4uIFwiezF9XCIgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHdpdGhcbiAgICAgKiB0aGlzIHBsdWdpbiBuYW1lIHN1ZmZpeCAoXCJ0b29sc1wiKS4gWW91IGRvbid0IGhhdmUgdG8gdXNlIFwiezF9XCIgYnV0IGl0XG4gICAgICogY2FuIGhlbHAgeW91IHRvIHdyaXRlIGNvZGUgd2hpY2ggaXMgbW9yZSByZWNvbmNpbGFibGUgd2l0aCB0aGUgZHJ5XG4gICAgICogY29uY2VwdC5cbiAgICAgKiBAcGFyYW0gJGRvbU5vZGUgLSAkLWV4dGVuZGVkIGRvbSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UgaW4gdmFyaW91c1xuICAgICAqIG1ldGhvZHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNoYW5nZSBydW50aW1lIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0T3B0aW9ucyAtIERlZmF1bHQgb3B0aW9ucyB0byBlbnN1cmUgdG8gYmUgcHJlc2VudCBpbiBhbnlcbiAgICAgKiBvcHRpb25zIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBsb2NrcyAtIE1hcHBpbmcgb2YgYSBsb2NrIGRlc2NyaXB0aW9uIHRvIGNhbGxiYWNrcyBmb3IgY2FsbGluZ1xuICAgICAqIHdoZW4gZ2l2ZW4gbG9jayBzaG91bGQgYmUgcmVsZWFzZWQuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBub3RoaW5nIGJ1dCBpZiBpbnZva2VkIHdpdGggXCJuZXdcIiBhbiBpbnN0YW5jZSBvZiB0aGlzXG4gICAgICogY2xhc3Mgd2lsbCBiZSBnaXZlbiBiYWNrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAkZG9tTm9kZTo/JERvbU5vZGUgPSBudWxsLCBvcHRpb25zOk9iamVjdCA9IHt9LFxuICAgICAgICBkZWZhdWx0T3B0aW9uczpQbGFpbk9iamVjdCA9IHtcbiAgICAgICAgICAgIGxvZ2dpbmc6IGZhbHNlLCBkb21Ob2RlU2VsZWN0b3JQcmVmaXg6ICdib2R5JywgZG9tTm9kZToge1xuICAgICAgICAgICAgICAgIGhpZGVKYXZhU2NyaXB0RW5hYmxlZDogJy50b29scy1oaWRkZW4tb24tamF2YXNjcmlwdC1lbmFibGVkJyxcbiAgICAgICAgICAgICAgICBzaG93SmF2YVNjcmlwdEVuYWJsZWQ6ICcudG9vbHMtdmlzaWJsZS1vbi1qYXZhc2NyaXB0LWVuYWJsZWQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGxvY2tzOntba2V5OnN0cmluZ106QXJyYXk8TG9ja0NhbGxiYWNrRnVuY3Rpb24+fSA9IHt9XG4gICAgKTp2b2lkIHtcbiAgICAgICAgaWYgKCRkb21Ob2RlKVxuICAgICAgICAgICAgdGhpcy4kZG9tTm9kZSA9ICRkb21Ob2RlXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNcbiAgICAgICAgdGhpcy5fbG9ja3MgPSBsb2Nrc1xuICAgICAgICAvLyBBdm9pZCBlcnJvcnMgaW4gYnJvd3NlcnMgdGhhdCBsYWNrIGEgY29uc29sZS5cbiAgICAgICAgaWYgKCEoJ2NvbnNvbGUnIGluICQuZ2xvYmFsKSlcbiAgICAgICAgICAgICQuZ2xvYmFsLmNvbnNvbGUgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWU6c3RyaW5nIG9mIHRoaXMuY29uc3RydWN0b3IuY29uc29sZU1ldGhvZE5hbWVzKVxuICAgICAgICAgICAgaWYgKCEobWV0aG9kTmFtZSBpbiAkLmdsb2JhbC5jb25zb2xlKSlcbiAgICAgICAgICAgICAgICAkLmdsb2JhbC5jb25zb2xlW21ldGhvZE5hbWVdID0gdGhpcy5jb25zdHJ1Y3Rvci5ub29wXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF0aGlzLmNvbnN0cnVjdG9yLl9qYXZhU2NyaXB0RGVwZW5kZW50Q29udGVudEhhbmRsZWQgJiZcbiAgICAgICAgICAgICdkb2N1bWVudCcgaW4gJC5nbG9iYWwgJiYgJ2ZpbHRlcicgaW4gJCAmJiAnaGlkZScgaW4gJCAmJlxuICAgICAgICAgICAgJ3Nob3cnIGluICRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9qYXZhU2NyaXB0RGVwZW5kZW50Q29udGVudEhhbmRsZWQgPSB0cnVlXG4gICAgICAgICAgICAkKFxuICAgICAgICAgICAgICAgIGAke3RoaXMuX2RlZmF1bHRPcHRpb25zLmRvbU5vZGVTZWxlY3RvclByZWZpeH0gYCArXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMuZG9tTm9kZS5oaWRlSmF2YVNjcmlwdEVuYWJsZWRcbiAgICAgICAgICAgICkuZmlsdGVyKGZ1bmN0aW9uKCk6Ym9vbGVhbiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEkKHRoaXMpLmRhdGEoJ2phdmFTY3JpcHREZXBlbmRlbnRDb250ZW50SGlkZScpXG4gICAgICAgICAgICB9KS5kYXRhKCdqYXZhU2NyaXB0RGVwZW5kZW50Q29udGVudEhpZGUnLCB0cnVlKS5oaWRlKClcbiAgICAgICAgICAgICQoXG4gICAgICAgICAgICAgICAgYCR7dGhpcy5fZGVmYXVsdE9wdGlvbnMuZG9tTm9kZVNlbGVjdG9yUHJlZml4fSBgICtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0T3B0aW9ucy5kb21Ob2RlLnNob3dKYXZhU2NyaXB0RW5hYmxlZFxuICAgICAgICAgICAgKS5maWx0ZXIoZnVuY3Rpb24oKTpib29sZWFuIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISQodGhpcykuZGF0YSgnamF2YVNjcmlwdERlcGVuZGVudENvbnRlbnRTaG93JylcbiAgICAgICAgICAgIH0pLmRhdGEoJ2phdmFTY3JpcHREZXBlbmRlbnRDb250ZW50U2hvdycsIHRydWUpLnNob3coKVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNvdWxkIGJlIG92ZXJ3cml0dGVuIG5vcm1hbGx5LiBJdCBhY3RzIGxpa2UgYSBkZXN0cnVjdG9yLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGVzdHJ1Y3RvcigpOlRvb2xzIHtcbiAgICAgICAgaWYgKCdvZmYnIGluICQuZm4pXG4gICAgICAgICAgICB0aGlzLm9mZignKicpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBub3JtYWxseS4gSXQgaXMgdHJpZ2dlcmVkIGlmIGN1cnJlbnRcbiAgICAgKiBvYmplY3Qgd2FzIGNyZWF0ZWQgdmlhIHRoZSBcIm5ld1wiIGtleXdvcmQgYW5kIGlzIGNhbGxlZCBub3cuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGluaXRpYWxpemUob3B0aW9uczpQbGFpbk9iamVjdCA9IHt9KTpUb29scyB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICBOT1RFOiBXZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCBpbnN0YW5jZSB0byBhdm9pZFxuICAgICAgICAgICAgY2hhbmdpbmcgYSBzdGF0aWMgb3B0aW9ucyBvYmplY3QuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLmNvbnN0cnVjdG9yLmV4dGVuZE9iamVjdChcbiAgICAgICAgICAgIHRydWUsIHt9LCB0aGlzLl9kZWZhdWx0T3B0aW9ucywgdGhpcy5fb3B0aW9ucywgb3B0aW9ucylcbiAgICAgICAgLypcbiAgICAgICAgICAgIFRoZSBzZWxlY3RvciBwcmVmaXggc2hvdWxkIGJlIHBhcnNlZCBhZnRlciBleHRlbmRpbmcgb3B0aW9uc1xuICAgICAgICAgICAgYmVjYXVzZSB0aGUgc2VsZWN0b3Igd291bGQgYmUgb3ZlcndyaXR0ZW4gb3RoZXJ3aXNlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcHRpb25zLmRvbU5vZGVTZWxlY3RvclByZWZpeCA9IHRoaXMuY29uc3RydWN0b3Iuc3RyaW5nRm9ybWF0KFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXgsXG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN0cmluZ0NhbWVsQ2FzZVRvRGVsaW1pdGVkKHRoaXMuY29uc3RydWN0b3IuX25hbWUpKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIG9iamVjdCBvcmllbnRhdGlvblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb24tY29tcGxldGUtc2VudGVuY2UgKi9cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgZ2VuZXJpYyBjb250cm9sbGVyIGZvciBkb20gbm9kZSBhd2FyZSBwbHVnaW5zLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IG9yIGNsYXNzIHRvIGNvbnRyb2wuIElmIFwib2JqZWN0XCIgaXMgYSBjbGFzc1xuICAgICAqIGFuIGluc3RhbmNlIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXIgLSBUaGUgaW5pdGlhbGx5IGdpdmVuIGFyZ3VtZW50cyBvYmplY3QuXG4gICAgICogQHBhcmFtICRkb21Ob2RlIC0gT3B0aW9uYWxseSBhICQtZXh0ZW5kZWQgZG9tIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHdoYXRldmVyIHRoZSBpbml0aWFsaXplciBtZXRob2QgcmV0dXJucy5cbiAgICAgKi9cbiAgICBjb250cm9sbGVyKFxuICAgICAgICBvYmplY3Q6T2JqZWN0LCBwYXJhbWV0ZXI6QXJyYXk8YW55PiwgJGRvbU5vZGU6PyREb21Ob2RlID0gbnVsbFxuICAgICk6YW55IHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb24tY29tcGxldGUtc2VudGVuY2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG5ldyBvYmplY3QoJGRvbU5vZGUpXG4gICAgICAgICAgICBpZiAoIW9iamVjdCBpbnN0YW5jZW9mIFRvb2xzKVxuICAgICAgICAgICAgICAgIG9iamVjdCA9IHRoaXMuY29uc3RydWN0b3IuZXh0ZW5kT2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICB0cnVlLCBuZXcgVG9vbHMoKSwgb2JqZWN0KVxuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlciA9IHRoaXMuY29uc3RydWN0b3IuYXJyYXlNYWtlKHBhcmFtZXRlcilcbiAgICAgICAgaWYgKCRkb21Ob2RlICYmICdkYXRhJyBpbiAkZG9tTm9kZSAmJiAhJGRvbU5vZGUuZGF0YShcbiAgICAgICAgICAgIG9iamVjdC5jb25zdHJ1Y3Rvci5fbmFtZVxuICAgICAgICApKVxuICAgICAgICAgICAgLy8gQXR0YWNoIGV4dGVuZGVkIG9iamVjdCB0byB0aGUgYXNzb2NpYXRlZCBkb20gbm9kZS5cbiAgICAgICAgICAgICRkb21Ob2RlLmRhdGEob2JqZWN0LmNvbnN0cnVjdG9yLl9uYW1lLCBvYmplY3QpXG4gICAgICAgIGlmIChwYXJhbWV0ZXJbMF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtwYXJhbWV0ZXJbMF1dLmFwcGx5KG9iamVjdCwgcGFyYW1ldGVyLnNsaWNlKDEpKVxuICAgICAgICBlbHNlIGlmIChwYXJhbWV0ZXIubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBwYXJhbWV0ZXJbMF0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBJZiBhbiBvcHRpb25zIG9iamVjdCBvciBubyBtZXRob2QgbmFtZSBpcyBnaXZlbiB0aGUgaW5pdGlhbGl6ZXJcbiAgICAgICAgICAgICAgICB3aWxsIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0LmluaXRpYWxpemUuYXBwbHkob2JqZWN0LCBwYXJhbWV0ZXIpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYE1ldGhvZCBcIiR7cGFyYW1ldGVyWzBdfVwiIGRvZXMgbm90IGV4aXN0IG9uICQtZXh0ZW5kZWQgZG9tIG5vZGUgYCArXG4gICAgICAgICAgICBgXCIke29iamVjdC5jb25zdHJ1Y3Rvci5fbmFtZX1cIi5gKVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIG11dHVhbCBleGNsdXNpb25cbiAgICAvKipcbiAgICAgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIGludHJvZHVjZXMgYSBzdGFydGluZyBwb2ludCBmb3IgYSBjcml0aWNhbCBhcmVhIHdpdGhcbiAgICAgKiBwb3RlbnRpYWwgcmFjZSBjb25kaXRpb25zLiBUaGUgYXJlYSB3aWxsIGJlIGJpbmRlZCB0byBnaXZlbiBkZXNjcmlwdGlvblxuICAgICAqIHN0cmluZy4gU28gZG9uJ3QgdXNlIHNhbWUgbmFtZXMgZm9yIGRpZmZlcmVudCBhcmVhcy5cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gLSBBIHNob3J0IHN0cmluZyBkZXNjcmliaW5nIHRoZSBjcml0aWNhbCBhcmVhc1xuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrRnVuY3Rpb24gLSBBIHByb2NlZHVyZSB3aGljaCBzaG91bGQgb25seSBiZSBleGVjdXRlZCBpZlxuICAgICAqIHRoZSBpbnRlcnByZXRlciBpc24ndCBpbiB0aGUgZ2l2ZW4gY3JpdGljYWwgYXJlYS4gVGhlIGxvY2sgZGVzY3JpcHRpb25cbiAgICAgKiBzdHJpbmcgd2lsbCBiZSBnaXZlbiB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGF1dG9SZWxlYXNlIC0gUmVsZWFzZSB0aGUgbG9jayBhZnRlciBleGVjdXRpb24gb2YgZ2l2ZW4gY2FsbGJhY2suXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBhY3F1aXJlTG9jayhcbiAgICAgICAgZGVzY3JpcHRpb246c3RyaW5nLCBjYWxsYmFja0Z1bmN0aW9uOkxvY2tDYWxsYmFja0Z1bmN0aW9uLFxuICAgICAgICBhdXRvUmVsZWFzZTpib29sZWFuID0gZmFsc2VcbiAgICApOlRvb2xzIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrRnVuY3Rpb246TG9ja0NhbGxiYWNrRnVuY3Rpb24gPSAoXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjpzdHJpbmdcbiAgICAgICAgKTp2b2lkID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrRnVuY3Rpb24oZGVzY3JpcHRpb24pXG4gICAgICAgICAgICBpZiAoYXV0b1JlbGVhc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlTG9jayhkZXNjcmlwdGlvbilcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbG9ja3MuaGFzT3duUHJvcGVydHkoZGVzY3JpcHRpb24pKVxuICAgICAgICAgICAgdGhpcy5fbG9ja3NbZGVzY3JpcHRpb25dLnB1c2god3JhcHBlZENhbGxiYWNrRnVuY3Rpb24pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbG9ja3NbZGVzY3JpcHRpb25dID0gW11cbiAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFja0Z1bmN0aW9uKGRlc2NyaXB0aW9uKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxpbmcgdGhpcyBtZXRob2QgIGNhdXNlcyB0aGUgZ2l2ZW4gY3JpdGljYWwgYXJlYSB0byBiZSBmaW5pc2hlZCBhbmRcbiAgICAgKiBhbGwgZnVuY3Rpb25zIGdpdmVuIHRvIFwidGhpcy5hY3F1aXJlTG9jaygpXCIgd2lsbCBiZSBleGVjdXRlZCBpbiByaWdodFxuICAgICAqIG9yZGVyLlxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiAtIEEgc2hvcnQgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGNyaXRpY2FsIGFyZWFzXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbGVhc2VMb2NrKGRlc2NyaXB0aW9uOnN0cmluZyk6VG9vbHMge1xuICAgICAgICBpZiAodGhpcy5fbG9ja3MuaGFzT3duUHJvcGVydHkoZGVzY3JpcHRpb24pKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2tzW2Rlc2NyaXB0aW9uXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9ja3NbZGVzY3JpcHRpb25dLnNoaWZ0KCkoZGVzY3JpcHRpb24pXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvY2tzW2Rlc2NyaXB0aW9uXVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgaXRzIGFyZ3VtZW50IHJlcHJlc2VudHMgYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGFuYWx5emUuXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgbnVtZXJpY1xuICAgICAqIGxpa2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzTnVtZXJpYyhvYmplY3Q6YW55KTpib29sZWFuIHtcbiAgICAgICAgY29uc3QgdHlwZTpzdHJpbmcgPSBUb29scy5kZXRlcm1pbmVUeXBlKG9iamVjdClcbiAgICAgICAgLypcbiAgICAgICAgICAgIE5PVEU6IFwicGFyc2VGbG9hdFwiIFwiTmFOc1wiIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpIGJ1dFxuICAgICAgICAgICAgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzXG4gICAgICAgICAgICAoXCIweC4uLlwiKSBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU4uXG4gICAgICAgICovXG4gICAgICAgIHJldHVybiBbJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlKSAmJiAhaXNOYU4oXG4gICAgICAgICAgICBvYmplY3QgLSBwYXJzZUZsb2F0KG9iamVjdCkpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhIHdpbmRvdy5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNXaW5kb3cob2JqZWN0OmFueSk6Ym9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAhW3VuZGVmaW5lZCwgbnVsbF0uaW5jbHVkZXMob2JqZWN0KSAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgJ3dpbmRvdycgaW4gb2JqZWN0ICYmXG4gICAgICAgICAgICBvYmplY3QgPT09IG9iamVjdC53aW5kb3cpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiBvYmplY3QgaXMgc2ltaWxhciB0byBhbiBhcnJheSBhbmQgY2FuIGJlIGhhbmRsZWQgbGlrZSBhblxuICAgICAqIGFycmF5LlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgYmVoYXZpb3IgZm9yLlxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGFycmF5IGxpa2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzQXJyYXlMaWtlKG9iamVjdDphbnkpOmJvb2xlYW4ge1xuICAgICAgICBsZXQgbGVuZ3RoOm51bWJlcnxib29sZWFuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZW5ndGggPSBCb29sZWFuKFxuICAgICAgICAgICAgICAgIG9iamVjdFxuICAgICAgICAgICAgKSAmJiAnbGVuZ3RoJyBpbiBvYmplY3QgJiYgb2JqZWN0Lmxlbmd0aFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZTpzdHJpbmcgPSBUb29scy5kZXRlcm1pbmVUeXBlKG9iamVjdClcbiAgICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicgfHwgVG9vbHMuaXNXaW5kb3cob2JqZWN0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2FycmF5JyB8fCBsZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgICAgICAgICAgICAgb2JqZWN0W2xlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvbmUgb2YgdGhlIGdpdmVuIHBhdHRlcm4gbWF0Y2hlcyBnaXZlbiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRhcmdldCB0byBjaGVjayBpbiBwYXR0ZXJuIGZvci5cbiAgICAgKiBAcGFyYW0gcGF0dGVybiAtIExpc3Qgb2YgcGF0dGVybiB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybnMgVmFsdWUgXCJ0cnVlXCIgaWYgZ2l2ZW4gb2JqZWN0IGlzIG1hdGNoZXMgYnkgYXQgbGVhcyBvbmUgb2YgdGhlXG4gICAgICogZ2l2ZW4gcGF0dGVybiBhbmQgXCJmYWxzZVwiIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNBbnlNYXRjaGluZyh0YXJnZXQ6c3RyaW5nLCBwYXR0ZXJuOkFycmF5PHN0cmluZ3xSZWdFeHA+KTpib29sZWFuIHtcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50UGF0dGVybjpSZWdFeHB8c3RyaW5nIG9mIHBhdHRlcm4pXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRQYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGF0dGVybiA9PT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UGF0dGVybi50ZXN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHBsYWluIG5hdGl2ZSBvYmplY3QuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBcInRydWVcIiBpZiBnaXZlbiBvYmplY3QgaXMgYSBwbGFpbiBqYXZhU2NyaXB0IG9iamVjdCBhbmRcbiAgICAgKiBcImZhbHNlXCIgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1BsYWluT2JqZWN0KG9iamVjdDptaXhlZCk6Ym9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBPYmplY3QucHJvdG90eXBlKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFZhbHVlIFwidHJ1ZVwiIGlmIGdpdmVuIG9iamVjdCBpcyBhIGZ1bmN0aW9uIGFuZCBcImZhbHNlXCJcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24ob2JqZWN0Om1peGVkKTpib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqZWN0KSAmJiB7fS50b1N0cmluZy5jYWxsKFxuICAgICAgICAgICAgb2JqZWN0XG4gICAgICAgICkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICB9XG4gICAgLy8gLyBlbmRyZWdpb25cbiAgICAvLyAvIHJlZ2lvbiBsYW5ndWFnZSBmaXhlc1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGZpeGVzIGFuIHVnbHkgamF2YVNjcmlwdCBidWcuIElmIHlvdSBhZGQgYSBtb3VzZW91dCBldmVudFxuICAgICAqIGxpc3RlbmVyIHRvIGEgZG9tIG5vZGUgdGhlIGdpdmVuIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgZWFjaCB0aW1lIGFueVxuICAgICAqIGRvbSBub2RlIGluc2lkZSB0aGUgb2JzZXJ2ZWQgZG9tIG5vZGUgdHJpZ2dlcnMgYSBtb3VzZW91dCBldmVudC4gVGhpc1xuICAgICAqIG1ldGhvZHMgZ3VhcmFudGVlcyB0aGF0IHRoZSBnaXZlbiBldmVudCBoYW5kbGVyIGlzIG9ubHkgY2FsbGVkIGlmIHRoZVxuICAgICAqIG9ic2VydmVkIGRvbSBub2RlIHdhcyBsZWF2ZWQuXG4gICAgICogQHBhcmFtIGV2ZW50SGFuZGxlciAtIFRoZSBtb3VzZSBvdXQgZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBnaXZlbiBmdW5jdGlvbiB3cmFwcGVkIGJ5IHRoZSB3b3JrYXJvdW5kIGxvZ2ljLlxuICAgICAqL1xuICAgIHN0YXRpYyBtb3VzZU91dEV2ZW50SGFuZGxlckZpeChldmVudEhhbmRsZXI6RnVuY3Rpb24pOkZ1bmN0aW9uIHtcbiAgICAgICAgY29uc3Qgc2VsZjpPYmplY3QgPSB0aGlzXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudDpPYmplY3QpOmFueSB7XG4gICAgICAgICAgICBsZXQgcmVsYXRlZFRhcmdldDpEb21Ob2RlID0gZXZlbnQudG9FbGVtZW50XG4gICAgICAgICAgICBpZiAoJ3JlbGF0ZWRUYXJnZXQnIGluIGV2ZW50KVxuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0XG4gICAgICAgICAgICB3aGlsZSAocmVsYXRlZFRhcmdldCAmJiByZWxhdGVkVGFyZ2V0LnRhZ05hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldC5wYXJlbnROb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGxvZ2dpbmdcbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgZ2l2ZW4gb2JqZWN0J3MgcmVwcmVzZW50YXRpb24gaW4gdGhlIGJyb3dzZXJzIGNvbnNvbGUgaWZcbiAgICAgKiBwb3NzaWJsZSBvciBpbiBhIHN0YW5kYWxvbmUgYWxlcnQtd2luZG93IGFzIGZhbGxiYWNrLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBBbnkgb2JqZWN0IHRvIHByaW50LlxuICAgICAqIEBwYXJhbSBmb3JjZSAtIElmIHNldCB0byBcInRydWVcIiBnaXZlbiBpbnB1dCB3aWxsIGJlIHNob3duIGluZGVwZW5kZW50bHlcbiAgICAgKiBmcm9tIGN1cnJlbnQgbG9nZ2luZyBjb25maWd1cmF0aW9uIG9yIGludGVycHJldGVyJ3MgY29uc29sZVxuICAgICAqIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSBhdm9pZEFubm90YXRpb24gLSBJZiBzZXQgdG8gXCJ0cnVlXCIgZ2l2ZW4gaW5wdXQgaGFzIG5vIG1vZHVsZSBvclxuICAgICAqIGxvZyBsZXZlbCBzcGVjaWZpYyBhbm5vdGF0aW9ucy5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgLSBEZXNjcmlwdGlvbiBvZiBsb2cgbWVzc2FnZXMgaW1wb3J0YW5jZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIGZvciBzdHJpbmdcbiAgICAgKiBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBsb2coXG4gICAgICAgIG9iamVjdDphbnksIGZvcmNlOmJvb2xlYW4gPSBmYWxzZSwgYXZvaWRBbm5vdGF0aW9uOmJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgbGV2ZWw6c3RyaW5nID0gJ2luZm8nLCAuLi5hZGRpdGlvbmFsQXJndW1lbnRzOkFycmF5PGFueT5cbiAgICApOlRvb2xzIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubG9nZ2luZyB8fCBmb3JjZSB8fCBbJ2Vycm9yJywgJ2NyaXRpY2FsJ10uaW5jbHVkZXMoXG4gICAgICAgICAgICBsZXZlbFxuICAgICAgICApKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZTphbnlcbiAgICAgICAgICAgIGlmIChhdm9pZEFubm90YXRpb24pXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG9iamVjdFxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzLnVuc2hpZnQob2JqZWN0KVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLmNvbnN0cnVjdG9yLl9uYW1lfSAoJHtsZXZlbH0pOiBgICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdHJpbmdGb3JtYXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLCBhZGRpdGlvbmFsQXJndW1lbnRzKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnN0cnVjdG9yLmlzTnVtZXJpYyhcbiAgICAgICAgICAgICAgICBvYmplY3RcbiAgICAgICAgICAgICkgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLmNvbnN0cnVjdG9yLl9uYW1lfSAoJHtsZXZlbH0pOiBgICtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnRvU3RyaW5nKClcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCcsLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0sJylcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhvYmplY3QsIGZvcmNlLCB0cnVlKVxuICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1wiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgaWYgKCEoJ2NvbnNvbGUnIGluICQuZ2xvYmFsICYmIGxldmVsIGluICQuZ2xvYmFsLmNvbnNvbGUpIHx8IChcbiAgICAgICAgICAgICAgICAgICAgJC5nbG9iYWwuY29uc29sZVtsZXZlbF0gPT09IHRoaXMuY29uc3RydWN0b3Iubm9vcFxuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdhbGVydCcgaW4gJC5nbG9iYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmdsb2JhbC5hbGVydChtZXNzYWdlKVxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAkLmdsb2JhbC5jb25zb2xlW2xldmVsXShtZXNzYWdlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgbWV0aG9kIGZvciB0aGUgbmF0aXZlIGNvbnNvbGUgbWV0aG9kIHVzdWFsbHkgcHJvdmlkZWQgYnlcbiAgICAgKiBpbnRlcnByZXRlci5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gQW55IG9iamVjdCB0byBwcmludC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIGZvciBzdHJpbmdcbiAgICAgKiBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBpbmZvKG9iamVjdDphbnksIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55Pik6VG9vbHMge1xuICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nLmFwcGx5KHRoaXMsIFtvYmplY3QsIGZhbHNlLCBmYWxzZSwgJ2luZm8nXS5jb25jYXQoXG4gICAgICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzKSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBtZXRob2QgZm9yIHRoZSBuYXRpdmUgY29uc29sZSBtZXRob2QgdXN1YWxseSBwcm92aWRlZCBieVxuICAgICAqIGludGVycHJldGVyLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBBbnkgb2JqZWN0IHRvIHByaW50LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQXJndW1lbnRzIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgZm9yIHN0cmluZ1xuICAgICAqIGZvcm1hdGluZy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGRlYnVnKG9iamVjdDphbnksIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55Pik6VG9vbHMge1xuICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nLmFwcGx5KHRoaXMsIFtvYmplY3QsIGZhbHNlLCBmYWxzZSwgJ2RlYnVnJ10uY29uY2F0KFxuICAgICAgICAgICAgYWRkaXRpb25hbEFyZ3VtZW50cykpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgbWV0aG9kIGZvciB0aGUgbmF0aXZlIGNvbnNvbGUgbWV0aG9kIHVzdWFsbHkgcHJvdmlkZWQgYnlcbiAgICAgKiBpbnRlcnByZXRlci5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gQW55IG9iamVjdCB0byBwcmludC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIGZvciBzdHJpbmdcbiAgICAgKiBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBlcnJvcihvYmplY3Q6YW55LCAuLi5hZGRpdGlvbmFsQXJndW1lbnRzOkFycmF5PGFueT4pOlRvb2xzIHtcbiAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgIHJldHVybiB0aGlzLmxvZy5hcHBseSh0aGlzLCBbb2JqZWN0LCB0cnVlLCBmYWxzZSwgJ2Vycm9yJ10uY29uY2F0KFxuICAgICAgICAgICAgYWRkaXRpb25hbEFyZ3VtZW50cykpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgbWV0aG9kIGZvciB0aGUgbmF0aXZlIGNvbnNvbGUgbWV0aG9kIHVzdWFsbHkgcHJvdmlkZWQgYnlcbiAgICAgKiBpbnRlcnByZXRlci5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gQW55IG9iamVjdCB0byBwcmludC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIGZvciBzdHJpbmdcbiAgICAgKiBmb3JtYXRpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjcml0aWNhbChvYmplY3Q6YW55LCAuLi5hZGRpdGlvbmFsQXJndW1lbnRzOkFycmF5PGFueT4pOlRvb2xzIHtcbiAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgIHJldHVybiB0aGlzLmxvZy5hcHBseSh0aGlzLCBbb2JqZWN0LCB0cnVlLCBmYWxzZSwgJ3dhcm4nXS5jb25jYXQoXG4gICAgICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzKSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBtZXRob2QgZm9yIHRoZSBuYXRpdmUgY29uc29sZSBtZXRob2QgdXN1YWxseSBwcm92aWRlZCBieVxuICAgICAqIGludGVycHJldGVyLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBBbnkgb2JqZWN0IHRvIHByaW50LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQXJndW1lbnRzIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgZm9yIHN0cmluZ1xuICAgICAqIGZvcm1hdGluZy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHdhcm4ob2JqZWN0OmFueSwgLi4uYWRkaXRpb25hbEFyZ3VtZW50czpBcnJheTxhbnk+KTpUb29scyB7XG4gICAgICAgIC8vIElnbm9yZVR5cGVDaGVja1xuICAgICAgICByZXR1cm4gdGhpcy5sb2cuYXBwbHkodGhpcywgW29iamVjdCwgZmFsc2UsIGZhbHNlLCAnd2FybiddLmNvbmNhdChcbiAgICAgICAgICAgIGFkZGl0aW9uYWxBcmd1bWVudHMpKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEdW1wcyBhIGdpdmVuIG9iamVjdCBpbiBhIGh1bWFuIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gQW55IG9iamVjdCB0byBzaG93LlxuICAgICAqIEBwYXJhbSBsZXZlbCAtIE51bWJlciBvZiBsZXZlbHMgdG8gZGlnIGludG8gZ2l2ZW4gb2JqZWN0IHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwYXJhbSBjdXJyZW50TGV2ZWwgLSBNYXhpbWFsIG51bWJlciBvZiByZWN1cnNpdmUgZnVuY3Rpb24gY2FsbHMgdG9cbiAgICAgKiByZXByZXNlbnQgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiBnaXZlbiBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIHNob3cob2JqZWN0OmFueSwgbGV2ZWw6bnVtYmVyID0gMywgY3VycmVudExldmVsOm51bWJlciA9IDApOnN0cmluZyB7XG4gICAgICAgIGxldCBvdXRwdXQ6c3RyaW5nID0gJydcbiAgICAgICAgaWYgKFRvb2xzLmRldGVybWluZVR5cGUob2JqZWN0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBvYmplY3QpXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBgJHtrZXkudG9TdHJpbmcoKX06IGBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA8PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBUb29scy5zaG93KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBsZXZlbCwgY3VycmVudExldmVsICsgMSlcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAke29iamVjdFtrZXldfWBcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9ICdcXG4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC50cmltKClcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSBgJHtvYmplY3R9YC50cmltKClcbiAgICAgICAgcmV0dXJuIGAke291dHB1dH0gKFR5cGU6IFwiJHtUb29scy5kZXRlcm1pbmVUeXBlKG9iamVjdCl9XCIpYFxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGRvbSBub2RlXG4gICAgLyoqXG4gICAgICogR2V0IHRleHQgY29udGVudCBvZiBjdXJyZW50IGVsZW1lbnQgd2l0aG91dCBpdCBjaGlsZHJlbidzIHRleHQgY29udGVudHMuXG4gICAgICogQHJldHVybnMgVGhlIHRleHQgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldFRleHQoKTpzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy4kZG9tTm9kZS5jbG9uZSgpLmNoaWxkcmVuKCkucmVtb3ZlKCkuZW5kKCkudGV4dCgpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgY2xhc3MgbmFtZSBvcmRlciBvZiBjdXJyZW50IGRvbSBub2RlLlxuICAgICAqIEByZXR1cm5zIEN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgbm9ybWFsaXplQ2xhc3NOYW1lcygpOlRvb2xzIHtcbiAgICAgICAgdGhpcy4kZG9tTm9kZS5maW5kKCcqJykuYWRkQmFjaygpLmVhY2goZnVuY3Rpb24oKTp2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzRG9tTm9kZTokRG9tTm9kZSA9ICQodGhpcylcbiAgICAgICAgICAgIGlmICgkdGhpc0RvbU5vZGUuYXR0cignY2xhc3MnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZENsYXNzTmFtZXM6QXJyYXk8c3RyaW5nPiA9ICR0aGlzRG9tTm9kZS5hdHRyKFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnXG4gICAgICAgICAgICAgICAgKS5zcGxpdCgnICcpLnNvcnQoKSB8fCBbXVxuICAgICAgICAgICAgICAgICR0aGlzRG9tTm9kZS5hdHRyKCdjbGFzcycsICcnKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2xhc3NOYW1lOnN0cmluZyBvZiBzb3J0ZWRDbGFzc05hbWVzKVxuICAgICAgICAgICAgICAgICAgICAkdGhpc0RvbU5vZGUuYWRkQ2xhc3MoY2xhc3NOYW1lKVxuICAgICAgICAgICAgfSBlbHNlIGlmICgkdGhpc0RvbU5vZGUuaXMoJ1tjbGFzc10nKSlcbiAgICAgICAgICAgICAgICAkdGhpc0RvbU5vZGUucmVtb3ZlQXR0cignY2xhc3MnKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHN0eWxlIGF0dHJpYnV0ZXMgb3JkZXIgb2YgY3VycmVudCBkb20gbm9kZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgbm9ybWFsaXplU3R5bGVzKCk6VG9vbHMge1xuICAgICAgICBjb25zdCBzZWxmOlRvb2xzID0gdGhpc1xuICAgICAgICB0aGlzLiRkb21Ob2RlLmZpbmQoJyonKS5hZGRCYWNrKCkuZWFjaChmdW5jdGlvbigpOnZvaWQge1xuICAgICAgICAgICAgY29uc3QgJHRoaXNEb21Ob2RlOiREb21Ob2RlID0gJCh0aGlzKVxuICAgICAgICAgICAgbGV0IHNlcmlhbGl6ZWRTdHlsZXM6P3N0cmluZyA9ICR0aGlzRG9tTm9kZS5hdHRyKCdzdHlsZScpXG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZFN0eWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZFN0eWxlczpBcnJheTxzdHJpbmc+ID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25zdHJ1Y3Rvci5zdHJpbmdDb21wcmVzc1N0eWxlVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkU3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICkuc3BsaXQoJzsnKS5zb3J0KCkgfHwgW11cbiAgICAgICAgICAgICAgICAkdGhpc0RvbU5vZGUuYXR0cignc3R5bGUnLCAnJylcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0eWxlOnN0cmluZyBvZiBzb3J0ZWRTdHlsZXMpXG4gICAgICAgICAgICAgICAgICAgICR0aGlzRG9tTm9kZS5jc3MuYXBwbHkoJHRoaXNEb21Ob2RlLCBzdHlsZS50cmltKCkuc3BsaXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAnOicpKVxuICAgICAgICAgICAgICAgICR0aGlzRG9tTm9kZS5hdHRyKFxuICAgICAgICAgICAgICAgICAgICAnc3R5bGUnLCBzZWxmLmNvbnN0cnVjdG9yLnN0cmluZ0NvbXByZXNzU3R5bGVWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzRG9tTm9kZS5hdHRyKCdzdHlsZScpKSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHRoaXNEb21Ob2RlLmlzKCdbc3R5bGVdJykpXG4gICAgICAgICAgICAgICAgJHRoaXNEb21Ob2RlLnJlbW92ZUF0dHIoJ3N0eWxlJylcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gaHRtbCBvciB0ZXh0IHN0cmluZ3MgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSBmaXJzdCAtIEZpcnN0IGh0bWwsIHNlbGVjdG9yIHRvIGRvbSBub2RlIG9yIHRleHQgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIC0gU2Vjb25kIGh0bWwsIHNlbGVjdG9yIHRvIGRvbSBub2RlICBvciB0ZXh0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIGZvcmNlSFRNTFN0cmluZyAtIEluZGljYXRlcyB3aGV0aGVyIGdpdmVuIGNvbnRlbnRzIGFyZVxuICAgICAqIGludGVycHJldGVkIGFzIGh0bWwgc3RyaW5nIChvdGhlcndpc2UgYW4gYXV0b21hdGljIGRldGVjdGlvbiB3aWxsIGJlXG4gICAgICogdHJpZ2dlcmVkKS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgYm90aCBkb20gcmVwcmVzZW50YXRpb25zIGFyZSBlcXVpdmFsZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VxdWl2YWxlbnREb20oXG4gICAgICAgIGZpcnN0OmFueSwgc2Vjb25kOmFueSwgZm9yY2VIVE1MU3RyaW5nOmJvb2xlYW4gPSBmYWxzZVxuICAgICk6Ym9vbGVhbiB7XG4gICAgICAgIGlmIChmaXJzdCA9PT0gc2Vjb25kKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgaWYgKGZpcnN0ICYmIHNlY29uZCkge1xuICAgICAgICAgICAgY29uc3QgZGV0ZW1lcm1pbmVIVE1MUGF0dGVybjpSZWdFeHAgPVxuICAgICAgICAgICAgICAgIC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvXG4gICAgICAgICAgICBjb25zdCBpbnB1dHM6e2ZpcnN0OmFueTtzZWNvbmQ6YW55fSA9IHtmaXJzdCwgc2Vjb25kfVxuICAgICAgICAgICAgY29uc3QgJGRvbU5vZGVzOntmaXJzdDokRG9tTm9kZTtzZWNvbmQ6JERvbU5vZGV9ID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0OiAkKCc8ZHVtbXk+JyksIHNlY29uZDogJCgnPGR1bW15PicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIE5PVEU6IEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBcIjxcIiBhbmQgZW5kIHdpdGggXCI+XCIgYXJlXG4gICAgICAgICAgICAgICAgbWFya3VwIGFuZCBza2lwIHRoZSBtb3JlIGV4cGVuc2l2ZSByZWd1bGFyIGV4cHJlc3Npb24gY2hlY2suXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlOnN0cmluZyBvZiBbJ2ZpcnN0JywgJ3NlY29uZCddKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRzW3R5cGVdID09PSAnc3RyaW5nJyAmJiAoZm9yY2VIVE1MU3RyaW5nIHx8IChcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzW3R5cGVdLnN0YXJ0c1dpdGgoJzwnKSAmJlxuICAgICAgICAgICAgICAgICAgICBpbnB1dHNbdHlwZV0uZW5kc1dpdGgoJz4nKSAmJiBpbnB1dHNbdHlwZV0ubGVuZ3RoID49IDMgfHxcbiAgICAgICAgICAgICAgICAgICAgZGV0ZW1lcm1pbmVIVE1MUGF0dGVybi50ZXN0KGlucHV0c1t0eXBlXSlcbiAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICAgICAgJGRvbU5vZGVzW3R5cGVdID0gJChgPGRpdj4ke2lucHV0c1t0eXBlXX08L2Rpdj5gKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCAkc2VsZWN0ZWREb21Ob2RlOiREb21Ob2RlID0gJChpbnB1dHNbdHlwZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNlbGVjdGVkRG9tTm9kZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGRvbU5vZGVzW3R5cGVdID0gJCgnPGRpdj4nKS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZWxlY3RlZERvbU5vZGUuY2xvbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJGRvbU5vZGVzLmZpcnN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICRkb21Ob2Rlcy5maXJzdC5sZW5ndGggPT09ICRkb21Ob2Rlcy5zZWNvbmQubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAkZG9tTm9kZXMuZmlyc3QgPSAkZG9tTm9kZXMuZmlyc3QuVG9vbHMoXG4gICAgICAgICAgICAgICAgICAgICdub3JtYWxpemVDbGFzc05hbWVzJ1xuICAgICAgICAgICAgICAgICkuJGRvbU5vZGUuVG9vbHMoJ25vcm1hbGl6ZVN0eWxlcycpLiRkb21Ob2RlXG4gICAgICAgICAgICAgICAgJGRvbU5vZGVzLnNlY29uZCA9ICRkb21Ob2Rlcy5zZWNvbmQuVG9vbHMoXG4gICAgICAgICAgICAgICAgICAgICdub3JtYWxpemVDbGFzc05hbWVzJ1xuICAgICAgICAgICAgICAgICkuJGRvbU5vZGUuVG9vbHMoJ25vcm1hbGl6ZVN0eWxlcycpLiRkb21Ob2RlXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4Om51bWJlciA9IDBcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRvbU5vZGU6RG9tTm9kZSBvZiAkZG9tTm9kZXMuZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZS5pc0VxdWFsTm9kZSgkZG9tTm9kZXMuc2Vjb25kW2luZGV4XSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXJlIGN1cnJlbnQgZG9tIG5vZGUgaXMgcmVsYXRpdmUgdG8gY3VycmVudCB2aWV3IHBvcnRcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gZGVsdGEgLSBBbGxvd3MgZGVsdGFzIGZvciBcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiBhbmQgXCJyaWdodFwiIGZvclxuICAgICAqIGRldGVybWluaW5nIHBvc2l0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIG9uZSBvZiBcImFib3ZlXCIsIFwibGVmdFwiLCBcImJlbG93XCIsIFwicmlnaHRcIiBvciBcImluXCIuXG4gICAgICovXG4gICAgZ2V0UG9zaXRpb25SZWxhdGl2ZVRvVmlld3BvcnQoZGVsdGE6UG9zaXRpb24gPSB7fSk6UmVsYXRpdmVQb3NpdGlvbiB7XG4gICAgICAgIGRlbHRhID0gdGhpcy5jb25zdHJ1Y3Rvci5leHRlbmRPYmplY3QoXG4gICAgICAgICAgICB7dG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IDAsIHJpZ2h0OiAwfSwgZGVsdGEpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICd3aW5kb3cnIGluICQuZ2xvYmFsICYmIHRoaXMuJGRvbU5vZGUgJiYgdGhpcy4kZG9tTm9kZS5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMuJGRvbU5vZGVbMF1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCAkd2luZG93OiREb21Ob2RlID0gJCgkLmdsb2JhbC53aW5kb3cpXG4gICAgICAgICAgICBjb25zdCByZWN0YW5nbGU6UG9zaXRpb24gPSB0aGlzLiRkb21Ob2RlWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICBpZiAoKHJlY3RhbmdsZS50b3AgKyBkZWx0YS50b3ApIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Fib3ZlJ1xuICAgICAgICAgICAgaWYgKChyZWN0YW5nbGUubGVmdCArIGRlbHRhLmxlZnQpIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2xlZnQnXG4gICAgICAgICAgICBpZiAoJHdpbmRvdy5oZWlnaHQoKSA8IChyZWN0YW5nbGUuYm90dG9tICsgZGVsdGEuYm90dG9tKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2JlbG93J1xuICAgICAgICAgICAgaWYgKCR3aW5kb3cud2lkdGgoKSA8IChyZWN0YW5nbGUucmlnaHQgKyBkZWx0YS5yaWdodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdyaWdodCdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2luJ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBkaXJlY3RpdmUgbmFtZSBjb3JyZXNwb25kaW5nIHNlbGVjdG9yIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZGlyZWN0aXZlTmFtZSAtIFRoZSBkaXJlY3RpdmUgbmFtZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGdlbmVyYXRlZCBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGVEaXJlY3RpdmVTZWxlY3RvcihkaXJlY3RpdmVOYW1lOnN0cmluZyk6c3RyaW5nIHtcbiAgICAgICAgY29uc3QgZGVsaW1pdGVkTmFtZTpzdHJpbmcgPSBUb29scy5zdHJpbmdDYW1lbENhc2VUb0RlbGltaXRlZChcbiAgICAgICAgICAgIGRpcmVjdGl2ZU5hbWUpXG4gICAgICAgIHJldHVybiBgJHtkZWxpbWl0ZWROYW1lfSwgLiR7ZGVsaW1pdGVkTmFtZX0sIFske2RlbGltaXRlZE5hbWV9XSwgYCArXG4gICAgICAgICAgICBgW2RhdGEtJHtkZWxpbWl0ZWROYW1lfV0sIFt4LSR7ZGVsaW1pdGVkTmFtZX1dYCArIChcbiAgICAgICAgICAgICAgICAoZGVsaW1pdGVkTmFtZS5pbmNsdWRlcygnLScpID8gKFxuICAgICAgICAgICAgICAgICAgICBgLCBbJHtkZWxpbWl0ZWROYW1lLnJlcGxhY2UoLy0vZywgJ1xcXFw6Jyl9XSwgYCArXG4gICAgICAgICAgICAgICAgICAgIGBbJHtkZWxpbWl0ZWROYW1lLnJlcGxhY2UoLy0vZywgJ18nKX1dYCkgOiAnJykpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkaXJlY3RpdmUgbmFtZSBjb3JyZXNwb25kaW5nIGNsYXNzIG9yIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gZGlyZWN0aXZlTmFtZSAtIFRoZSBkaXJlY3RpdmUgbmFtZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGN1cnJlbnQgZG9tIG5vZGUuXG4gICAgICovXG4gICAgcmVtb3ZlRGlyZWN0aXZlKGRpcmVjdGl2ZU5hbWU6c3RyaW5nKTokRG9tTm9kZSB7XG4gICAgICAgIGNvbnN0IGRlbGltaXRlZE5hbWU6c3RyaW5nID1cbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3RyaW5nQ2FtZWxDYXNlVG9EZWxpbWl0ZWQoZGlyZWN0aXZlTmFtZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuJGRvbU5vZGUucmVtb3ZlQ2xhc3MoZGVsaW1pdGVkTmFtZSkucmVtb3ZlQXR0cihcbiAgICAgICAgICAgIGRlbGltaXRlZE5hbWVcbiAgICAgICAgKS5yZW1vdmVBdHRyKGBkYXRhLSR7ZGVsaW1pdGVkTmFtZX1gKS5yZW1vdmVBdHRyKFxuICAgICAgICAgICAgYHgtJHtkZWxpbWl0ZWROYW1lfWBcbiAgICAgICAgKS5yZW1vdmVBdHRyKGRlbGltaXRlZE5hbWUucmVwbGFjZSgnLScsICc6JykpLnJlbW92ZUF0dHIoXG4gICAgICAgICAgICBkZWxpbWl0ZWROYW1lLnJlcGxhY2UoJy0nLCAnXycpKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGEgbm9ybWFsaXplZCBjYW1lbCBjYXNlIGRpcmVjdGl2ZSBuYW1lIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSBkaXJlY3RpdmVOYW1lIC0gVGhlIGRpcmVjdGl2ZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgbmFtZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Tm9ybWFsaXplZERpcmVjdGl2ZU5hbWUoZGlyZWN0aXZlTmFtZTpzdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIGZvciAoY29uc3QgZGVsaW1pdGVyOnN0cmluZyBvZiBbJy0nLCAnOicsICdfJ10pIHtcbiAgICAgICAgICAgIGxldCBwcmVmaXhGb3VuZDpib29sZWFuID0gZmFsc2VcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZml4OnN0cmluZyBvZiBbYGRhdGEke2RlbGltaXRlcn1gLCBgeCR7ZGVsaW1pdGVyfWBdKVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3RpdmVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlTmFtZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4Rm91bmQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZWZpeEZvdW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkZWxpbWl0ZXI6c3RyaW5nIG9mIFsnLScsICc6JywgJ18nXSlcbiAgICAgICAgICAgIGRpcmVjdGl2ZU5hbWUgPSBUb29scy5zdHJpbmdEZWxpbWl0ZWRUb0NhbWVsQ2FzZShcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVOYW1lLCBkZWxpbWl0ZXIpXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVOYW1lXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYSBkaXJlY3RpdmUgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBkaXJlY3RpdmVOYW1lIC0gVGhlIGRpcmVjdGl2ZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIHZhbHVlIG9yIFwibnVsbFwiIGlmIG5vXG4gICAgICogYXR0cmlidXRlIHZhbHVlIGV4aXN0cy5cbiAgICAgKi9cbiAgICBnZXREaXJlY3RpdmVWYWx1ZShkaXJlY3RpdmVOYW1lOnN0cmluZyk6P3N0cmluZyB7XG4gICAgICAgIGNvbnN0IGRlbGltaXRlZE5hbWU6c3RyaW5nID1cbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3RyaW5nQ2FtZWxDYXNlVG9EZWxpbWl0ZWQoZGlyZWN0aXZlTmFtZSlcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lOnN0cmluZyBvZiBbXG4gICAgICAgICAgICBkZWxpbWl0ZWROYW1lLCBgZGF0YS0ke2RlbGltaXRlZE5hbWV9YCwgYHgtJHtkZWxpbWl0ZWROYW1lfWAsXG4gICAgICAgICAgICBkZWxpbWl0ZWROYW1lLnJlcGxhY2UoJy0nLCAnXFxcXDonKVxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTpzdHJpbmcgPSB0aGlzLiRkb21Ob2RlLmF0dHIoYXR0cmlidXRlTmFtZSlcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzZWxlY3RvciBwcmVmaXggZnJvbSBhIGdpdmVuIHNlbGVjdG9yLiBUaGlzIG1ldGhvZHMgc2VhcmNoZXNcbiAgICAgKiBpbiB0aGUgb3B0aW9ucyBvYmplY3QgZm9yIGEgZ2l2ZW4gXCJkb21Ob2RlU2VsZWN0b3JQcmVmaXhcIi5cbiAgICAgKiBAcGFyYW0gZG9tTm9kZVNlbGVjdG9yIC0gVGhlIGRvbSBub2RlIHNlbGVjdG9yIHRvIHNsaWNlLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNsaWNlZCBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBzbGljZURvbU5vZGVTZWxlY3RvclByZWZpeChkb21Ob2RlU2VsZWN0b3I6c3RyaW5nKTpzdHJpbmcge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAnZG9tTm9kZVNlbGVjdG9yUHJlZml4JyBpbiB0aGlzLl9vcHRpb25zICYmXG4gICAgICAgICAgICBkb21Ob2RlU2VsZWN0b3Iuc3RhcnRzV2l0aCh0aGlzLl9vcHRpb25zLmRvbU5vZGVTZWxlY3RvclByZWZpeClcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGVTZWxlY3Rvci5zdWJzdHJpbmcoXG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXgubGVuZ3RoXG4gICAgICAgICAgICApLnRyaW0oKVxuICAgICAgICByZXR1cm4gZG9tTm9kZVNlbGVjdG9yXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGRvbSBub2RlIG5hbWUgb2YgYSBnaXZlbiBkb20gbm9kZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIGRvbU5vZGVTZWxlY3RvciAtIEEgZ2l2ZW4gdG8gZG9tIG5vZGUgc2VsZWN0b3IgdG8gZGV0ZXJtaW5lIGl0c1xuICAgICAqIG5hbWUuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBUaGUgZG9tIG5vZGUgbmFtZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJldHVybnMgJ2RpdidcbiAgICAgKiAkLlRvb2xzLmdldERvbU5vZGVOYW1lKCcmbHQ7ZGl2Jmd0OycpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm5zICdkaXYnXG4gICAgICogJC5Ub29scy5nZXREb21Ob2RlTmFtZSgnJmx0O2RpdiZndDsmbHQ7L2RpdiZndDsnKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcmV0dXJucyAnYnInXG4gICAgICogJC5Ub29scy5nZXREb21Ob2RlTmFtZSgnJmx0O2JyLyZndDsnKVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREb21Ob2RlTmFtZShkb21Ob2RlU2VsZWN0b3I6c3RyaW5nKTo/c3RyaW5nIHtcbiAgICAgICAgY29uc3QgbWF0Y2g6P0FycmF5PHN0cmluZz4gPSBkb21Ob2RlU2VsZWN0b3IubWF0Y2goXG4gICAgICAgICAgICBuZXcgUmVnRXhwKCdePD8oW2EtekEtWl0rKS4qPj8uKicpKVxuICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBvZiBkb20gc2VsZWN0b3JzIHRvIGFuIGFycmF5IG9mICQgd3JhcHBlZCBkb20gbm9kZXMuXG4gICAgICogTm90ZSBpZiBzZWxlY3RvciBkZXNjcmlwdGlvbiBhcyBvbmUgb2YgXCJjbGFzc1wiIG9yIFwiaWRcIiBhcyBzdWZmaXggZWxlbWVudFxuICAgICAqIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0gZG9tTm9kZVNlbGVjdG9ycyAtIEFuIG9iamVjdCB3aXRoIGRvbSBub2RlIHNlbGVjdG9ycy5cbiAgICAgKiBAcGFyYW0gd3JhcHBlckRvbU5vZGUgLSBBIGRvbSBub2RlIHRvIGJlIHRoZSBwYXJlbnQgb3Igd3JhcHBlciBvZiBhbGxcbiAgICAgKiByZXRyaWV2ZWQgZG9tIG5vZGVzLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgQWxsICQgd3JhcHBlZCBkb20gbm9kZXMgY29ycmVzcG9uZGluZyB0byBnaXZlblxuICAgICAqIHNlbGVjdG9ycy5cbiAgICAgKi9cbiAgICBncmFiRG9tTm9kZShcbiAgICAgICAgZG9tTm9kZVNlbGVjdG9yczpQbGFpbk9iamVjdCwgd3JhcHBlckRvbU5vZGU6RG9tTm9kZXwkRG9tTm9kZVxuICAgICk6e1trZXk6c3RyaW5nXTokRG9tTm9kZX0ge1xuICAgIC8qIGVzbGludC1lbmFibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgICAgICBjb25zdCBkb21Ob2Rlczp7W2tleTpzdHJpbmddOiREb21Ob2RlfSA9IHt9XG4gICAgICAgIGlmIChkb21Ob2RlU2VsZWN0b3JzKVxuICAgICAgICAgICAgaWYgKHdyYXBwZXJEb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHdyYXBwZXJEb21Ob2RlOiREb21Ob2RlID0gJCh3cmFwcGVyRG9tTm9kZSlcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWU6c3RyaW5nIGluIGRvbU5vZGVTZWxlY3RvcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlU2VsZWN0b3JzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZXNbbmFtZV0gPSAkd3JhcHBlckRvbU5vZGUuZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlU2VsZWN0b3JzW25hbWVdKVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lOnN0cmluZyBpbiBkb21Ob2RlU2VsZWN0b3JzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZVNlbGVjdG9ycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2g6P0FycmF5PHN0cmluZz4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGVTZWxlY3RvcnNbbmFtZV0ubWF0Y2goJywgKicpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZWxlY3RvclBhcnQ6c3RyaW5nIG9mIGRvbU5vZGVTZWxlY3RvcnNbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLnNwbGl0KG1hdGNoWzBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZVNlbGVjdG9yc1tuYW1lXSArPSAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsaXplRG9tTm9kZVNlbGVjdG9yKHNlbGVjdG9yUGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGVzW25hbWVdID0gJCh0aGlzLm5vcm1hbGl6ZURvbU5vZGVTZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlU2VsZWN0b3JzW25hbWVdKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXgpXG4gICAgICAgICAgICBkb21Ob2Rlcy5wYXJlbnQgPSAkKHRoaXMuX29wdGlvbnMuZG9tTm9kZVNlbGVjdG9yUHJlZml4KVxuICAgICAgICBpZiAoJ3dpbmRvdycgaW4gJC5nbG9iYWwpXG4gICAgICAgICAgICBkb21Ob2Rlcy53aW5kb3cgPSAkKCQuZ2xvYmFsLndpbmRvdylcbiAgICAgICAgaWYgKCdkb2N1bWVudCcgaW4gJC5nbG9iYWwpXG4gICAgICAgICAgICBkb21Ob2Rlcy5kb2N1bWVudCA9ICQoJC5nbG9iYWwuZG9jdW1lbnQpXG4gICAgICAgIHJldHVybiBkb21Ob2Rlc1xuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIHNjb3BlXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlcyBhbGwgaW5oZXJpdGVkIHZhcmlhYmxlcyBmcm9tIHBhcmVudCBzY29wZSB3aXRoIFwidW5kZWZpbmVkXCIuXG4gICAgICogQHBhcmFtIHNjb3BlIC0gQSBzY29wZSB3aGVyZSBpbmhlcml0ZWQgbmFtZXMgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqIEBwYXJhbSBwcmVmaXhlc1RvSWdub3JlIC0gTmFtZSBwcmVmaXhlcyB0byBpZ25vcmUgZHVyaW5nIGRlbGV0aW5nIG5hbWVzXG4gICAgICogaW4gZ2l2ZW4gc2NvcGUuXG4gICAgICogQHJldHVybnMgVGhlIGlzb2xhdGVkIHNjb3BlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc29sYXRlU2NvcGUoc2NvcGU6T2JqZWN0LCBwcmVmaXhlc1RvSWdub3JlOkFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICckJywgJ18nXG4gICAgXSk6T2JqZWN0IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lOnN0cmluZyBpbiBzY29wZSlcbiAgICAgICAgICAgIGlmICghKHByZWZpeGVzVG9JZ25vcmUuaW5jbHVkZXMobmFtZS5jaGFyQXQoMCkpIHx8IFtcbiAgICAgICAgICAgICAgICAndGhpcycsICdjb25zdHJ1Y3RvcidcbiAgICAgICAgICAgIF0uaW5jbHVkZXMobmFtZSkgfHwgc2NvcGUuaGFzT3duUHJvcGVydHkobmFtZSkpKVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIE5PVEU6IERlbGV0ZSAoXCJkZWxldGUgJHNjb3BlW25hbWVdXCIpIGRvZXNuJ3QgZGVzdHJveSB0aGVcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljIGxvb2t1cCB0byBwYXJlbnQgc2NvcGUuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzY29wZVtuYW1lXSA9IHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gc2NvcGVcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIG5hbWUgaW4gZ2l2ZW4gc2NvcGUgKHVzZWZ1bGwgZm9yIGpzb25wIHJlcXVlc3RzKS5cbiAgICAgKiBAcGFyYW0gcHJlZml4IC0gQSBwcmVmaXggd2hpY2ggd2lsbCBiZSBwcmVwcmVuZGVkIHRvIHVuaXFlIG5hbWUuXG4gICAgICogQHBhcmFtIHN1ZmZpeCAtIEEgc3VmZml4IHdoaWNoIHdpbGwgYmUgcHJlcHJlbmRlZCB0byB1bmlxZSBuYW1lLlxuICAgICAqIEBwYXJhbSBzY29wZSAtIEEgc2NvcGUgd2hlcmUgdGhlIG5hbWUgc2hvdWxkIGJlIHVuaXF1ZS5cbiAgICAgKiBAcGFyYW0gaW5pdGlhbFVuaXF1ZU5hbWUgLSBBbiBpbml0aWFsIHNjb3BlIG5hbWUgdG8gdXNlIGlmIG5vdCBleGlzdHMuXG4gICAgICogQHJldHVybnMgVGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgc3RhdGljIGRldGVybWluZVVuaXF1ZVNjb3BlTmFtZShcbiAgICAgICAgcHJlZml4OnN0cmluZyA9ICdjYWxsYmFjaycsIHN1ZmZpeDpzdHJpbmcgPSAnJyxcbiAgICAgICAgc2NvcGU6T2JqZWN0ID0gJC5nbG9iYWwsIGluaXRpYWxVbmlxdWVOYW1lOnN0cmluZyA9ICcnXG4gICAgKTpzdHJpbmcge1xuICAgICAgICBpZiAoaW5pdGlhbFVuaXF1ZU5hbWUubGVuZ3RoICYmICEoaW5pdGlhbFVuaXF1ZU5hbWUgaW4gc2NvcGUpKVxuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxVbmlxdWVOYW1lXG4gICAgICAgIGxldCB1bmlxdWVOYW1lOnN0cmluZyA9IHByZWZpeCArIHN1ZmZpeFxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdW5pcXVlTmFtZSA9IHByZWZpeCArIHBhcnNlSW50KFxuICAgICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygxMCwgMTApLCAxMFxuICAgICAgICAgICAgKSArIHN1ZmZpeFxuICAgICAgICAgICAgaWYgKCEodW5pcXVlTmFtZSBpbiBzY29wZSkpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pcXVlTmFtZVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGZ1bmN0aW9uXG4gICAgLyoqXG4gICAgICogTWV0aG9kcyBnaXZlbiBieSB0aGlzIG1ldGhvZCBoYXMgdGhlIHBsdWdpbiBzY29wZSByZWZlcmVuY2VkIHdpdGhcbiAgICAgKiBcInRoaXNcIi4gT3RoZXJ3aXNlIFwidGhpc1wiIHVzdWFsbHkgcG9pbnRzIHRvIHRoZSBvYmplY3QgdGhlIGdpdmVuIG1ldGhvZFxuICAgICAqIHdhcyBhdHRhY2hlZCB0by4gSWYgXCJtZXRob2RcIiBkb2Vzbid0IG1hdGNoIHN0cmluZyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAqIHRocm91Z2ggYSB3cmFwcGVyIGZ1bmN0aW9uIHdpdGggXCJjb250ZXh0XCIgc2V0dGVkIGFzIFwic2NvcGVcIiBvciBcInRoaXNcIiBpZlxuICAgICAqIG5vdGhpbmcgaXMgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIG1ldGhvZCAtIEEgbWV0aG9kIG5hbWUgb2YgZ2l2ZW4gc2NvcGUuXG4gICAgICogQHBhcmFtIHNjb3BlIC0gQSBnaXZlbiBzY29wZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEEgbGlzdCBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmb3J3YXJkXG4gICAgICogdG8gZ2l2ZW4gZnVuY3Rpb24sIHdoZW4gaXQgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBnaXZlbiBtZXRob2RzIHJldHVybiB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRNZXRob2QoXG4gICAgICAgIG1ldGhvZDpGdW5jdGlvbnxzdHJpbmcsIHNjb3BlOmFueSA9IG51bGwsXG4gICAgICAgIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55PlxuICAgICk6RnVuY3Rpb24ge1xuICAgICAgICAvKlxuICAgICAgICAgICAgVGhpcyBmb2xsb3dpbmcgb3V0Y29tbWVudCBsaW5lIHdvdWxkIGJlIHJlc3BvbnNpYmxlIGZvciBhIGJ1ZyBpblxuICAgICAgICAgICAgeXVpY29tcHJlc3Nvci4gQmVjYXVzZSBvZiBkZWNsYXJhdGlvbiBvZiBhcmd1bWVudHMgdGhlIHBhcnNlclxuICAgICAgICAgICAgdGhpbmdzIHRoYXQgYXJndW1lbnRzIGlzIGEgbG9jYWwgdmFyaWFibGUgYW5kIGNvdWxkIGJlIHJlbmFtZWQuIEl0XG4gICAgICAgICAgICBkb2Vzbid0IGNhcmUgYWJvdXQgdGhhdCB0aGUgbWFnaWMgYXJndW1lbnRzIG9iamVjdCBpcyBuZWNlc3NhcnkgdG9cbiAgICAgICAgICAgIGdlbmVyYXRlIHRoZSBhcmd1bWVudHMgYXJyYXkgaW4gdGhpcyBjb250ZXh0LlxuXG4gICAgICAgICAgICB2YXIgYXJndW1lbnRzID0gdGhpcy5jb25zdHJ1Y3Rvci5hcnJheU1ha2UoYXJndW1lbnRzKVxuICAgICAgICAqL1xuICAgICAgICBpZiAoIXNjb3BlKVxuICAgICAgICAgICAgc2NvcGUgPSB0aGlzXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2NvcGUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCk6YW55IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlW21ldGhvZF0gJiYgdHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGRvZXNuJ3QgZXhpc3RzIGluIFwiJHtzY29wZX1cIi5gKVxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZVttZXRob2RdLmFwcGx5KHNjb3BlLCBhZGRpdGlvbmFsQXJndW1lbnRzLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5hcnJheU1ha2UoYXJndW1lbnRzKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGY6VG9vbHMgPSB0aGlzXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpOmFueSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIHNlbGYuY29uc3RydWN0b3IuYXJyYXlNYWtlKFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICAgKS5jb25jYXQoYWRkaXRpb25hbEFyZ3VtZW50cykpXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gQSB2YWx1ZSB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIGlkZW50aXR5KHZhbHVlOmFueSk6YW55IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVydGVkIGZpbHRlciBoZWxwZXIgdG8gaW52ZXJzZSBlYWNoIGdpdmVuIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gQSBmdW5jdGlvbiB0aGF0IGZpbHRlcnMgYW4gYXJyYXkuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIGZpbHRlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW52ZXJ0QXJyYXlGaWx0ZXIoZmlsdGVyOkZ1bmN0aW9uKTpGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhOmFueSk6YW55IHtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWREYXRhOmFueSA9IGZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDpBcnJheTxhbnk+ID0gW11cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjdXJseSAqL1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGF0ZTphbnkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyZWREYXRhLmluY2x1ZGVzKGRhdGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGUpXG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjdXJseSAqL1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIGV2ZW50XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgZXZlbnQgZnVuY3Rpb25zIGZyb20gdHJpZ2dlcmluZyB0byBvZnRlbiBieSBkZWZpbmluZyBhIG1pbmltYWxcbiAgICAgKiBzcGFuIGJldHdlZW4gZWFjaCBmdW5jdGlvbiBjYWxsLiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBnaXZlbiB0byB0aGlzXG4gICAgICogZnVuY3Rpb24gd2lsbCBiZSBmb3J3YXJkZWQgdG8gZ2l2ZW4gZXZlbnQgZnVuY3Rpb24gY2FsbC4gVGhlIGZ1bmN0aW9uXG4gICAgICogd3JhcHBlciByZXR1cm5zIG51bGwgaWYgY3VycmVudCBmdW5jdGlvbiB3aWxsIGJlIG9taXR0ZWQgZHVlIHRvXG4gICAgICogZGVib3VuY2VpbmcuXG4gICAgICogQHBhcmFtIGV2ZW50RnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBkZWJvdW5jZWQuXG4gICAgICogQHBhcmFtIHRocmVzaG9sZEluTWlsbGlzZWNvbmRzIC0gVGhlIG1pbmltdW0gdGltZSBzcGFuIGJldHdlZW4gZWFjaFxuICAgICAqIGZ1bmN0aW9uIGNhbGwuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxBcmd1bWVudHMgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmb3J3YXJkIHRvIGdpdmVuXG4gICAgICogZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgd3JhcHBlZCBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGRlYm91bmNlKFxuICAgICAgICBldmVudEZ1bmN0aW9uOkZ1bmN0aW9uLCB0aHJlc2hvbGRJbk1pbGxpc2Vjb25kczpudW1iZXIgPSA2MDAsXG4gICAgICAgIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55PlxuICAgICk6RnVuY3Rpb24ge1xuICAgICAgICBsZXQgbG9jazpib29sZWFuID0gZmFsc2VcbiAgICAgICAgbGV0IHdhaXRpbmdDYWxsQXJndW1lbnRzOj9BcnJheTxhbnk+ID0gbnVsbFxuICAgICAgICBsZXQgdGltZW91dElEOj9udW1iZXIgPSBudWxsXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpOj9udW1iZXIge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyOkFycmF5PGFueT4gPSBUb29scy5hcnJheU1ha2UoYXJndW1lbnRzKVxuICAgICAgICAgICAgaWYgKGxvY2spXG4gICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxBcmd1bWVudHMgPSBwYXJhbWV0ZXIuY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzIHx8IFtdKVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jayA9IHRydWVcbiAgICAgICAgICAgICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpOnZvaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2NrID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhaXRpbmdDYWxsQXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHdhaXRpbmdDYWxsQXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZ0NhbGxBcmd1bWVudHMgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aHJlc2hvbGRJbk1pbGxpc2Vjb25kcylcbiAgICAgICAgICAgICAgICBldmVudEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtZXRlci5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxBcmd1bWVudHMgfHwgW10pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXRJRFxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBpbnRlcm5hbCBldmVudCBoYW5kbGVyIG1ldGhvZHMgYW5kIHJ1bnMgdGhlbSBieSBkZWZhdWx0LiBJblxuICAgICAqIGFkZGl0aW9uIHRoaXMgbWV0aG9kIHNlYXJjaGVzIGZvciBhIGdpdmVuIGV2ZW50IG1ldGhvZCBieSB0aGUgb3B0aW9uc1xuICAgICAqIG9iamVjdC4gQWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIGZvcndhcmRlZCB0byByZXNwZWN0aXZlIGV2ZW50XG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBBbiBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBjYWxsT25seU9wdGlvbnNNZXRob2QgLSBQcmV2ZW50cyBmcm9tIHRyeWluZyB0byBjYWxsIGFuIGludGVybmFsXG4gICAgICogZXZlbnQgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gc2NvcGUgLSBUaGUgc2NvcGUgZnJvbSB3aGVyZSB0aGUgZ2l2ZW4gZXZlbnQgaGFuZGxlciBzaG91bGQgYmVcbiAgICAgKiBjYWxsZWQuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxBcmd1bWVudHMgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmb3J3YXJkIHRvXG4gICAgICogY29ycmVzcG9uZGluZyBldmVudCBoYW5kbGVycy5cbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgXCJ0cnVlXCIgaWYgYW4gb3B0aW9ucyBldmVudCBoYW5kbGVyIHdhcyBjYWxsZWQgYW5kXG4gICAgICogXCJmYWxzZVwiIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmaXJlRXZlbnQoXG4gICAgICAgIGV2ZW50TmFtZTpzdHJpbmcsIGNhbGxPbmx5T3B0aW9uc01ldGhvZDpib29sZWFuID0gZmFsc2UsXG4gICAgICAgIHNjb3BlOmFueSA9IHRoaXMsIC4uLmFkZGl0aW9uYWxBcmd1bWVudHM6QXJyYXk8YW55PlxuICAgICk6Ym9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlck5hbWU6c3RyaW5nID1cbiAgICAgICAgICAgIGBvbiR7dGhpcy5jb25zdHJ1Y3Rvci5zdHJpbmdDYXBpdGFsaXplKGV2ZW50TmFtZSl9YFxuICAgICAgICBpZiAoIWNhbGxPbmx5T3B0aW9uc01ldGhvZClcbiAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJOYW1lIGluIHNjb3BlKVxuICAgICAgICAgICAgICAgIHNjb3BlW2V2ZW50SGFuZGxlck5hbWVdLmFwcGx5KHNjb3BlLCBhZGRpdGlvbmFsQXJndW1lbnRzKVxuICAgICAgICAgICAgZWxzZSBpZiAoYF8ke2V2ZW50SGFuZGxlck5hbWV9YCBpbiBzY29wZSlcbiAgICAgICAgICAgICAgICBzY29wZVtgXyR7ZXZlbnRIYW5kbGVyTmFtZX1gXS5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUsIGFkZGl0aW9uYWxBcmd1bWVudHMpXG4gICAgICAgIGlmIChzY29wZS5fb3B0aW9ucyAmJiBldmVudEhhbmRsZXJOYW1lIGluIHNjb3BlLl9vcHRpb25zKSB7XG4gICAgICAgICAgICBzY29wZS5fb3B0aW9uc1tldmVudEhhbmRsZXJOYW1lXS5hcHBseShzY29wZSwgYWRkaXRpb25hbEFyZ3VtZW50cylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb24tY29tcGxldGUtc2VudGVuY2UgKi9cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgbWV0aG9kIGZvciBcIiQub24oKVwiLiBJdCBzZXRzIGN1cnJlbnQgcGx1Z2luIG5hbWUgYXMgZXZlbnRcbiAgICAgKiBzY29wZSBpZiBubyBzY29wZSBpcyBnaXZlbi4gR2l2ZW4gYXJndW1lbnRzIGFyZSBtb2RpZmllZCBhbmQgcGFzc2VkXG4gICAgICogdGhyb3VnaCBcIiQub24oKVwiLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgJCdzIGdyYWJiZWQgZG9tIG5vZGUuXG4gICAgICovXG4gICAgb24oKTokRG9tTm9kZSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBqc2RvYy9yZXF1aXJlLWRlc2NyaXB0aW9uLWNvbXBsZXRlLXNlbnRlbmNlICovXG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kRXZlbnRIZWxwZXIoYXJndW1lbnRzLCBmYWxzZSlcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBtZXRob2QgZm8gXCIkLm9mZigpXCIuIEl0IHNldHMgY3VycmVudCBwbHVnaW4gbmFtZSBhcyBldmVudFxuICAgICAqIHNjb3BlIGlmIG5vIHNjb3BlIGlzIGdpdmVuLiBHaXZlbiBhcmd1bWVudHMgYXJlIG1vZGlmaWVkIGFuZCBwYXNzZWRcbiAgICAgKiB0aHJvdWdoIFwiJC5vZmYoKVwiLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgJCdzIGdyYWJiZWQgZG9tIG5vZGUuXG4gICAgICovXG4gICAgb2ZmKCk6JERvbU5vZGUge1xuICAgIC8qIGVzbGludC1lbmFibGUganNkb2MvcmVxdWlyZS1kZXNjcmlwdGlvbi1jb21wbGV0ZS1zZW50ZW5jZSAqL1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZEV2ZW50SGVscGVyKGFyZ3VtZW50cywgdHJ1ZSwgJ29mZicpXG4gICAgfVxuICAgIC8vIC8gZW5kcmVnaW9uXG4gICAgLy8gLyByZWdpb24gb2JqZWN0XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IFtbQ2xhc3NdXSBvZiBhbiBvYmplY3QuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBhbmFseXplLlxuICAgICAqIEByZXR1cm5zIE5hbWUgb2YgZGV0ZXJtaW5lZCBjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0ZXJtaW5lVHlwZShvYmplY3Q6YW55ID0gdW5kZWZpbmVkKTpzdHJpbmcge1xuICAgICAgICBpZiAoW3VuZGVmaW5lZCwgbnVsbF0uaW5jbHVkZXMob2JqZWN0KSlcbiAgICAgICAgICAgIHJldHVybiBgJHtvYmplY3R9YFxuICAgICAgICBpZiAoWydvYmplY3QnLCAnZnVuY3Rpb24nXS5pbmNsdWRlcyhcbiAgICAgICAgICAgIHR5cGVvZiBvYmplY3RcbiAgICAgICAgKSAmJiAndG9TdHJpbmcnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nUmVwcmVzZW50YXRpb246c3RyaW5nID1cbiAgICAgICAgICAgICAgICBUb29scy5jbGFzc1RvVHlwZU1hcHBpbmcudG9TdHJpbmcuY2FsbChvYmplY3QpXG4gICAgICAgICAgICBpZiAoVG9vbHMuY2xhc3NUb1R5cGVNYXBwaW5nLmhhc093blByb3BlcnR5KHN0cmluZ1JlcHJlc2VudGF0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gVG9vbHMuY2xhc3NUb1R5cGVNYXBwaW5nW3N0cmluZ1JlcHJlc2VudGF0aW9uXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGdpdmVuIHBhdHRlcm4gaW4gZWFjaCB2YWx1ZSBpbiBnaXZlbiBvYmplY3QgcmVjdXJzaXZlbHkgd2l0aFxuICAgICAqIGdpdmVuIHN0cmluZyByZXBsYWNlbWVudC5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGNvbnZlcnQgc3Vic3RyaW5ncyBpbi5cbiAgICAgKiBAcGFyYW0gcGF0dGVybiAtIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSByZXBsYWNlbWVudCAtIFN0cmluZyB0byB1c2UgYXMgcmVwbGFjZW1lbnQgZm9yIGZvdW5kIHBhdHRlcm5zLlxuICAgICAqIEByZXR1cm5zIENvbnZlcnRlZCBvYmplY3Qgd2l0aCByZXBsYWNlZCBwYXR0ZXJucy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydFN1YnN0cmluZ0luUGxhaW5PYmplY3QoXG4gICAgICAgIG9iamVjdDpQbGFpbk9iamVjdCwgcGF0dGVybjpSZWdFeHAsIHJlcGxhY2VtZW50OnN0cmluZ1xuICAgICk6UGxhaW5PYmplY3Qge1xuICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gb2JqZWN0KVxuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgIGlmIChUb29scy5pc1BsYWluT2JqZWN0KG9iamVjdFtrZXldKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBUb29scy5jb252ZXJ0U3Vic3RyaW5nSW5QbGFpbk9iamVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBwYXR0ZXJuLCByZXBsYWNlbWVudClcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IG9iamVjdFtrZXldLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZW1lbnQpXG4gICAgICAgIHJldHVybiBvYmplY3RcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0ZW5kcyBnaXZlbiB0YXJnZXQgb2JqZWN0IHdpdGggZ2l2ZW4gc291cmNlcyBvYmplY3QuIEFzIHRhcmdldCBhbmRcbiAgICAgKiBzb3VyY2VzIG1hbnkgZXhwYW5kYWJsZSB0eXBlcyBhcmUgYWxsb3dlZCBidXQgdGFyZ2V0IGFuZCBzb3VyY2VzIGhhdmUgdG9cbiAgICAgKiB0byBjb21lIGZyb20gdGhlIHNhbWUgdHlwZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0T3JEZWVwSW5kaWNhdG9yIC0gTWF5YmUgdGhlIHRhcmdldCBvciBkZWVwIGluZGljYXRvci5cbiAgICAgKiBAcGFyYW0gX3RhcmdldEFuZE9yU291cmNlcyAtIFRhcmdldCBhbmQgYXQgbGVhc3Qgb25lIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiB0YXJnZXQgZXh0ZW5kZWQgd2l0aCBhbGwgZ2l2ZW4gc291cmNlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXh0ZW5kT2JqZWN0KFxuICAgICAgICB0YXJnZXRPckRlZXBJbmRpY2F0b3I6Ym9vbGVhbnxhbnksIC4uLl90YXJnZXRBbmRPclNvdXJjZXM6QXJyYXk8YW55PlxuICAgICk6YW55IHtcbiAgICAgICAgbGV0IGluZGV4Om51bWJlciA9IDFcbiAgICAgICAgbGV0IGRlZXA6Ym9vbGVhbiA9IGZhbHNlXG4gICAgICAgIGxldCB0YXJnZXQ6bWl4ZWRcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRPckRlZXBJbmRpY2F0b3IgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvbiBhbmQgc2tpcCBkZWVwIGluZGljYXRvciBhbmQgdGFyZ2V0LlxuICAgICAgICAgICAgZGVlcCA9IHRhcmdldE9yRGVlcEluZGljYXRvclxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzW2luZGV4XVxuICAgICAgICAgICAgaW5kZXggPSAyXG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0T3JEZWVwSW5kaWNhdG9yXG4gICAgICAgIGNvbnN0IG1lcmdlVmFsdWUgPSAoa2V5OnN0cmluZywgdmFsdWU6YW55LCB0YXJnZXRWYWx1ZTphbnkpOmFueSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHRhcmdldFZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRWYWx1ZVxuICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgbWFwcy5cbiAgICAgICAgICAgIGlmIChkZWVwICYmIHZhbHVlICYmIChcbiAgICAgICAgICAgICAgICBUb29scy5pc1BsYWluT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIE1hcFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbG9uZTphbnlcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICAgICAgICAgIGNsb25lID0gdGFyZ2V0VmFsdWUgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgICAgICAgICAgICAgKSA/IHRhcmdldFZhbHVlIDogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHRhcmdldFZhbHVlICYmIFRvb2xzLmlzUGxhaW5PYmplY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApID8gdGFyZ2V0VmFsdWUgOiB7fVxuICAgICAgICAgICAgICAgIHJldHVybiBUb29scy5leHRlbmRPYmplY3QoZGVlcCwgY2xvbmUsIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlOmFueSA9IGFyZ3VtZW50c1tpbmRleF1cbiAgICAgICAgICAgIGxldCB0YXJnZXRUeXBlOnN0cmluZyA9IHR5cGVvZiB0YXJnZXRcbiAgICAgICAgICAgIGxldCBzb3VyY2VUeXBlOnN0cmluZyA9IHR5cGVvZiBzb3VyY2VcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICAgICAgdGFyZ2V0VHlwZSArPSAnIE1hcCdcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICAgICAgc291cmNlVHlwZSArPSAnIE1hcCdcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSBzb3VyY2VUeXBlICYmIHRhcmdldCAhPT0gc291cmNlKVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXAgJiYgc291cmNlIGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXk6c3RyaW5nLCB2YWx1ZTphbnldIG9mIHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZXQoa2V5LCBtZXJnZVZhbHVlKGtleSwgdmFsdWUsIHRhcmdldC5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KSkpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHNvdXJjZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2UpICYmIHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZVZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksIHNvdXJjZVtrZXldLCB0YXJnZXRba2V5XSlcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gc291cmNlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gc291cmNlXG4gICAgICAgICAgICBpbmRleCArPSAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcHJveGllcyBmcm9tIGdpdmVuIGRhdGEgc3RydWN0dXJlIHJlY3Vyc2l2bGV5LlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3QgdG8gcHJveHkuXG4gICAgICogQHBhcmFtIHNlZW5PYmplY3RzIC0gVHJhY2tzIGFsbCBhbHJlYWR5IHByb2Nlc3NlZCBvYmVqY3RzIHRvIGF2b2lkXG4gICAgICogZW5kbGVzcyBsb29wcyAodXN1YWxseSBvbmx5IG5lZWRlZCBmb3IgaW50ZXJuYWwgcHJ1cG9zZSkuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiBvYmplY3QgdW53cmFwcGVkIGZyb20gYSBkeW5hbWljIHByb3h5LlxuICAgICAqL1xuICAgIHN0YXRpYyB1bndyYXBQcm94eShvYmplY3Q6YW55LCBzZWVuT2JqZWN0czpBcnJheTxhbnk+ID0gW10pOmFueSB7XG4gICAgICAgIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHdoaWxlIChvYmplY3QuX190YXJnZXRfXylcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QuX190YXJnZXRfX1xuICAgICAgICAgICAgY29uc3QgaW5kZXg6bnVtYmVyID0gc2Vlbk9iamVjdHMuaW5kZXhPZihvYmplY3QpXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWVuT2JqZWN0c1tpbmRleF1cbiAgICAgICAgICAgIHNlZW5PYmplY3RzLnB1c2gob2JqZWN0KVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZTptaXhlZCBvZiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2luZGV4XSA9IFRvb2xzLnVud3JhcFByb3h5KHZhbHVlLCBzZWVuT2JqZWN0cylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleTptaXhlZCwgdmFsdWU6bWl4ZWRdIG9mIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNldChrZXksIFRvb2xzLnVud3JhcFByb3h5KHZhbHVlLCBzZWVuT2JqZWN0cykpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBUb29scy51bndyYXBQcm94eShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSwgc2Vlbk9iamVjdHMpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGR5bmFtaWMgZ2V0dGVyIGFuZCBzZXR0ZXIgdG8gYW55IGdpdmVuIGRhdGEgc3RydWN0dXJlIHN1Y2ggYXMgbWFwcy5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIHByb3h5LlxuICAgICAqIEBwYXJhbSBnZXR0ZXJXcmFwcGVyIC0gRnVuY3Rpb24gdG8gd3JhcCBlYWNoIHByb3BlcnR5IGdldC5cbiAgICAgKiBAcGFyYW0gc2V0dGVyV3JhcHBlciAtIEZ1bmN0aW9uIHRvIHdyYXAgZWFjaCBwcm9wZXJ0eSBzZXQuXG4gICAgICogQHBhcmFtIGdldHRlck1ldGhvZE5hbWUgLSBNZXRob2QgbmFtZSB0byBnZXQgYSBzdG9yZWQgdmFsdWUgYnkga2V5LlxuICAgICAqIEBwYXJhbSBzZXR0ZXJNZXRob2ROYW1lIC0gTWV0aG9kIG5hbWUgdG8gc2V0IGEgc3RvcmVkIHZhbHVlIGJ5IGtleS5cbiAgICAgKiBAcGFyYW0gY29udGFpbmVzTWV0aG9kTmFtZSAtIE1ldGhvZCBuYW1lIHRvIGluZGljYXRlIGlmIGEga2V5IGlzIHN0b3JlZFxuICAgICAqIGluIGdpdmVuIGRhdGEgc3RydWN0dXJlLlxuICAgICAqIEBwYXJhbSBkZWVwIC0gSW5kaWNhdGVzIHRvIHBlcmZvcm0gYSBkZWVwIHdyYXBwaW5nIG9mIHNwZWNpZmllZCB0eXBlcy5cbiAgICAgKiBwZXJmb3JtZWQgdmlhIFwidmFsdWUgaW5zdGFuY2VvZiB0eXBlXCIuKS5cbiAgICAgKiBAcGFyYW0gdHlwZXNUb0V4dGVuZCAtIFR5cGVzIHdoaWNoIHNob3VsZCBiZSBleHRlbmRlZCAoQ2hlY2tzIGFyZVxuICAgICAqIHBlcmZvcm1lZCB2aWEgXCJ2YWx1ZSBpbnN0YW5jZW9mIHR5cGVcIi4pLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gb2JqZWN0IHdyYXBwZWQgd2l0aCBhIGR5bmFtaWMgZ2V0dGVyIHByb3h5LlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREeW5hbWljR2V0dGVyQW5kU2V0dGVyPFZhbHVlPihcbiAgICAgICAgb2JqZWN0OlZhbHVlLCBnZXR0ZXJXcmFwcGVyOkdldHRlckZ1bmN0aW9uID0gKHZhbHVlOmFueSk6YW55ID0+IHZhbHVlLFxuICAgICAgICBzZXR0ZXJXcmFwcGVyOlNldHRlckZ1bmN0aW9uID0gKGtleTphbnksIHZhbHVlOmFueSk6YW55ID0+IHZhbHVlLFxuICAgICAgICBnZXR0ZXJNZXRob2ROYW1lOnN0cmluZyA9ICdbXScsIHNldHRlck1ldGhvZE5hbWU6c3RyaW5nID0gJ1tdJyxcbiAgICAgICAgY29udGFpbmVzTWV0aG9kTmFtZTpzdHJpbmcgPSAnaGFzT3duUHJvcGVydHknLCBkZWVwOmJvb2xlYW4gPSB0cnVlLFxuICAgICAgICB0eXBlc1RvRXh0ZW5kOkFycmF5PG1peGVkPiA9IFtPYmplY3RdXG4gICAgKTpWYWx1ZSB7XG4gICAgICAgIGlmIChkZWVwKVxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXk6bWl4ZWQsIHZhbHVlOm1peGVkXSBvZiBvYmplY3QpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zZXQoa2V5LCBUb29scy5hZGREeW5hbWljR2V0dGVyQW5kU2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGdldHRlcldyYXBwZXIsIHNldHRlcldyYXBwZXIsIGdldHRlck1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJNZXRob2ROYW1lLCBjb250YWluZXNNZXRob2ROYW1lLCBkZWVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNUb0V4dGVuZCkpXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gb2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IFRvb2xzLmFkZER5bmFtaWNHZXR0ZXJBbmRTZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0sIGdldHRlcldyYXBwZXIsIHNldHRlcldyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyTWV0aG9kTmFtZSwgc2V0dGVyTWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXNNZXRob2ROYW1lLCBkZWVwLCB0eXBlc1RvRXh0ZW5kKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXg6bnVtYmVyID0gMFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWU6bWl4ZWQgb2Ygb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtpbmRleF0gPSBUb29scy5hZGREeW5hbWljR2V0dGVyQW5kU2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGdldHRlcldyYXBwZXIsIHNldHRlcldyYXBwZXIsIGdldHRlck1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJNZXRob2ROYW1lLCBjb250YWluZXNNZXRob2ROYW1lLCBkZWVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNUb0V4dGVuZClcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0eXBlOm1peGVkIG9mIHR5cGVzVG9FeHRlbmQpXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuX190YXJnZXRfXylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXI6e1xuICAgICAgICAgICAgICAgICAgICBoYXM/Oih0YXJnZXQ6T2JqZWN0LCBuYW1lOnN0cmluZykgPT4gYm9vbGVhbjtcbiAgICAgICAgICAgICAgICAgICAgZ2V0PzoodGFyZ2V0Ok9iamVjdCwgbmFtZTpzdHJpbmcpID0+IGFueTtcbiAgICAgICAgICAgICAgICAgICAgc2V0PzoodGFyZ2V0Ok9iamVjdCwgbmFtZTpzdHJpbmcpID0+IGFueVxuICAgICAgICAgICAgICAgIH0gPSB7fVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXNNZXRob2ROYW1lKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmhhcyA9ICh0YXJnZXQ6T2JqZWN0LCBuYW1lOnN0cmluZyk6Ym9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVzTWV0aG9kTmFtZSA9PT0gJ1tdJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSBpbiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbY29udGFpbmVzTWV0aG9kTmFtZV0obmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXNNZXRob2ROYW1lICYmIGdldHRlck1ldGhvZE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuZ2V0ID0gKHRhcmdldDpPYmplY3QsIG5hbWU6c3RyaW5nKTphbnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdfX3RhcmdldF9fJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtuYW1lXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W25hbWVdLmJpbmQodGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFtjb250YWluZXNNZXRob2ROYW1lXShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXR0ZXJNZXRob2ROYW1lID09PSAnW10nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyV3JhcHBlcih0YXJnZXRbbmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcldyYXBwZXIodGFyZ2V0W2dldHRlck1ldGhvZE5hbWVdKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0ZXJNZXRob2ROYW1lKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLnNldCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDpPYmplY3QsIG5hbWU6c3RyaW5nLCB2YWx1ZTphbnlcbiAgICAgICAgICAgICAgICAgICAgKTp2b2lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0ZXJNZXRob2ROYW1lID09PSAnW10nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNldHRlcldyYXBwZXIobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3NldHRlck1ldGhvZE5hbWVdKG5hbWUsIHNldHRlcldyYXBwZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZVR5cGVDaGVja1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkob2JqZWN0LCBoYW5kbGVyKVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBuZXN0ZWQgbWFwcGluZ3Mgd2l0aCBnaXZlbiBpbmRpY2F0b3Iga2V5IGFuZCByZXNvbHZlc1xuICAgICAqIG1hcmtlZCB2YWx1ZXMuIEFkZGl0aW9uYWxseSBhbGwgb2JqZWN0cyBhcmUgd3JhcHBlZCB3aXRoIGEgcHJveHkgdG9cbiAgICAgKiBkeW5hbWljYWxseSByZXNvbHZlIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBHaXZlbiBtYXBwaW5nIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHBhcmFtZXRlckRlc2NyaXB0aW9uIC0gQXJyYXkgb2Ygc2NvcGUgbmFtZXMuXG4gICAgICogQHBhcmFtIHBhcmFtZXRlciAtIEFycmF5IG9mIHZhbHVlcyBmb3IgZ2l2ZW4gc2NvcGUgbmFtZXMuIElmIHRoZXJlIGlzXG4gICAgICogb25lIG1pc3NpbmcgZ2l2ZW4gb2JqZWN0IHdpbGwgYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIGRlZXAgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBwZXJmb3JtIGEgcmVjdXJzaXZlIHJlc29sdmluZy5cbiAgICAgKiBAcGFyYW0gZXZhbHVhdGlvbkluZGljYXRvcktleSAtIEluZGljYXRvciBwcm9wZXJ0eSBuYW1lIHRvIG1hcmsgYSB2YWx1ZVxuICAgICAqIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSBleGVjdXRpb25JbmRpY2F0b3JLZXkgLSBJbmRpY2F0b3IgcHJvcGVydHkgbmFtZSB0byBtYXJrIGEgdmFsdWVcbiAgICAgKiB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyBFdmFsdWF0ZWQgZ2l2ZW4gbWFwcGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUR5bmFtaWNEYXRhU3RydWN0dXJlKFxuICAgICAgICBvYmplY3Q6YW55LCBwYXJhbWV0ZXJEZXNjcmlwdGlvbjpBcnJheTxzdHJpbmc+ID0gW10sXG4gICAgICAgIHBhcmFtZXRlcjpBcnJheTxhbnk+ID0gW10sIGRlZXA6Ym9vbGVhbiA9IHRydWUsXG4gICAgICAgIGV2YWx1YXRpb25JbmRpY2F0b3JLZXk6c3RyaW5nID0gJ19fZXZhbHVhdGVfXycsXG4gICAgICAgIGV4ZWN1dGlvbkluZGljYXRvcktleTpzdHJpbmcgPSAnX19leGVjdXRlX18nXG4gICAgKTphbnkge1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgICAgICBsZXQgY29uZmlndXJhdGlvbjphbnkgPSBvYmplY3RcbiAgICAgICAgaWYgKGRlZXAgJiYgY29uZmlndXJhdGlvbiAmJiAhY29uZmlndXJhdGlvbi5fX3RhcmdldF9fKVxuICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IFRvb2xzLmFkZER5bmFtaWNHZXR0ZXJBbmRTZXR0ZXIoXG4gICAgICAgICAgICAgICAgVG9vbHMuY29weUxpbWl0ZWRSZWN1cnNpdmVseShvYmplY3QpLCAoKHZhbHVlOmFueSk6YW55ID0+XG4gICAgICAgICAgICAgICAgICAgIFRvb2xzLnJlc29sdmVEeW5hbWljRGF0YVN0cnVjdHVyZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLCBwYXJhbWV0ZXJEZXNjcmlwdGlvbiwgcGFyYW1ldGVyLCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb25JbmRpY2F0b3JLZXksIGV4ZWN1dGlvbkluZGljYXRvcktleVxuICAgICAgICAgICAgICAgICAgICApKSwgKGtleTphbnksIHZhbHVlOmFueSk6YW55ID0+IHZhbHVlLCAnW10nLCAnJylcbiAgICAgICAgaWYgKHBhcmFtZXRlckRlc2NyaXB0aW9uLmxlbmd0aCA+IHBhcmFtZXRlci5sZW5ndGgpXG4gICAgICAgICAgICBwYXJhbWV0ZXIucHVzaChjb25maWd1cmF0aW9uKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpICYmIGRlZXApIHtcbiAgICAgICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlOm1peGVkIG9mIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIG9iamVjdFtpbmRleF0gPSBUb29scy5yZXNvbHZlRHluYW1pY0RhdGFTdHJ1Y3R1cmUoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLCBwYXJhbWV0ZXJEZXNjcmlwdGlvbiwgcGFyYW1ldGVyLCBkZWVwLFxuICAgICAgICAgICAgICAgICAgICBldmFsdWF0aW9uSW5kaWNhdG9yS2V5LCBleGVjdXRpb25JbmRpY2F0b3JLZXkpXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBvYmplY3QpXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGlvbkluZGljYXRvcktleSwgZXhlY3V0aW9uSW5kaWNhdG9yS2V5XG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRvb2xzLnJlc29sdmVEeW5hbWljRGF0YVN0cnVjdHVyZSgobmV3IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlVHlwZUNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KEZ1bmN0aW9uLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHBhcmFtZXRlckRlc2NyaXB0aW9uKS5jb25jYXQoKChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0gZXZhbHVhdGlvbkluZGljYXRvcktleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApID8gJ3JldHVybiAnIDogJycpICsgb2JqZWN0W2tleV0pKSkpLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSwgcGFyYW1ldGVyRGVzY3JpcHRpb24sIHBhcmFtZXRlciwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGlvbkluZGljYXRvcktleSwgZXhlY3V0aW9uSW5kaWNhdG9yS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGR1cmluZyAnICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID09PSBldmFsdWF0aW9uSW5kaWNhdG9yS2V5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZXhlY3V0aW5nJyA6ICdldmFsdWF0aW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApICsgYCBcIiR7b2JqZWN0W2tleV19XCI6ICR7ZXJyb3J9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gVG9vbHMucmVzb2x2ZUR5bmFtaWNEYXRhU3RydWN0dXJlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBwYXJhbWV0ZXJEZXNjcmlwdGlvbiwgcGFyYW1ldGVyLCBkZWVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb25JbmRpY2F0b3JLZXksIGV4ZWN1dGlvbkluZGljYXRvcktleSlcbiAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBnaXZlbiBvYmplY3QgaW50byBpdHMgc2VyaWFsaXplZCBqc29uIHJlcHJlc2VudGF0aW9uIGJ5XG4gICAgICogcmVwbGFjaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgd2l0aCBhIGdpdmVuIHByb3ZpZGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3QgdG8gc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSBkZXRlcm1pbmVDaWN1bGFyUmVmZXJlbmNlVmFsdWUgLSBDYWxsYmFjayB0byBjcmVhdGUgYSBmYWxsYmFja1xuICAgICAqIHZhbHVlIGRlcGVuZGluZyBvbiBnaXZlbiByZWR1bmRhbnQgdmFsdWUuXG4gICAgICogQHBhcmFtIG51bWJlck9mU3BhY2VzIC0gTnVtYmVyIG9mIHNwYWNlcyB0byB1c2UgZm9yIHN0cmluZyBmb3JtYXR0aW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0Q2lyY3VsYXJPYmplY3RUb0pTT04oXG4gICAgICAgIG9iamVjdDpPYmplY3QsIGRldGVybWluZUNpY3VsYXJSZWZlcmVuY2VWYWx1ZTooKFxuICAgICAgICAgICAga2V5OnN0cmluZywgdmFsdWU6YW55LCBzZWVuZE9iamVjdHM6QXJyYXk8YW55PlxuICAgICAgICApID0+IGFueSkgPSAoKTpzdHJpbmcgPT4gJ19fY2lyY3VsYXJSZWZlcmVuY2VfXycsXG4gICAgICAgIG51bWJlck9mU3BhY2VzOm51bWJlciA9IDBcbiAgICApOnN0cmluZyB7XG4gICAgICAgIGNvbnN0IHNlZW5PYmplY3RzOkFycmF5PGFueT4gPSBbXVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0LCAoa2V5OnN0cmluZywgdmFsdWU6YW55KTphbnkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbk9iamVjdHMuaW5jbHVkZXModmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV0ZXJtaW5lQ2ljdWxhclJlZmVyZW5jZVZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgc2Vlbk9iamVjdHMpXG4gICAgICAgICAgICAgICAgc2Vlbk9iamVjdHMucHVzaCh2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9LCBudW1iZXJPZlNwYWNlcylcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZ2l2ZW4gcGxhaW4gb2JqZWN0IGFuZCBhbGwgbmVzdGVkIGZvdW5kIG9iamVjdHMgdG9cbiAgICAgKiBjb3JyZXNwb25kaW5nIG1hcC5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGNvbnZlcnQgdG8uXG4gICAgICogQHBhcmFtIGRlZXAgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBwZXJmb3JtIGEgcmVjdXJzaXZlIGNvbnZlcnNpb24uXG4gICAgICogQHJldHVybnMgR2l2ZW4gb2JqZWN0IGFzIG1hcC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydFBsYWluT2JqZWN0VG9NYXA8VmFsdWU+KFxuICAgICAgICBvYmplY3Q6VmFsdWUsIGRlZXA6Ym9vbGVhbiA9IHRydWVcbiAgICApOlZhbHVlfE1hcDxhbnksIGFueT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgVG9vbHMuaXNQbGFpbk9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdPYmplY3Q6TWFwPGFueSwgYW55PiA9IG5ldyBNYXAoKVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIG9iamVjdClcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IFRvb2xzLmNvbnZlcnRQbGFpbk9iamVjdFRvTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBkZWVwKVxuICAgICAgICAgICAgICAgICAgICBuZXdPYmplY3Quc2V0KGtleSwgb2JqZWN0W2tleV0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld09iamVjdFxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWVwKVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZTphbnkgb2Ygb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtpbmRleF0gPSBUb29scy5jb252ZXJ0UGxhaW5PYmplY3RUb01hcCh2YWx1ZSwgZGVlcClcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5Om1peGVkLCB2YWx1ZTptaXhlZF0gb2Ygb2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc2V0KGtleSwgVG9vbHMuY29udmVydFBsYWluT2JqZWN0VG9NYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSwgZGVlcCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZ2l2ZW4gbWFwIGFuZCBhbGwgbmVzdGVkIGZvdW5kIG1hcHMgb2JqZWN0cyB0byBjb3JyZXNwb25kaW5nXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBNYXAgdG8gY29udmVydCB0by5cbiAgICAgKiBAcGFyYW0gZGVlcCAtIEluZGljYXRlcyB3aGV0aGVyIHRvIHBlcmZvcm0gYSByZWN1cnNpdmUgY29udmVyc2lvbi5cbiAgICAgKiBAcmV0dXJucyBHaXZlbiBtYXAgYXMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0TWFwVG9QbGFpbk9iamVjdDxWYWx1ZT4oXG4gICAgICAgIG9iamVjdDpWYWx1ZSwgZGVlcDpib29sZWFuID0gdHJ1ZVxuICAgICk6VmFsdWV8UGxhaW5PYmplY3Qge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdPYmplY3Q6UGxhaW5PYmplY3QgPSB7fVxuICAgICAgICAgICAgZm9yIChsZXQgW2tleTphbnksIHZhbHVlOm1peGVkXSBvZiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVlcClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBUb29scy5jb252ZXJ0TWFwVG9QbGFpbk9iamVjdCh2YWx1ZSwgZGVlcClcbiAgICAgICAgICAgICAgICBuZXdPYmplY3RbYCR7a2V5fWBdID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdPYmplY3RcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVlcClcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBUb29scy5pc1BsYWluT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gb2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IFRvb2xzLmNvbnZlcnRNYXBUb1BsYWluT2JqZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldLCBkZWVwKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXg6bnVtYmVyID0gMFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWU6bWl4ZWQgb2Ygb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtpbmRleF0gPSBUb29scy5jb252ZXJ0TWFwVG9QbGFpbk9iamVjdCh2YWx1ZSwgZGVlcClcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBnaXZlbiBvYmplY3RzIG93biBwcm9wZXJ0aWVzIGluIHNvcnRlZCBmYXNoaW9uLiBGb3JcbiAgICAgKiBlYWNoIGtleSB2YWx1ZSBwYWlyIGdpdmVuIGl0ZXJhdG9yIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcbiAgICAgKiB2YWx1ZSBhbmQga2V5IGFzIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gT2JqZWN0IHRvIGl0ZXJhdGUuXG4gICAgICogQHBhcmFtIGl0ZXJhdG9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBrZXkgdmFsdWUgcGFpci4gVmFsdWVcbiAgICAgKiB3aWxsIGJlIHRoZSBmaXJzdCBhbmQga2V5IHdpbGwgYmUgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBcInRoaXNcIiBiaW5kaW5nIGZvciBnaXZlbiBpdGVyYXRvciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGdpdmVuIHNvcnRlZCBrZXlzLlxuICAgICAqL1xuICAgIHN0YXRpYyBmb3JFYWNoU29ydGVkKFxuICAgICAgICBvYmplY3Q6bWl4ZWQsIGl0ZXJhdG9yOihrZXk6YW55LCB2YWx1ZTphbnkpID0+IGFueSwgY29udGV4dDpPYmplY3RcbiAgICApOkFycmF5PGFueT4ge1xuICAgICAgICBjb25zdCBrZXlzOkFycmF5PGFueT4gPSBUb29scy5zb3J0KG9iamVjdClcbiAgICAgICAgZm9yIChjb25zdCBrZXk6YW55IG9mIGtleXMpXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0LmdldChrZXkpLCBrZXkpXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgb2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0W2tleV0sIGtleSlcbiAgICAgICAgcmV0dXJuIGtleXNcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydCBnaXZlbiBvYmplY3RzIGtleXMuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB3aGljaCBrZXlzIHNob3VsZCBiZSBzb3J0ZWQuXG4gICAgICogQHJldHVybnMgU29ydGVkIGxpc3Qgb2YgZ2l2ZW4ga2V5cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc29ydChvYmplY3Q6bWl4ZWQpOkFycmF5PGFueT4ge1xuICAgICAgICBjb25zdCBrZXlzOkFycmF5PGFueT4gPSBbXVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKVxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXg6bnVtYmVyID0gMDsgaW5kZXggPCBvYmplY3QubGVuZ3RoOyBpbmRleCsrKVxuICAgICAgICAgICAgICAgIGtleXMucHVzaChpbmRleClcbiAgICAgICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXlWYWx1ZVBhaXI6QXJyYXk8YW55PiBvZiBvYmplY3QpXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleVZhbHVlUGFpclswXSlcbiAgICAgICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIG9iamVjdClcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpXG4gICAgICAgIHJldHVybiBrZXlzLnNvcnQoKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gaXRlbXMgYXJlIGVxdWFsIGZvciBnaXZlbiBwcm9wZXJ0eSBsaXN0LiBJZlxuICAgICAqIHByb3BlcnR5IGxpc3QgaXNuJ3Qgc2V0IGFsbCBwcm9wZXJ0aWVzIHdpbGwgYmUgY2hlY2tlZC4gQWxsIGtleXMgd2hpY2hcbiAgICAgKiBzdGFydHMgd2l0aCBvbmUgb2YgdGhlIGV4Y2VwdGlvbiBwcmVmaXhlcyB3aWxsIGJlIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIGZpcnN0VmFsdWUgLSBGaXJzdCBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gc2Vjb25kVmFsdWUgLSBTZWNvbmQgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgLSBQcm9wZXJ0eSBuYW1lcyB0byBjaGVjay4gQ2hlY2sgYWxsIGlmIFwibnVsbFwiIGlzXG4gICAgICogc2VsZWN0ZWQgKGRlZmF1bHQpLlxuICAgICAqIEBwYXJhbSBkZWVwIC0gUmVjdXJzaW9uIGRlcHRoIG5lZ2F0aXZlIHZhbHVlcyBtZWFucyBpbmZpbml0ZWx5IGRlZXBcbiAgICAgKiAoZGVmYXVsdCkuXG4gICAgICogQHBhcmFtIGV4Y2VwdGlvblByZWZpeGVzIC0gUHJvcGVydHkgcHJlZml4ZXMgd2hpY2ggaW5kaWNhdGVzIHByb3BlcnRpZXNcbiAgICAgKiB0byBpZ25vcmUuXG4gICAgICogQHBhcmFtIGlnbm9yZUZ1bmN0aW9ucyAtIEluZGljYXRlcyB3aGV0aGVyIGZ1bmN0aW9ucyBoYXZlIHRvIGJlXG4gICAgICogaWRlbnRpY2FsIHRvIGludGVycHJldCBpcyBhcyBlcXVhbC4gSWYgc2V0IHRvIFwidHJ1ZVwiIHR3byBmdW5jdGlvbnMgd2lsbFxuICAgICAqIGJlIGFzc3VtZWQgdG8gYmUgZXF1YWwgKGRlZmF1bHQpLlxuICAgICAqIEByZXR1cm5zIFZhbHVlIFwidHJ1ZVwiIGlmIGJvdGggb2JqZWN0cyBhcmUgZXF1YWwgYW5kIFwiZmFsc2VcIiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIGVxdWFscyhcbiAgICAgICAgZmlyc3RWYWx1ZTphbnksIHNlY29uZFZhbHVlOmFueSwgcHJvcGVydGllczo/QXJyYXk8YW55PiA9IG51bGwsXG4gICAgICAgIGRlZXA6bnVtYmVyID0gLTEsIGV4Y2VwdGlvblByZWZpeGVzOkFycmF5PHN0cmluZz4gPSBbJyQnLCAnXyddLFxuICAgICAgICBpZ25vcmVGdW5jdGlvbnM6Ym9vbGVhbiA9IHRydWVcbiAgICApOmJvb2xlYW4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpZ25vcmVGdW5jdGlvbnMgJiYgVG9vbHMuaXNGdW5jdGlvbihcbiAgICAgICAgICAgICAgICBmaXJzdFZhbHVlXG4gICAgICAgICAgICApICYmIFRvb2xzLmlzRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgc2Vjb25kVmFsdWVcbiAgICAgICAgICAgICkgfHwgZmlyc3RWYWx1ZSA9PT0gc2Vjb25kVmFsdWUgfHwgVG9vbHMubnVtYmVySXNOb3RBTnVtYmVyKFxuICAgICAgICAgICAgICAgIGZpcnN0VmFsdWVcbiAgICAgICAgICAgICkgJiYgVG9vbHMubnVtYmVySXNOb3RBTnVtYmVyKHNlY29uZFZhbHVlKSB8fFxuICAgICAgICAgICAgZmlyc3RWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCAmJlxuICAgICAgICAgICAgc2Vjb25kVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgJiZcbiAgICAgICAgICAgIGZpcnN0VmFsdWUudG9TdHJpbmcoKSA9PT0gc2Vjb25kVmFsdWUudG9TdHJpbmcoKSB8fFxuICAgICAgICAgICAgZmlyc3RWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICAgICAgICAgIHNlY29uZFZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAoXG4gICAgICAgICAgICAgICAgaXNOYU4oZmlyc3RWYWx1ZS5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgaXNOYU4oc2Vjb25kVmFsdWUuZ2V0VGltZSgpKSB8fFxuICAgICAgICAgICAgICAgICFpc05hTihmaXJzdFZhbHVlLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4oc2Vjb25kVmFsdWUuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGZpcnN0VmFsdWUuZ2V0VGltZSgpID09PSBzZWNvbmRWYWx1ZS5nZXRUaW1lKClcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgaWYgKFRvb2xzLmlzUGxhaW5PYmplY3QoZmlyc3RWYWx1ZSkgJiYgVG9vbHMuaXNQbGFpbk9iamVjdChcbiAgICAgICAgICAgIHNlY29uZFZhbHVlXG4gICAgICAgICkgJiYgIShcbiAgICAgICAgICAgIGZpcnN0VmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgc2Vjb25kVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgKSB8fCBBcnJheS5pc0FycmF5KGZpcnN0VmFsdWUpICYmIEFycmF5LmlzQXJyYXkoXG4gICAgICAgICAgICBzZWNvbmRWYWx1ZVxuICAgICAgICApICYmIGZpcnN0VmFsdWUubGVuZ3RoID09PSBzZWNvbmRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpcnN0LCBzZWNvbmRdIG9mIFtbZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWVdLCBbXG4gICAgICAgICAgICAgICAgc2Vjb25kVmFsdWUsIGZpcnN0VmFsdWVcbiAgICAgICAgICAgIF1dKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RJc0FycmF5OmJvb2xlYW4gPSBBcnJheS5pc0FycmF5KGZpcnN0KVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdElzQXJyYXkgJiYgKCFBcnJheS5pc0FycmF5KFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRcbiAgICAgICAgICAgICAgICApKSB8fCBmaXJzdC5sZW5ndGggIT09IHNlY29uZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIGxldCBlcXVhbDpib29sZWFuID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdElzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4Om51bWJlciA9IDBcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZTphbnkgb2YgZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWVwICE9PSAwICYmICFUb29scy5lcXVhbHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsIHNlY29uZFtpbmRleF0sIHByb3BlcnRpZXMsIGRlZXAgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvblByZWZpeGVzXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTpzdHJpbmcgaW4gZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXF1YWwgfHwgcHJvcGVydGllcyAmJiAhcHJvcGVydGllcy5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZG9CcmVhazpib29sZWFuID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNlcHRpb25QcmVmaXg6c3RyaW5nIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvblByZWZpeGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnRvU3RyaW5nKCkuc3RhcnRzV2l0aChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvblByZWZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0JyZWFrID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb0JyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWVwICE9PSAwICYmICFUb29scy5lcXVhbHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0W2tleV0sIHNlY29uZFtrZXldLCBwcm9wZXJ0aWVzLCBkZWVwIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uUHJlZml4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgZ2l2ZW4gb2JqZWN0IChvZiBhbnkgdHlwZSkgaW50byBvcHRpb25hbGx5IGdpdmVuIGRlc3RpbmF0aW9uLlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QgdG8gY29weS5cbiAgICAgKiBAcGFyYW0gcmVjdXJzaW9uTGltaXQgLSBTcGVjaWZpZXMgaG93IGRlZXAgd2Ugc2hvdWxkIHRyYXZlcnNlIGludG8gZ2l2ZW5cbiAgICAgKiBvYmplY3QgcmVjdXJzaXZlbHkuXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uIC0gVGFyZ2V0IHRvIGNvcHkgc291cmNlIHRvLlxuICAgICAqIEBwYXJhbSBzdGFja1NvdXJjZSAtIEludGVybmFsbHkgdXNlZCB0byBhdm9pZCB0cmF2ZXJzaW5nIGxvb3BzLlxuICAgICAqIEBwYXJhbSBzdGFja0Rlc3RpbmF0aW9uIC0gSW50ZXJuYWxseSB1c2VkIHRvIGF2b2lkIHRyYXZlcnNpbmcgbG9vcHMgYW5kXG4gICAgICogcmVmZXJlbmNpbmcgdGhlbSBjb3JyZWN0bHkuXG4gICAgICogQHBhcmFtIHJlY3Vyc2lvbkxldmVsIC0gSW50ZXJuYWxseSB1c2VkIHRvIHRyYWNrIGN1cnJlbnQgcmVjdXJzaW9uXG4gICAgICogbGV2ZWwgaW4gZ2l2ZW4gc291cmNlIGRhdGEgc3RydWN0dXJlLlxuICAgICAqIEByZXR1cm5zIFZhbHVlIFwidHJ1ZVwiIGlmIGJvdGggb2JqZWN0cyBhcmUgZXF1YWwgYW5kIFwiZmFsc2VcIiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIGNvcHlMaW1pdGVkUmVjdXJzaXZlbHkoXG4gICAgICAgIHNvdXJjZTphbnksIHJlY3Vyc2lvbkxpbWl0Om51bWJlciA9IC0xLCBkZXN0aW5hdGlvbjphbnkgPSBudWxsLFxuICAgICAgICBzdGFja1NvdXJjZTpBcnJheTxhbnk+ID0gW10sIHN0YWNrRGVzdGluYXRpb246QXJyYXk8YW55PiA9IFtdLFxuICAgICAgICByZWN1cnNpb25MZXZlbDpudW1iZXIgPSAwXG4gICAgKTphbnkge1xuICAgICAgICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkNhbid0IGNvcHkgYmVjYXVzZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFyZSBpZGVudGljYWwuXCIpXG4gICAgICAgICAgICBpZiAocmVjdXJzaW9uTGltaXQgIT09IC0xICYmIHJlY3Vyc2lvbkxpbWl0IDwgcmVjdXJzaW9uTGV2ZWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIGlmICghW3VuZGVmaW5lZCwgbnVsbF0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgICApICYmIHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXg6bnVtYmVyID0gc3RhY2tTb3VyY2UuaW5kZXhPZihzb3VyY2UpXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrRGVzdGluYXRpb25baW5kZXhdXG4gICAgICAgICAgICAgICAgc3RhY2tTb3VyY2UucHVzaChzb3VyY2UpXG4gICAgICAgICAgICAgICAgc3RhY2tEZXN0aW5hdGlvbi5wdXNoKGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29weVZhbHVlOkZ1bmN0aW9uID0gKHZhbHVlOmFueSk6YW55ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6YW55ID0gVG9vbHMuY29weUxpbWl0ZWRSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIHJlY3Vyc2lvbkxpbWl0LCBudWxsLCBzdGFja1NvdXJjZSwgc3RhY2tEZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uTGV2ZWwgKyAxKVxuICAgICAgICAgICAgICAgIGlmICghW3VuZGVmaW5lZCwgbnVsbF0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrU291cmNlLnB1c2godmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrRGVzdGluYXRpb24ucHVzaChyZXN1bHQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtOmFueSBvZiBzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goY29weVZhbHVlKGl0ZW0pKVxuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXk6bWl4ZWQsIHZhbHVlOm1peGVkXSBvZiBzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnNldChrZXksIGNvcHlWYWx1ZSh2YWx1ZSkpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGNvcHlWYWx1ZShzb3VyY2Vba2V5XSlcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRvb2xzLmNvcHlMaW1pdGVkUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSwgcmVjdXJzaW9uTGltaXQsIFtdLCBzdGFja1NvdXJjZSwgc3RhY2tEZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uTGV2ZWwpXG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgICAgICAgIHJldHVybiBUb29scy5jb3B5TGltaXRlZFJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsIHJlY3Vyc2lvbkxpbWl0LCBuZXcgTWFwKCksIHN0YWNrU291cmNlLFxuICAgICAgICAgICAgICAgICAgICBzdGFja0Rlc3RpbmF0aW9uLCByZWN1cnNpb25MZXZlbClcbiAgICAgICAgICAgIGlmIChUb29scy5kZXRlcm1pbmVUeXBlKHNvdXJjZSkgPT09ICdkYXRlJylcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoc291cmNlLmdldFRpbWUoKSlcbiAgICAgICAgICAgIGlmIChUb29scy5kZXRlcm1pbmVUeXBlKHNvdXJjZSkgPT09ICdyZWdleHAnKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uuc291cmNlLCBzb3VyY2UudG9TdHJpbmcoKS5tYXRjaCgvW15cXC9dKiQvKVswXSlcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5sYXN0SW5kZXggPSBzb3VyY2UubGFzdEluZGV4XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVt1bmRlZmluZWQsIG51bGxdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgKSAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICByZXR1cm4gVG9vbHMuY29weUxpbWl0ZWRSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLCByZWN1cnNpb25MaW1pdCwge30sIHN0YWNrU291cmNlLCBzdGFja0Rlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICByZWN1cnNpb25MZXZlbClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb24gfHwgc291cmNlXG4gICAgfVxuICAgIC8vIC8gZW5kcmVnaW9uXG4gICAgLy8gLyByZWdpb24gYXJyYXlcbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGUgY29udGVudHMgb2YgdHdvIGFycmF5cyB0b2dldGhlciBpbnRvIHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGFyZ2V0IGFycmF5LlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBTb3VyY2UgYXJyYXkuXG4gICAgICogQHJldHVybnMgVGFyZ2V0IGFycmF5IHdpdGggbWVyZ2VkIGdpdmVuIHNvdXJjZSBvbmUuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5TWVyZ2UodGFyZ2V0OkFycmF5PGFueT4sIHNvdXJjZTpBcnJheTxhbnk+KTpBcnJheTxhbnk+IHtcbiAgICAgICAgY29uc3QgbGVuZ3RoOm51bWJlciA9IE51bWJlcihzb3VyY2UubGVuZ3RoKVxuICAgICAgICBsZXQgc291cmNlSW5kZXg6bnVtYmVyID0gMFxuICAgICAgICBsZXQgdGFyZ2V0SW5kZXg6bnVtYmVyID0gdGFyZ2V0Lmxlbmd0aFxuICAgICAgICBmb3IgKDtzb3VyY2VJbmRleCA8IGxlbmd0aDsgc291cmNlSW5kZXgrKylcbiAgICAgICAgICAgIHRhcmdldFt0YXJnZXRJbmRleCsrXSA9IHNvdXJjZVtzb3VyY2VJbmRleF1cbiAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IHRhcmdldEluZGV4XG4gICAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZ2l2ZW4gb2JqZWN0IGludG8gYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIFRhcmdldCB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIEdlbmVyYXRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlNYWtlKG9iamVjdDphbnkpOkFycmF5PGFueT4ge1xuICAgICAgICBjb25zdCByZXN1bHQ6QXJyYXk8YW55PiA9IFtdXG4gICAgICAgIGlmICghW251bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXMocmVzdWx0KSlcbiAgICAgICAgICAgIGlmIChUb29scy5pc0FycmF5TGlrZShPYmplY3Qob2JqZWN0KSkpXG4gICAgICAgICAgICAgICAgVG9vbHMuYXJyYXlNZXJnZShcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LCB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyA/IFtvYmplY3RdIDogb2JqZWN0KVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iamVjdClcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhbGwgdmFsdWVzIGluIGdpdmVuIGl0ZXJhYmxlIHVuaXF1ZSBieSByZW1vdmluZyBkdXBsaWNhdGVzIChUaGVcbiAgICAgKiBmaXJzdCBvY2N1cnJlbmNlcyB3aWxsIGJlIGxlZnQpLlxuICAgICAqIEBwYXJhbSBkYXRhIC0gQXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICogQHJldHVybnMgU2xpY2VkIHZlcnNpb24gb2YgZ2l2ZW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheVVuaXF1ZShkYXRhOkFycmF5PGFueT4pOkFycmF5PGFueT4ge1xuICAgICAgICBjb25zdCByZXN1bHQ6QXJyYXk8YW55PiA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWU6YW55IG9mIGRhdGEpXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VtbWFyaXplcyBnaXZlbiBwcm9wZXJ0eSBvZiBnaXZlbiBpdGVtIGxpc3QuXG4gICAgICogQHBhcmFtIGRhdGEgLSBBcnJheSBvZiBvYmplY3RzIHdpdGggZ2l2ZW4gcHJvcGVydHkgbmFtZS5cbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIC0gUHJvcGVydHkgbmFtZSB0byBzdW1tYXJpemUuXG4gICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFZhbHVlIHRvIHJldHVybiBpZiBwcm9wZXJ0eSB2YWx1ZXMgZG9lc24ndCBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyBTdW1tYXJpemVkIGFycmF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheUFnZ3JlZ2F0ZVByb3BlcnR5SWZFcXVhbChcbiAgICAgICAgZGF0YTpBcnJheTxPYmplY3Q+LCBwcm9wZXJ0eU5hbWU6c3RyaW5nLCBkZWZhdWx0VmFsdWU6YW55ID0gJydcbiAgICApOmFueSB7XG4gICAgICAgIGxldCByZXN1bHQ6YW55ID0gZGVmYXVsdFZhbHVlXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoICYmIGRhdGFbMF0uaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGF0YVswXVtwcm9wZXJ0eU5hbWVdXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVtwcm9wZXJ0eU5hbWVdICE9PSByZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgZXZlcnkgaXRlbSB3aXRjaCBoYXMgb25seSBlbXB0eSBhdHRyaWJ1dGVzIGZvciBnaXZlbiBwcm9wZXJ0eVxuICAgICAqIG5hbWVzLiBJZiBnaXZlbiBwcm9wZXJ0eSBuYW1lcyBhcmUgZW1wdHkgZWFjaCBhdHRyaWJ1dGUgd2lsbCBiZVxuICAgICAqIGNvbnNpZGVyZWQuIFRoZSBlbXB0eSBzdHJpbmcsIFwibnVsbFwiIGFuZCBcInVuZGVmaW5lZFwiIHdpbGwgYmUgaW50ZXJwcmV0ZWRcbiAgICAgKiBhcyBlbXB0eS5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIERhdGEgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWVzIC0gUHJvcGVydGllcyB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJucyBHaXZlbiBkYXRhIHdpdGhvdXQgZW1wdHkgaXRlbXMuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5RGVsZXRlRW1wdHlJdGVtcyhcbiAgICAgICAgZGF0YTo/QXJyYXk8T2JqZWN0PiwgcHJvcGVydHlOYW1lczpBcnJheTxzdHJpbmc+ID0gW11cbiAgICApOj9BcnJheTxPYmplY3Q+IHtcbiAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgY29uc3QgcmVzdWx0OkFycmF5PGFueT4gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW06YW55IG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBlbXB0eTpib29sZWFuID0gdHJ1ZVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWU6c3RyaW5nIGluIGl0ZW0pXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFbJycsIG51bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXMoaXRlbVtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZVxuICAgICAgICAgICAgICAgICAgICBdKSAmJiAoIXByb3BlcnR5TmFtZXMubGVuZ3RoIHx8IHByb3BlcnR5TmFtZXMuaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWVcbiAgICAgICAgICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZW1wdHkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGFsbCBwcm9wZXJ0aWVzIGZyb20gYWxsIGl0ZW1zIHdpY2ggb2NjdXIgaW4gZ2l2ZW4gcHJvcGVydHlcbiAgICAgKiBuYW1lcy5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIERhdGEgd2hlcmUgZWFjaCBpdGVtIHNob3VsZCBiZSBzbGljZWQuXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZXMgLSBQcm9wZXJ0eSBuYW1lcyB0byBleHRyYWN0LlxuICAgICAqIEByZXR1cm5zIERhdGEgd2l0aCBzbGljZWQgaXRlbXMuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5RXh0cmFjdChcbiAgICAgICAgZGF0YTpBcnJheTxPYmplY3Q+LCBwcm9wZXJ0eU5hbWVzOkFycmF5PHN0cmluZz5cbiAgICApOkFycmF5PE9iamVjdD4ge1xuICAgICAgICBjb25zdCByZXN1bHQ6QXJyYXk8T2JqZWN0PiA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgaXRlbTpPYmplY3Qgb2YgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbTpPYmplY3QgPSB7fVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWU6c3RyaW5nIG9mIHByb3BlcnR5TmFtZXMpXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgbmV3SXRlbVtwcm9wZXJ0eU5hbWVdID0gaXRlbVtwcm9wZXJ0eU5hbWVdXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdJdGVtKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgYWxsIHZhbHVlcyB3aGljaCBtYXRjaGVzIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIERhdGEgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSByZWd1bGFyRXhwcmVzc2lvbiAtIFBhdHRlcm4gdG8gbWF0Y2ggZm9yLlxuICAgICAqIEByZXR1cm5zIEZpbHRlcmVkIGRhdGEuXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5RXh0cmFjdElmTWF0Y2hlcyhcbiAgICAgICAgZGF0YTpBcnJheTxzdHJpbmc+LCByZWd1bGFyRXhwcmVzc2lvbjpzdHJpbmd8UmVnRXhwXG4gICAgKTpBcnJheTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0OkFycmF5PHN0cmluZz4gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlOnN0cmluZyBvZiBkYXRhKVxuICAgICAgICAgICAgaWYgKCgodHlwZW9mIHJlZ3VsYXJFeHByZXNzaW9uID09PSAnc3RyaW5nJykgPyBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uXG4gICAgICAgICAgICApIDogcmVndWxhckV4cHJlc3Npb24pLnRlc3QodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgZ2l2ZW4gZGF0YSBpZiBnaXZlbiBwcm9wZXJ0eSBpcyBzZXQgb3Igbm90LlxuICAgICAqIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSAtIFByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yIGV4aXN0ZW5jZS5cbiAgICAgKiBAcmV0dXJucyBHaXZlbiBkYXRhIHdpdGhvdXQgdGhlIGl0ZW1zIHdoaWNoIGRvZXNuJ3QgaGF2ZSBzcGVjaWZpZWRcbiAgICAgKiBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlFeHRyYWN0SWZQcm9wZXJ0eUV4aXN0cyhcbiAgICAgICAgZGF0YTo/QXJyYXk8T2JqZWN0PiwgcHJvcGVydHlOYW1lOnN0cmluZ1xuICAgICk6P0FycmF5PE9iamVjdD4ge1xuICAgICAgICBpZiAoZGF0YSAmJiBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDpBcnJheTxPYmplY3Q+ID0gW11cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbTpPYmplY3Qgb2YgZGF0YSkge1xuICAgICAgICAgICAgICAgIGxldCBleGlzdHM6Ym9vbGVhbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXk6c3RyaW5nIGluIGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHByb3BlcnR5TmFtZSAmJiBpdGVtLmhhc093blByb3BlcnR5KGtleSkgJiYgIVtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgbnVsbFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKGl0ZW1ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0cyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgZ2l2ZW4gZGF0YSB3aGVyZSBzcGVjaWZpZWQgcHJvcGVydHkgdmFsdWUgbWF0Y2hlcyBnaXZlblxuICAgICAqIHBhdHRlcm5zLlxuICAgICAqIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHByb3BlcnR5UGF0dGVybiAtIE1hcHBpbmcgb2YgcHJvcGVydHkgbmFtZXMgdG8gcGF0dGVybi5cbiAgICAgKiBAcmV0dXJucyBGaWx0ZXJlZCBkYXRhLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheUV4dHJhY3RJZlByb3BlcnR5TWF0Y2hlcyhcbiAgICAgICAgZGF0YTo/QXJyYXk8T2JqZWN0PiwgcHJvcGVydHlQYXR0ZXJuOntba2V5OnN0cmluZ106c3RyaW5nfFJlZ0V4cH1cbiAgICApOj9BcnJheTxPYmplY3Q+IHtcbiAgICAgICAgaWYgKGRhdGEgJiYgcHJvcGVydHlQYXR0ZXJuKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6QXJyYXk8T2JqZWN0PiA9IFtdXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW06T2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlczpib29sZWFuID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lOnN0cmluZyBpbiBwcm9wZXJ0eVBhdHRlcm4pXG4gICAgICAgICAgICAgICAgICAgIGlmICghKChcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5UGF0dGVybltwcm9wZXJ0eU5hbWVdIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgICAgICAgICAgICAgICkgPyBwcm9wZXJ0eVBhdHRlcm5bcHJvcGVydHlOYW1lXSA6IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVBhdHRlcm5bcHJvcGVydHlOYW1lXVxuICAgICAgICAgICAgICAgICAgICApKS50ZXN0KGl0ZW1bcHJvcGVydHlOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYWxsIG9iamVjdHMgd2hpY2ggZXhpc3RzIGluIFwiZmlyc3RTZXRcIiBhbmQgaW4gXCJzZWNvbmRTZXRcIi5cbiAgICAgKiBPYmplY3Qga2V5IHdoaWNoIHdpbGwgYmUgY29tcGFyZWQgYXJlIGdpdmVuIGJ5IFwia2V5c1wiLiBJZiBhbiBlbXB0eSBhcnJheVxuICAgICAqIGlzIGdpdmVuIGVhY2gga2V5IHdpbGwgYmUgY29tcGFyZWQuIElmIGFuIG9iamVjdCBpcyBnaXZlbiBjb3JyZXNwb25kaW5nXG4gICAgICogaW5pdGlhbCBkYXRhIGtleSB3aWxsIGJlIG1hcHBlZCB0byByZWZlcmVuY2VkIG5ldyBkYXRhIGtleS5cbiAgICAgKiBAcGFyYW0gZmlyc3RTZXQgLSBSZWZlcmVuY2VkIGRhdGEgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSBzZWNvbmRTZXQgLSBEYXRhIHRvIGNoZWNrIGZvciBleGlzdGVuY2UuXG4gICAgICogQHBhcmFtIGtleXMgLSBLZXlzIHRvIGRlZmluZSBlcXVhbGl0eS5cbiAgICAgKiBAcGFyYW0gc3RyaWN0IC0gVGhlIHN0cmljdCBwYXJhbWV0ZXIgaW5kaWNhdGVzIHdoZXRoZXIgXCJudWxsXCIgYW5kXG4gICAgICogXCJ1bmRlZmluZWRcIiBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgZXF1YWwgKHRha2VzIG9ubHkgZWZmZWN0IGlmIGdpdmVuXG4gICAgICoga2V5cyBhcmVuJ3QgZW1wdHkpLlxuICAgICAqIEByZXR1cm5zIERhdGEgd2hpY2ggZG9lcyBleGl0IGluIGdpdmVuIGluaXRpYWwgZGF0YS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlJbnRlcnNlY3QoXG4gICAgICAgIGZpcnN0U2V0OkFycmF5PGFueT4sIHNlY29uZFNldDpBcnJheTxhbnk+LFxuICAgICAgICBrZXlzOk9iamVjdHxBcnJheTxzdHJpbmc+ID0gW10sIHN0cmljdDpib29sZWFuID0gdHJ1ZVxuICAgICk6QXJyYXk8YW55PiB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5pbmdEYXRhOkFycmF5PGFueT4gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGluaXRpYWxJdGVtOmFueSBvZiBmaXJzdFNldClcbiAgICAgICAgICAgIGlmIChUb29scy5pc1BsYWluT2JqZWN0KGluaXRpYWxJdGVtKSlcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5ld0l0ZW06YW55IG9mIHNlY29uZFNldCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzOmJvb2xlYW4gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRlR2l2ZW5LZXlzOmJvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5c0FyZUFuQXJyYXk6Ym9vbGVhbiA9IEFycmF5LmlzQXJyYXkoa2V5cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRvb2xzLmlzUGxhaW5PYmplY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzXG4gICAgICAgICAgICAgICAgICAgICkgfHwga2V5c0FyZUFuQXJyYXkgJiYga2V5cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlR2l2ZW5LZXlzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVHaXZlbktleXMgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cyA9IGluaXRpYWxJdGVtXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlOkZ1bmN0aW9uID0gKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTZXRLZXk6c3RyaW5nfG51bWJlciwgc2Vjb25kU2V0S2V5OnN0cmluZ3xudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgKTo/ZmFsc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNBcmVBbkFycmF5ICYmIGl0ZXJhdGVHaXZlbktleXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTZXRLZXkgPSBzZWNvbmRTZXRLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpdGVyYXRlR2l2ZW5LZXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFNldEtleSA9IGZpcnN0U2V0S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3SXRlbVtzZWNvbmRTZXRLZXldICE9PSBpbml0aWFsSXRlbVtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFNldEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgXSAmJiAoc3RyaWN0IHx8ICEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW251bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW1bc2Vjb25kU2V0S2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgJiYgW251bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxJdGVtW2ZpcnN0U2V0S2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RzID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4Om51bWJlciA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZShpbmRleCwga2V5KSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5OnN0cmluZyBpbiBrZXlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUoa2V5LCBrZXlzW2tleV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdEYXRhLnB1c2goaW5pdGlhbEl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2Vjb25kU2V0LmluY2x1ZGVzKGluaXRpYWxJdGVtKSlcbiAgICAgICAgICAgICAgICBjb250YWluaW5nRGF0YS5wdXNoKGluaXRpYWxJdGVtKVxuICAgICAgICByZXR1cm4gY29udGFpbmluZ0RhdGFcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxpc3Qgb2YgaXRlbXMgd2l0aGluIGdpdmVuIHJhbmdlLlxuICAgICAqIEBwYXJhbSByYW5nZSAtIEFycmF5IG9mIGxvd2VyIGFuZCB1cHBlciBib3VuZHMuIElmIG9ubHkgb25lIHZhbHVlIGlzXG4gICAgICogZ2l2ZW4gbG93ZXIgYm91bmQgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIHplcm8uIEJvdGggaW50ZWdlcnMgaGF2ZSB0byBiZVxuICAgICAqIHBvc2l0aXZlIGFuZCB3aWxsIGJlIGNvbnRhaW5lZCBpbiB0aGUgcmVzdWx0aW5nIGFycmF5LlxuICAgICAqIEBwYXJhbSBzdGVwIC0gU3BhY2UgYmV0d2VlbiB0d28gY29uc2VjdXRpdmUgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIFByb2R1Y2VkIGFycmF5IG9mIGludGVnZXJzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheU1ha2VSYW5nZShyYW5nZTpBcnJheTxudW1iZXI+LCBzdGVwOm51bWJlciA9IDEpOkFycmF5PG51bWJlcj4ge1xuICAgICAgICBsZXQgaW5kZXg6bnVtYmVyXG4gICAgICAgIGxldCBoaWdoZXJCb3VuZDpudW1iZXJcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaW5kZXggPSAwXG4gICAgICAgICAgICBoaWdoZXJCb3VuZCA9IHBhcnNlSW50KHJhbmdlWzBdLCAxMClcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQocmFuZ2VbMF0sIDEwKVxuICAgICAgICAgICAgaGlnaGVyQm91bmQgPSBwYXJzZUludChyYW5nZVsxXSwgMTApXG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtpbmRleF1cbiAgICAgICAgd2hpbGUgKGluZGV4IDw9IGhpZ2hlckJvdW5kIC0gc3RlcCkge1xuICAgICAgICAgICAgaW5kZXggKz0gc3RlcFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdW1zIHVwIGdpdmVuIHByb3BlcnR5IG9mIGdpdmVuIGl0ZW0gbGlzdC5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBvYmplY3RzIHdpdGggc3BlY2lmaWVkIHByb3BlcnR5IHRvIHN1bSB1cC5cbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIC0gUHJvcGVydHkgbmFtZSB0byBzdW0gdXAgaXRzIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBhZ2dyZWdhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheVN1bVVwUHJvcGVydHkoXG4gICAgICAgIGRhdGE6P0FycmF5PE9iamVjdD4sIHByb3BlcnR5TmFtZTpzdHJpbmdcbiAgICApOm51bWJlciB7XG4gICAgICAgIGxldCByZXN1bHQ6bnVtYmVyID0gMFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbTpPYmplY3Qgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcGFyc2VGbG9hdChpdGVtW3Byb3BlcnR5TmFtZV0gfHwgMClcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gYW5vdGhlciBpdGVtIGFzIGFycmF5IGNvbm5lY3Rpb24gKG1hbnkgdG8gb25lKS5cbiAgICAgKiBAcGFyYW0gaXRlbSAtIEl0ZW0gd2hlcmUgdGhlIGl0ZW0gc2hvdWxkIGJlIGFwcGVuZGVkIHRvLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUYXJnZXQgdG8gYWRkIHRvIGdpdmVuIGl0ZW0uXG4gICAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSB0YXJnZXQgY29ubmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY2hlY2tJZkV4aXN0cyAtIEluZGljYXRlcyBpZiBkdXBsaWNhdGVzIGFyZSBhbGxvd2VkIGluIHJlc3VsdGluZ1xuICAgICAqIGxpc3QgKHdpbGwgcmVzdWx0IGluIGxpbmVhciBydW50aW1lIGluc3RlYWQgb2YgY29uc3RhbnQgb25lKS5cbiAgICAgKiBAcmV0dXJucyBJdGVtIHdpdGggdGhlIGFwcGVuZGVkIHRhcmdldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlBcHBlbmRBZGQoXG4gICAgICAgIGl0ZW06T2JqZWN0LCB0YXJnZXQ6YW55LCBuYW1lOnN0cmluZywgY2hlY2tJZkV4aXN0czpib29sZWFuID0gdHJ1ZVxuICAgICk6T2JqZWN0IHtcbiAgICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIGlmICghKGNoZWNrSWZFeGlzdHMgJiYgaXRlbVtuYW1lXS5pbmNsdWRlcyh0YXJnZXQpKSlcbiAgICAgICAgICAgICAgICBpdGVtW25hbWVdLnB1c2godGFyZ2V0KVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGl0ZW1bbmFtZV0gPSBbdGFyZ2V0XVxuICAgICAgICByZXR1cm4gaXRlbVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIHRhcmdldCBvbiBnaXZlbiBsaXN0LlxuICAgICAqIEBwYXJhbSBsaXN0IC0gQXJyYXkgdG8gc3BsaWNlLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUYXJnZXQgdG8gcmVtb3ZlIGZyb20gZ2l2ZW4gbGlzdC5cbiAgICAgKiBAcGFyYW0gc3RyaWN0IC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gZmlyZSBhbiBleGNlcHRpb24gaWYgZ2l2ZW4gdGFyZ2V0XG4gICAgICogZG9lc24ndCBleGlzdHMgZ2l2ZW4gbGlzdC5cbiAgICAgKiBAcmV0dXJucyBJdGVtIHdpdGggdGhlIGFwcGVuZGVkIHRhcmdldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXlSZW1vdmUoXG4gICAgICAgIGxpc3Q6P0FycmF5PGFueT4sIHRhcmdldDphbnksIHN0cmljdDpib29sZWFuID0gZmFsc2VcbiAgICApOj9BcnJheTxhbnk+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4Om51bWJlciA9IGxpc3QuaW5kZXhPZih0YXJnZXQpXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJHaXZlbiB0YXJnZXQgZG9lc24ndCBleGlzdHMgaW4gZ2l2ZW4gbGlzdC5cIilcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lICovXG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiR2l2ZW4gdGFyZ2V0IGlzbid0IGFuIGFycmF5LlwiKVxuICAgICAgICByZXR1cm4gbGlzdFxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIHN0cmluZ1xuICAgIC8vIC8vIHJlZ2lvbiB1cmwgaGFuZGxpbmdcbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGdpdmVuIHN0cmluZyBpbnRvIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gdmFsaWRhdGVkXG4gICAgICogcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIGV4Y2x1ZGVTeW1ib2xzIC0gU3ltYm9scyBub3QgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIENvbnZlcnRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0NvbnZlcnRUb1ZhbGlkUmVndWxhckV4cHJlc3Npb24oXG4gICAgICAgIHZhbHVlOnN0cmluZywgZXhjbHVkZVN5bWJvbHM6QXJyYXk8c3RyaW5nPiA9IFtdXG4gICAgKTpzdHJpbmcge1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIG9ubHkgZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cy5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSAmJiAhVG9vbHMuc3BlY2lhbFJlZ2V4U2VxdWVuY2VzLmluY2x1ZGVzKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBUaGUgZXNjYXBlIHNlcXVlbmNlIG11c3QgYWxzbyBiZSBlc2NhcGVkOyBidXQgYXQgZmlyc3QuXG4gICAgICAgIGlmICghZXhjbHVkZVN5bWJvbHMuaW5jbHVkZXMoJ1xcXFwnKSlcbiAgICAgICAgICAgIHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgICAgZm9yIChjb25zdCByZXBsYWNlOnN0cmluZyBvZiBUb29scy5zcGVjaWFsUmVnZXhTZXF1ZW5jZXMpXG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVTeW1ib2xzLmluY2x1ZGVzKHJlcGxhY2UpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChgXFxcXCR7cmVwbGFjZX1gLCAnZycpLCBgXFxcXCR7cmVwbGFjZX1gKVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBnaXZlbiBuYW1lIGludG8gYSB2YWxpZCBqYXZhU2NyaXB0IG9uZS5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gYWxsb3dlZFN5bWJvbHMgLSBTdHJpbmcgb2Ygc3ltYm9scyB3aGljaCBzaG91bGQgYmUgYWxsb3dlZCB3aXRoaW5cbiAgICAgKiBhIHZhcmlhYmxlIG5hbWUgKG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyKS5cbiAgICAgKiBAcmV0dXJucyBDb252ZXJ0ZWQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nQ29udmVydFRvVmFsaWRWYXJpYWJsZU5hbWUoXG4gICAgICAgIG5hbWU6c3RyaW5nLCBhbGxvd2VkU3ltYm9sczpzdHJpbmcgPSAnMC05YS16QS1aXyQnXG4gICAgKTpzdHJpbmcge1xuICAgICAgICByZXR1cm4gbmFtZS50b1N0cmluZygpLnJlcGxhY2UoL15bXmEtekEtWl8kXSsvLCAnJykucmVwbGFjZShcbiAgICAgICAgICAgIG5ldyBSZWdFeHAoYFteJHthbGxvd2VkU3ltYm9sc31dKyhbYS16QS1aMC05XSlgLCAnZycpLCAoXG4gICAgICAgICAgICAgICAgZnVsbE1hdGNoOnN0cmluZywgZmlyc3RMZXR0ZXI6c3RyaW5nXG4gICAgICAgICAgICApOnN0cmluZyA9PiBmaXJzdExldHRlci50b1VwcGVyQ2FzZSgpKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZW5jb2RpbmcgKmtleSogb3IgKnZhbHVlKiBwYXJ0cyBvZiBxdWVyeVxuICAgICAqIGNvbXBvbmVudC4gV2UgbmVlZCBhIGN1c3RvbSBtZXRob2QgYmVjYXVzZSBcImVuY29kZVVSSUNvbXBvbmVudCgpXCIgaXMgdG9vXG4gICAgICogYWdncmVzc2l2ZSBhbmQgZW5jb2RlcyBzdHVmZiB0aGF0IGRvZXNuJ3QgaGF2ZSB0byBiZSBlbmNvZGVkIHBlclxuICAgICAqIFwiaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NjpcIi5cbiAgICAgKiBAcGFyYW0gdXJsIC0gVVJMIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gZW5jb2RlU3BhY2VzIC0gSW5kaWNhdGVzIHdoZXRoZXIgZ2l2ZW4gdXJsIHNob3VsZCBlbmNvZGVcbiAgICAgKiB3aGl0ZXNwYWNlcyBhcyBcIitcIiBvciBcIiUyMFwiLlxuICAgICAqIEByZXR1cm5zIEVuY29kZWQgZ2l2ZW4gdXJsLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdFbmNvZGVVUklDb21wb25lbnQodXJsOnN0cmluZywgZW5jb2RlU3BhY2VzOmJvb2xlYW4pOnN0cmluZyB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodXJsKS5yZXBsYWNlKC8lNDAvZ2ksICdAJykucmVwbGFjZShcbiAgICAgICAgICAgIC8lM0EvZ2ksICc6J1xuICAgICAgICApLnJlcGxhY2UoLyUyNC9nLCAnJCcpLnJlcGxhY2UoLyUyQy9naSwgJywnKS5yZXBsYWNlKFxuICAgICAgICAgICAgLyUyMC9nLCAoZW5jb2RlU3BhY2VzKSA/ICclMjAnIDogJysnKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcGF0aCBzZWxlY3RvciB0byB0aGUgZ2l2ZW4gcGF0aCBpZiB0aGVyZSBpc24ndCBvbmUgeWV0LlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggZm9yIGFwcGVuZGluZyBhIHNlbGVjdG9yLlxuICAgICAqIEBwYXJhbSBwYXRoU2VwYXJhdG9yIC0gVGhlIHNlbGVjdG9yIGZvciBhcHBlbmRpbmcgdG8gcGF0aC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwZW5kZWQgcGF0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nQWRkU2VwYXJhdG9yVG9QYXRoKFxuICAgICAgICBwYXRoOnN0cmluZywgcGF0aFNlcGFyYXRvcjpzdHJpbmcgPSAnLydcbiAgICApOnN0cmluZyB7XG4gICAgICAgIHBhdGggPSBwYXRoLnRyaW0oKVxuICAgICAgICBpZiAocGF0aC5zdWJzdHIoLTEpICE9PSBwYXRoU2VwYXJhdG9yICYmIHBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHBhdGggKyBwYXRoU2VwYXJhdG9yXG4gICAgICAgIHJldHVybiBwYXRoXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiBwYXRoIGhhcyBnaXZlbiBwYXRoIHByZWZpeC5cbiAgICAgKiBAcGFyYW0gcHJlZml4IC0gUGF0aCBwcmVmaXggdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gc2VhcmNoIGluLlxuICAgICAqIEBwYXJhbSBzZXBhcmF0b3IgLSBEZWxpbWl0ZXIgdG8gdXNlIGluIHBhdGggKGRlZmF1bHQgaXMgdGhlIHBvc2l4XG4gICAgICogY29uZm9ybSBzbGFzaCkuXG4gICAgICogQHJldHVybnMgVmFsdWUgXCJ0cnVlXCIgaWYgZ2l2ZW4gcHJlZml4IG9jY3VyIGFuZCBcImZhbHNlXCIgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdIYXNQYXRoUHJlZml4KFxuICAgICAgICBwcmVmaXg6P3N0cmluZyA9ICcvYWRtaW4nLFxuICAgICAgICBwYXRoOnN0cmluZyA9IChcbiAgICAgICAgICAgICdsb2NhdGlvbicgaW4gJC5nbG9iYWwgJiYgJC5nbG9iYWwubG9jYXRpb24ucGF0aG5hbWUgfHwgJycpLFxuICAgICAgICBzZXBhcmF0b3I6c3RyaW5nID0gJy8nXG4gICAgKTpib29sZWFuIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIXByZWZpeC5lbmRzV2l0aChzZXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgIHByZWZpeCArPSBzZXBhcmF0b3JcbiAgICAgICAgICAgIHJldHVybiBwYXRoID09PSBwcmVmaXguc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgIDAsIHByZWZpeC5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoXG4gICAgICAgICAgICApIHx8IHBhdGguc3RhcnRzV2l0aChwcmVmaXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGRvbWFpbiBuYW1lIGZyb20gZ2l2ZW4gdXJsLiBJZiBubyBleHBsaWNpdCBkb21haW4gbmFtZSBnaXZlblxuICAgICAqIGN1cnJlbnQgZG9tYWluIG5hbWUgd2lsbCBiZSBhc3N1bWVkLiBJZiBubyBwYXJhbWV0ZXIgZ2l2ZW4gY3VycmVudFxuICAgICAqIGRvbWFpbiBuYW1lIHdpbGwgYmUgZGV0ZXJtaW5lZC5cbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIHVybCB0byBleHRyYWN0IGRvbWFpbiBmcm9tLlxuICAgICAqIEBwYXJhbSBmYWxsYmFjayAtIFRoZSBmYWxsYmFjayBob3N0IG5hbWUgaWYgbm8gb25lIGV4aXRzIGluIGdpdmVuIHVybFxuICAgICAqIChkZWZhdWx0IGlzIGN1cnJlbnQgaG9zdG5hbWUpLlxuICAgICAqIEByZXR1cm5zIEV4dHJhY3RlZCBkb21haW4uXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0dldERvbWFpbk5hbWUoXG4gICAgICAgIHVybDpzdHJpbmcgPSAnbG9jYXRpb24nIGluICQuZ2xvYmFsICYmICQuZ2xvYmFsLmxvY2F0aW9uLmhyZWYgfHwgJycsXG4gICAgICAgIGZhbGxiYWNrOmFueSA9IChcbiAgICAgICAgICAgICdsb2NhdGlvbicgaW4gJC5nbG9iYWwgJiYgJC5nbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHwgJycpXG4gICAgKTphbnkge1xuICAgICAgICBjb25zdCByZXN1bHQ6QXJyYXk8P3N0cmluZz4gPVxuICAgICAgICAgICAgL14oW2Etel0qOj9cXC9cXC8pPyhbXi9dKz8pKD86OlswLTldKyk/KD86XFwvLip8JCkvaS5leGVjKHVybClcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMiAmJiByZXN1bHRbMV0gJiYgcmVzdWx0WzJdKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFsyXVxuICAgICAgICByZXR1cm4gZmFsbGJhY2tcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgcG9ydCBudW1iZXIgZnJvbSBnaXZlbiB1cmwuIElmIG5vIGV4cGxpY2l0IHBvcnQgbnVtYmVyIGdpdmVuXG4gICAgICogYW5kIG5vIGZhbGxiYWNrIGlzIGRlZmluZWQgY3VycmVudCBwb3J0IG51bWJlciB3aWxsIGJlIGFzc3VtZWQgZm9yIGxvY2FsXG4gICAgICogbGlua3MuIEZvciBleHRlcm5hbCBsaW5rcyA4MCB3aWxsIGJlIGFzc3VtZWQgZm9yIGh0dHAgcHJvdG9jb2wgb3IgNDQzXG4gICAgICogZm9yIGh0dHBzLlxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgdXJsIHRvIGV4dHJhY3QgcG9ydCBmcm9tLlxuICAgICAqIEBwYXJhbSBmYWxsYmFjayAtIEZhbGxiYWNrIHBvcnQgbnVtYmVyIGlmIG5vIGV4cGxpY2l0IG9uZSB3YXMgZm91bmQuXG4gICAgICogRGVmYXVsdCBpcyBkZXJpdmVkIGZyb20gY3VycmVudCBwcm90b2NvbCBuYW1lLlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXIgLSBBZGRpdGlvbmFsIHBhcmFtZXRlciBmb3IgY2hlY2tpbmcgaWYgZ2l2ZW4gdXJsIGlzIGFuXG4gICAgICogaW50ZXJuYWwgdXJsLiBHaXZlbiB1cmwgYW5kIHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZVxuICAgICAqIFwic3RyaW5nSXNJbnRlcm5hbFVSTCgpXCIgbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIEV4dHJhY3RlZCBwb3J0IG51bWJlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nR2V0UG9ydE51bWJlcihcbiAgICAgICAgdXJsOnN0cmluZyA9ICdsb2NhdGlvbicgaW4gJC5nbG9iYWwgJiYgJC5nbG9iYWwubG9jYXRpb24uaHJlZiB8fCAnJyxcbiAgICAgICAgZmFsbGJhY2s6YW55ID0gbnVsbCwgcGFyYW1ldGVyOkFycmF5PHN0cmluZz4gPSBbXVxuICAgICk6bnVtYmVyIHtcbiAgICAgICAgY29uc3QgcmVzdWx0OkFycmF5PD9zdHJpbmc+ID1cbiAgICAgICAgICAgIC9eKD86W2Etel0qOj9cXC9cXC9bXi9dKz8pPyg/OlteL10rPyk6KFswLTldKykvaS5leGVjKHVybClcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChyZXN1bHRbMV0sIDEwKVxuICAgICAgICBpZiAoZmFsbGJhY2sgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2tcbiAgICAgICAgaWYgKFRvb2xzLnN0cmluZ0lzSW50ZXJuYWxVUkwuYXBwbHkoXG4gICAgICAgICAgICB0aGlzLCBbdXJsXS5jb25jYXQocGFyYW1ldGVyKVxuICAgICAgICAgICAgKSAmJiAnbG9jYXRpb24nIGluICQuZ2xvYmFsICYmICQuZ2xvYmFsLmxvY2F0aW9uLnBvcnQgJiZcbiAgICAgICAgICAgIHBhcnNlSW50KCQuZ2xvYmFsLmxvY2F0aW9uLnBvcnQsIDEwKVxuICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoJC5nbG9iYWwubG9jYXRpb24ucG9ydCwgMTApXG4gICAgICAgIHJldHVybiAoVG9vbHMuc3RyaW5nR2V0UHJvdG9jb2xOYW1lKHVybCkgPT09ICdodHRwcycpID8gNDQzIDogODBcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgcHJvdG9jb2wgbmFtZSBmcm9tIGdpdmVuIHVybC4gSWYgbm8gZXhwbGljaXQgdXJsIGlzIGdpdmVuLFxuICAgICAqIGN1cnJlbnQgcHJvdG9jb2wgd2lsbCBiZSBhc3N1bWVkLiBJZiBubyBwYXJhbWV0ZXIgZ2l2ZW4gY3VycmVudCBwcm90b2NvbFxuICAgICAqIG51bWJlciB3aWxsIGJlIGRldGVybWluZWQuXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSB1cmwgdG8gZXh0cmFjdCBwcm90b2NvbCBmcm9tLlxuICAgICAqIEBwYXJhbSBmYWxsYmFjayAtIEZhbGxiYWNrIHBvcnQgdG8gdXNlIGlmIG5vIHByb3RvY29sIGV4aXN0cyBpbiBnaXZlblxuICAgICAqIHVybCAoZGVmYXVsdCBpcyBjdXJyZW50IHByb3RvY29sKS5cbiAgICAgKiByZXR1cm5zIEV4dHJhY3RlZCBwcm90b2NvbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nR2V0UHJvdG9jb2xOYW1lKFxuICAgICAgICB1cmw6c3RyaW5nID0gJ2xvY2F0aW9uJyBpbiAkLmdsb2JhbCAmJiAkLmdsb2JhbC5sb2NhdGlvbi5ocmVmIHx8ICcnLFxuICAgICAgICBmYWxsYmFjazphbnkgPSAnbG9jYXRpb24nIGluICQuZ2xvYmFsICYmXG4gICAgICAgICAgICAkLmdsb2JhbC5sb2NhdGlvbi5wcm90b2NvbC5zdWJzdHJpbmcoXG4gICAgICAgICAgICAgICAgMCwgJC5nbG9iYWwubG9jYXRpb24ucHJvdG9jb2wubGVuZ3RoIC0gMSkgfHwgJydcbiAgICApOmFueSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDpBcnJheTw/c3RyaW5nPiA9IC9eKFthLXpdKyk6XFwvXFwvL2kuZXhlYyh1cmwpXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDEgJiYgcmVzdWx0WzFdKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFsxXVxuICAgICAgICByZXR1cm4gZmFsbGJhY2tcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIHBhZ2UncyBHRVQgVVJMIHZhcmlhYmxlcyBhbmQgcmV0dXJuIHRoZW0gYXMgYW4gYXNzb2NpYXRpdmUgYXJyYXlcbiAgICAgKiBhbmQgcHJlc2VydmVzIG9yZGVyaW5nLlxuICAgICAqIEBwYXJhbSBrZXlUb0dldCAtIElmIGtleSBnaXZlbiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBpcyByZXR1cm5lZCBhbmRcbiAgICAgKiBmdWxsIG9iamVjdCBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIGdpdmVuSW5wdXQgLSBBbiBhbHRlcm5hdGl2ZSBpbnB1dCB0byB0aGUgdXJsIHNlYXJjaCBwYXJhbWV0ZXIuIElmXG4gICAgICogXCIjXCIgaXMgZ2l2ZW4gdGhlIGNvbXBsZXRlIGN1cnJlbnQgaGFzaCB0YWcgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyB1cmxcbiAgICAgKiBhbmQgc2VhcmNoIHBhcmFtZXRlciB3aWxsIGJlIGV4dHJhY3RlZCBmcm9tIHRoZXJlLiBJZiBcIiZcIiBpcyBnaXZlblxuICAgICAqIGNsYXNzaWNhbCBzZWFyY2ggcGFyYW1ldGVyIGFuZCBoYXNoIHBhcmFtZXRlciB3aWxsIGJlIHRha2VuIGluIGFjY291bnQuXG4gICAgICogSWYgYSBzZWFyY2ggc3RyaW5nIGlzIGdpdmVuIHRoaXMgd2lsbCBiZSBhbmFseXplZC4gVGhlIGRlZmF1bHQgaXMgdG9cbiAgICAgKiB0YWtlIGdpdmVuIHNlYXJjaCBwYXJ0IGludG8gYWNjb3VudC5cbiAgICAgKiBAcGFyYW0gc3ViRGVsaW1pdGVyIC0gRGVmaW5lcyB3aGljaCBzZXF1ZW5jZSBpbmRpY2F0ZXMgdGhlIHN0YXJ0IG9mXG4gICAgICogcGFyYW1ldGVyIGluIGEgaGFzaCBwYXJ0IG9mIHRoZSB1cmwuXG4gICAgICogQHBhcmFtIGhhc2hlZFBhdGhJbmRpY2F0b3IgLSBJZiBkZWZpbmVkIGFuZCBnaXZlbiBoYXNoIHN0YXJ0cyB3aXRoIHRoaXNcbiAgICAgKiBpbmRpY2F0b3IgZ2l2ZW4gaGFzaCB3aWxsIGJlIGludGVycHJldGVkIGFzIHBhdGggY29udGFpbmluZyBzZWFyY2ggYW5kXG4gICAgICogaGFzaCBwYXJ0cy5cbiAgICAgKiBAcGFyYW0gZ2l2ZW5TZWFyY2ggLSBTZWFyY2ggcGFydCB0byB0YWtlIGludG8gYWNjb3VudCBkZWZhdWx0cyB0b1xuICAgICAqIGN1cnJlbnQgdXJsIHNlYXJjaCBwYXJ0LlxuICAgICAqIEBwYXJhbSBnaXZlbkhhc2ggLSBIYXNoIHBhcnQgdG8gdGFrZSBpbnRvIGFjY291bnQgZGVmYXVsdHMgdG8gY3VycmVudFxuICAgICAqIHVybCBoYXNoIHBhcnQuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgY3VycmVudCBnZXQgYXJyYXkgb3IgcmVxdWVzdGVkIHZhbHVlLiBJZiByZXF1ZXN0ZWRcbiAgICAgKiBrZXkgZG9lc24ndCBleGlzdCBcInVuZGVmaW5lZFwiIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdHZXRVUkxWYXJpYWJsZShcbiAgICAgICAga2V5VG9HZXQ6c3RyaW5nLCBnaXZlbklucHV0Oj9zdHJpbmcsIHN1YkRlbGltaXRlcjpzdHJpbmcgPSAnJCcsXG4gICAgICAgIGhhc2hlZFBhdGhJbmRpY2F0b3I6c3RyaW5nID0gJyEnLCBnaXZlblNlYXJjaDo/c3RyaW5nLFxuICAgICAgICBnaXZlbkhhc2g6P3N0cmluZyA9IChcbiAgICAgICAgICAgICdsb2NhdGlvbicgaW4gJC5nbG9iYWwgJiYgJC5nbG9iYWwubG9jYXRpb24uaGFzaCB8fCAnJylcbiAgICApOkFycmF5PHN0cmluZz58c3RyaW5nIHtcbiAgICAgICAgLy8gcmVnaW9uIHNldCBzZWFyY2ggYW5kIGhhc2hcbiAgICAgICAgbGV0IGhhc2g6c3RyaW5nID0gKGdpdmVuSGFzaCkgPyBnaXZlbkhhc2ggOiAnIydcbiAgICAgICAgbGV0IHNlYXJjaDpzdHJpbmcgPSAnJ1xuICAgICAgICBpZiAoZ2l2ZW5TZWFyY2gpXG4gICAgICAgICAgICBzZWFyY2ggPSBnaXZlblNlYXJjaFxuICAgICAgICBlbHNlIGlmIChoYXNoZWRQYXRoSW5kaWNhdG9yICYmIGhhc2guc3RhcnRzV2l0aChoYXNoZWRQYXRoSW5kaWNhdG9yKSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViSGFzaFN0YXJ0SW5kZXg6bnVtYmVyID0gaGFzaC5pbmRleE9mKCcjJylcbiAgICAgICAgICAgIGxldCBwYXRoQW5kU2VhcmNoOnN0cmluZ1xuICAgICAgICAgICAgaWYgKHN1Ykhhc2hTdGFydEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGhBbmRTZWFyY2ggPSBoYXNoLnN1YnN0cmluZyhoYXNoZWRQYXRoSW5kaWNhdG9yLmxlbmd0aClcbiAgICAgICAgICAgICAgICBoYXNoID0gJydcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aEFuZFNlYXJjaCA9IGhhc2guc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBoYXNoZWRQYXRoSW5kaWNhdG9yLmxlbmd0aCwgc3ViSGFzaFN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgaGFzaCA9IGhhc2guc3Vic3RyaW5nKHN1Ykhhc2hTdGFydEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ViU2VhcmNoU3RhcnRJbmRleDpudW1iZXIgPSBwYXRoQW5kU2VhcmNoLmluZGV4T2YoJz8nKVxuICAgICAgICAgICAgaWYgKHN1YlNlYXJjaFN0YXJ0SW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIHNlYXJjaCA9IHBhdGhBbmRTZWFyY2guc3Vic3RyaW5nKHN1YlNlYXJjaFN0YXJ0SW5kZXgpXG4gICAgICAgIH0gZWxzZSBpZiAoJ2xvY2F0aW9uJyBpbiAkLmdsb2JhbClcbiAgICAgICAgICAgIHNlYXJjaCA9ICQuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCB8fCAnJ1xuICAgICAgICBsZXQgaW5wdXQ6c3RyaW5nID0gKGdpdmVuSW5wdXQpID8gZ2l2ZW5JbnB1dCA6IHNlYXJjaFxuICAgICAgICAvLyBlbmRyZWdpb25cbiAgICAgICAgLy8gcmVnaW9uIGRldGVybWluZSBkYXRhIGZyb20gc2VhcmNoIGFuZCBoYXNoIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBib3RoOmJvb2xlYW4gPSBpbnB1dCA9PT0gJyYnXG4gICAgICAgIGlmIChib3RoIHx8IGlucHV0ID09PSAnIycpIHtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkSGFzaDpzdHJpbmcgPSAnJ1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkSGFzaCA9IGRlY29kZVVSSUNvbXBvbmVudChoYXNoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgICAgICBjb25zdCBzdWJEZWxpbWl0ZXJJbmRleDpudW1iZXIgPSBkZWNvZGVkSGFzaC5pbmRleE9mKHN1YkRlbGltaXRlcilcbiAgICAgICAgICAgIGlmIChzdWJEZWxpbWl0ZXJJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgaW5wdXQgPSAnJ1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBkZWNvZGVkSGFzaC5zdWJzdHJpbmcoc3ViRGVsaW1pdGVySW5kZXgpXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoc3ViRGVsaW1pdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHJpbmcoc3ViRGVsaW1pdGVyLmxlbmd0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5zdGFydHNXaXRoKCc/JykpXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygnPycubGVuZ3RoKVxuICAgICAgICBsZXQgZGF0YTpBcnJheTxzdHJpbmc+ID0gKGlucHV0KSA/IGlucHV0LnNwbGl0KCcmJykgOiBbXVxuICAgICAgICBzZWFyY2ggPSBzZWFyY2guc3Vic3RyaW5nKCc/Jy5sZW5ndGgpXG4gICAgICAgIGlmIChib3RoICYmIHNlYXJjaClcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChzZWFyY2guc3BsaXQoJyYnKSlcbiAgICAgICAgLy8gZW5kcmVnaW9uXG4gICAgICAgIC8vIHJlZ2lvbiBjb25zdHJ1Y3QgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgY29uc3QgdmFyaWFibGVzOkFycmF5PHN0cmluZz4gPSBbXVxuICAgICAgICBmb3IgKGxldCB2YWx1ZTpzdHJpbmcgb2YgZGF0YSkge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsdWVQYWlyOkFycmF5PHN0cmluZz4gPSB2YWx1ZS5zcGxpdCgnPScpXG4gICAgICAgICAgICBsZXQga2V5OnN0cmluZ1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5VmFsdWVQYWlyWzBdKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXlWYWx1ZVBhaXJbMV0pXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKGtleSlcbiAgICAgICAgICAgIC8vIElnbm9yZVR5cGVDaGVja1xuICAgICAgICAgICAgdmFyaWFibGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIC8vIGVuZHJlZ2lvblxuICAgICAgICBpZiAoa2V5VG9HZXQpXG4gICAgICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZXNba2V5VG9HZXRdXG4gICAgICAgIHJldHVybiB2YXJpYWJsZXNcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGdpdmVuIHVybCBwb2ludHMgdG8gYW5vdGhlciBkb21haW4gdGhhbiBzZWNvbmQgZ2l2ZW4gdXJsLiBJZlxuICAgICAqIG5vIHNlY29uZCBnaXZlbiB1cmwgcHJvdmlkZWQgY3VycmVudCB1cmwgd2lsbCBiZSBhc3N1bWVkLlxuICAgICAqIEBwYXJhbSBmaXJzdFVSTCAtIFVSTCB0byBjaGVjayBhZ2FpbnN0IHNlY29uZCB1cmwuXG4gICAgICogQHBhcmFtIHNlY29uZFVSTCAtIFVSTCB0byBjaGVjayBhZ2FpbnN0IGZpcnN0IHVybC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIFwidHJ1ZVwiIGlmIGdpdmVuIGZpcnN0IHVybCBoYXMgc2FtZSBkb21haW4gYXMgZ2l2ZW5cbiAgICAgKiBzZWNvbmQgKG9yIGN1cnJlbnQpLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdJc0ludGVybmFsVVJMKFxuICAgICAgICBmaXJzdFVSTDpzdHJpbmcsIHNlY29uZFVSTDpzdHJpbmcgPSAnbG9jYXRpb24nIGluICQuZ2xvYmFsICYmXG4gICAgICAgICQuZ2xvYmFsLmxvY2F0aW9uLmhyZWYgfHwgJydcbiAgICApOmJvb2xlYW4ge1xuICAgICAgICBjb25zdCBleHBsaWNpdERvbWFpbk5hbWU6c3RyaW5nID0gVG9vbHMuc3RyaW5nR2V0RG9tYWluTmFtZShcbiAgICAgICAgICAgIGZpcnN0VVJMLCBmYWxzZSlcbiAgICAgICAgY29uc3QgZXhwbGljaXRQcm90b2NvbE5hbWU6c3RyaW5nID0gVG9vbHMuc3RyaW5nR2V0UHJvdG9jb2xOYW1lKFxuICAgICAgICAgICAgZmlyc3RVUkwsIGZhbHNlKVxuICAgICAgICBjb25zdCBleHBsaWNpdFBvcnROdW1iZXIgPSBUb29scy5zdHJpbmdHZXRQb3J0TnVtYmVyKGZpcnN0VVJMLCBmYWxzZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICFleHBsaWNpdERvbWFpbk5hbWUgfHxcbiAgICAgICAgICAgIGV4cGxpY2l0RG9tYWluTmFtZSA9PT0gVG9vbHMuc3RyaW5nR2V0RG9tYWluTmFtZShzZWNvbmRVUkwpXG4gICAgICAgICkgJiYgKFxuICAgICAgICAgICAgIWV4cGxpY2l0UHJvdG9jb2xOYW1lIHx8XG4gICAgICAgICAgICBleHBsaWNpdFByb3RvY29sTmFtZSA9PT0gVG9vbHMuc3RyaW5nR2V0UHJvdG9jb2xOYW1lKHNlY29uZFVSTClcbiAgICAgICAgKSAmJiAoXG4gICAgICAgICAgICAhZXhwbGljaXRQb3J0TnVtYmVyIHx8XG4gICAgICAgICAgICBleHBsaWNpdFBvcnROdW1iZXIgPT09IFRvb2xzLnN0cmluZ0dldFBvcnROdW1iZXIoc2Vjb25kVVJMKSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplZCBnaXZlbiB3ZWJzaXRlIHVybC5cbiAgICAgKiBAcGFyYW0gdXJsIC0gVW5pZm9ybSByZXNvdXJjZSBsb2NhdG9yIHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyBOb3JtYWxpemVkIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nTm9ybWFsaXplVVJMKHVybDo/c3RyaW5nKTpzdHJpbmcge1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXjo/XFwvKy8sICcnKS5yZXBsYWNlKC9cXC8rJC8sICcnKS50cmltKClcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgICAgIHJldHVybiBgaHR0cDovLyR7dXJsfWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBnaXZlbiB3ZWJzaXRlIHVybC5cbiAgICAgKiBAcGFyYW0gdXJsIC0gVW5pZm9ybSByZXNvdXJjZSBsb2NhdG9yIHRvIHJlcHJlc2VudC5cbiAgICAgKiBAcmV0dXJucyBSZXByZXNlbnRlZCByZXN1bHQuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ1JlcHJlc2VudFVSTCh1cmw6P3N0cmluZyk6c3RyaW5nIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKGh0dHBzPyk/Oj9cXC8rLywgJycpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgL1xcLyskLywgJydcbiAgICAgICAgICAgICkudHJpbSgpXG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICAvLyAvLyBlbmRyZWdpb25cbiAgICAvKipcbiAgICAgKiBDb21wcmVzc2VzIGdpdmVuIHN0eWxlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gc3R5bGVWYWx1ZSAtIFN0eWxlIHZhbHVlIHRvIGNvbXByZXNzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wcmVzc2VkIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdDb21wcmVzc1N0eWxlVmFsdWUoc3R5bGVWYWx1ZTpzdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIHJldHVybiBzdHlsZVZhbHVlLnJlcGxhY2UoLyAqKFs6O10pICovZywgJyQxJykucmVwbGFjZShcbiAgICAgICAgICAgIC8gKy9nLCAnICdcbiAgICAgICAgKS5yZXBsYWNlKC9eOysvLCAnJykucmVwbGFjZSgvOyskLywgJycpLnRyaW0oKVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9yZXF1aXJlLWRlc2NyaXB0aW9uLWNvbXBsZXRlLXNlbnRlbmNlICovXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBjYW1lbCBjYXNlZCBzdHJpbmcgdG8gaXRzIGRlbGltaXRlZCBzdHJpbmcgdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0gc3RyaW5nIC0gVGhlIHN0cmluZyB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGRlbGltaXRlciAtIERlbGltaXRlciBzdHJpbmdcbiAgICAgKiBAcGFyYW0gYWJicmV2aWF0aW9ucyAtIENvbGxlY3Rpb24gb2Ygc2hvcnRjdXQgd29yZHMgdG8gcmVwcmVzZW50IHVwcGVyXG4gICAgICogY2FzZWQuXG4gICAgICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ0NhbWVsQ2FzZVRvRGVsaW1pdGVkKFxuICAgICAgICBzdHJpbmc6c3RyaW5nLCBkZWxpbWl0ZXI6c3RyaW5nID0gJy0nLFxuICAgICAgICBhYmJyZXZpYXRpb25zOj9BcnJheTxzdHJpbmc+ID0gbnVsbFxuICAgICk6c3RyaW5nIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb24tY29tcGxldGUtc2VudGVuY2UgKi9cbiAgICAgICAgaWYgKCFhYmJyZXZpYXRpb25zKVxuICAgICAgICAgICAgYWJicmV2aWF0aW9ucyA9IFRvb2xzLmFiYnJldmlhdGlvbnNcbiAgICAgICAgY29uc3QgZXNjYXBlZERlbGltaXRlcjpzdHJpbmcgPVxuICAgICAgICAgICAgVG9vbHMuc3RyaW5nR2V0UmVndWxhckV4cHJlc3Npb25WYWxpZGF0ZWQoZGVsaW1pdGVyKVxuICAgICAgICBpZiAoYWJicmV2aWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBhYmJyZXZpYXRpb25QYXR0ZXJuOnN0cmluZyA9ICcnXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFiYnJldmlhdGlvbjpzdHJpbmcgb2YgYWJicmV2aWF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhYmJyZXZpYXRpb25QYXR0ZXJuKVxuICAgICAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb25QYXR0ZXJuICs9ICd8J1xuICAgICAgICAgICAgICAgIGFiYnJldmlhdGlvblBhdHRlcm4gKz0gYWJicmV2aWF0aW9uLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgYCgke2FiYnJldmlhdGlvblBhdHRlcm59KSgke2FiYnJldmlhdGlvblBhdHRlcm59KWAsICdnJ1xuICAgICAgICAgICAgKSwgYCQxJHtkZWxpbWl0ZXJ9JDJgKVxuICAgICAgICB9XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBgKFteJHtlc2NhcGVkRGVsaW1pdGVyfV0pKFtBLVpdW2Etel0rKWAsICdnJ1xuICAgICAgICApLCBgJDEke2RlbGltaXRlcn0kMmApXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShcbiAgICAgICAgICAgIG5ldyBSZWdFeHAoJyhbYS16MC05XSkoW0EtWl0pJywgJ2cnKSwgYCQxJHtkZWxpbWl0ZXJ9JDJgXG4gICAgICAgICkudG9Mb3dlckNhc2UoKVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9yZXF1aXJlLWRlc2NyaXB0aW9uLWNvbXBsZXRlLXNlbnRlbmNlICovXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gaXRzIGNhcGl0YWxpemUgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gZm9ybWF0LlxuICAgICAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdDYXBpdGFsaXplKHN0cmluZzpzdHJpbmcpOnN0cmluZyB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBqc2RvYy9yZXF1aXJlLWRlc2NyaXB0aW9uLWNvbXBsZXRlLXNlbnRlbmNlICovXG4gICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyaW5nKDEpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgZGVsaW1pdGVkIHN0cmluZyB0byBpdHMgY2FtZWwgY2FzZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0gc3RyaW5nIC0gVGhlIHN0cmluZyB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGRlbGltaXRlciAtIERlbGltaXRlciBzdHJpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBhYmJyZXZpYXRpb25zIC0gQ29sbGVjdGlvbiBvZiBzaG9ydGN1dCB3b3JkcyB0byByZXByZXNlbnQgdXBwZXJcbiAgICAgKiBjYXNlZC5cbiAgICAgKiBAcGFyYW0gcHJlc2VydmVXcm9uZ0Zvcm1hdHRlZEFiYnJldmlhdGlvbnMgLSBJZiBzZXQgdG8gXCJUcnVlXCIgd3JvbmdcbiAgICAgKiBmb3JtYXR0ZWQgY2FtZWwgY2FzZSBhYmJyZXZpYXRpb25zIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0gcmVtb3ZlTXVsdGlwbGVEZWxpbWl0ZXIgLSBJbmRpY2F0ZXMgd2hldGhlciBhIHNlcmllcyBvZiBkZWxpbWl0ZXJcbiAgICAgKiBzaG91bGQgYmUgY29uc29saWRhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdEZWxpbWl0ZWRUb0NhbWVsQ2FzZShcbiAgICAgICAgc3RyaW5nOnN0cmluZywgZGVsaW1pdGVyOnN0cmluZyA9ICctJyxcbiAgICAgICAgYWJicmV2aWF0aW9uczo/QXJyYXk8c3RyaW5nPiA9IG51bGwsXG4gICAgICAgIHByZXNlcnZlV3JvbmdGb3JtYXR0ZWRBYmJyZXZpYXRpb25zOmJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgcmVtb3ZlTXVsdGlwbGVEZWxpbWl0ZXI6Ym9vbGVhbiA9IGZhbHNlXG4gICAgKTpzdHJpbmcge1xuICAgICAgICBsZXQgZXNjYXBlZERlbGltaXRlcjpzdHJpbmcgPVxuICAgICAgICAgICAgVG9vbHMuc3RyaW5nR2V0UmVndWxhckV4cHJlc3Npb25WYWxpZGF0ZWQoZGVsaW1pdGVyKVxuICAgICAgICBpZiAoIWFiYnJldmlhdGlvbnMpXG4gICAgICAgICAgICBhYmJyZXZpYXRpb25zID0gVG9vbHMuYWJicmV2aWF0aW9uc1xuICAgICAgICBsZXQgYWJicmV2aWF0aW9uUGF0dGVybjpzdHJpbmdcbiAgICAgICAgaWYgKHByZXNlcnZlV3JvbmdGb3JtYXR0ZWRBYmJyZXZpYXRpb25zKVxuICAgICAgICAgICAgYWJicmV2aWF0aW9uUGF0dGVybiA9IGFiYnJldmlhdGlvbnMuam9pbignfCcpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJicmV2aWF0aW9uUGF0dGVybiA9ICcnXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFiYnJldmlhdGlvbjpzdHJpbmcgb2YgYWJicmV2aWF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhYmJyZXZpYXRpb25QYXR0ZXJuKVxuICAgICAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb25QYXR0ZXJuICs9ICd8J1xuICAgICAgICAgICAgICAgIGFiYnJldmlhdGlvblBhdHRlcm4gKz1cbiAgICAgICAgICAgICAgICAgICAgYCR7VG9vbHMuc3RyaW5nQ2FwaXRhbGl6ZShhYmJyZXZpYXRpb24pfXwke2FiYnJldmlhdGlvbn1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0c1dpdGhEZWxpbWl0ZXI6Ym9vbGVhbiA9IGZhbHNlXG4gICAgICAgIGlmIChzdHJpbmcuc3RhcnRzV2l0aChkZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKGRlbGltaXRlci5sZW5ndGgpXG4gICAgICAgICAgICBzdHJpbmdTdGFydHNXaXRoRGVsaW1pdGVyID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBgKCR7ZXNjYXBlZERlbGltaXRlcn0pKCR7YWJicmV2aWF0aW9uUGF0dGVybn0pYCArXG4gICAgICAgICAgICBgKCR7ZXNjYXBlZERlbGltaXRlcn18JClgLCAnZydcbiAgICAgICAgKSwgKFxuICAgICAgICAgICAgZnVsbE1hdGNoOnN0cmluZywgYmVmb3JlOnN0cmluZywgYWJicmV2aWF0aW9uOnN0cmluZywgYWZ0ZXI6c3RyaW5nXG4gICAgICAgICk6c3RyaW5nID0+IGJlZm9yZSArIGFiYnJldmlhdGlvbi50b1VwcGVyQ2FzZSgpICsgYWZ0ZXIpXG4gICAgICAgIGlmIChyZW1vdmVNdWx0aXBsZURlbGltaXRlcilcbiAgICAgICAgICAgIGVzY2FwZWREZWxpbWl0ZXIgPSBgKD86JHtlc2NhcGVkRGVsaW1pdGVyfSkrYFxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKFxuICAgICAgICAgICAgYCR7ZXNjYXBlZERlbGltaXRlcn0oW2EtekEtWjAtOV0pYCwgJ2cnXG4gICAgICAgICksIChmdWxsTWF0Y2g6c3RyaW5nLCBmaXJzdExldHRlcjpzdHJpbmcpOnN0cmluZyA9PlxuICAgICAgICAgICAgZmlyc3RMZXR0ZXIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgaWYgKHN0cmluZ1N0YXJ0c1dpdGhEZWxpbWl0ZXIpXG4gICAgICAgICAgICBzdHJpbmcgPSBkZWxpbWl0ZXIgKyBzdHJpbmdcbiAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHN0cmluZyBmb3JtYXRpb24uIFJlcGxhY2VzIGV2ZXJ5IHBsYWNlaG9sZGVyIFwie2l9XCIgd2l0aCB0aGVcbiAgICAgKiBpJ3RoIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEFyZ3VtZW50cyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBpbnRlcnByZXRlZCBhc1xuICAgICAqIHJlcGxhY2VtZW50cyBmb3Igc3RyaW5nIGZvcm1hdGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nRm9ybWF0KFxuICAgICAgICBzdHJpbmc6c3RyaW5nLCAuLi5hZGRpdGlvbmFsQXJndW1lbnRzOkFycmF5PGFueT5cbiAgICApOnN0cmluZyB7XG4gICAgICAgIGFkZGl0aW9uYWxBcmd1bWVudHMudW5zaGlmdChzdHJpbmcpXG4gICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWU6c3RyaW5nfG51bWJlciBvZiBhZGRpdGlvbmFsQXJndW1lbnRzKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShcbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKGBcXFxceyR7aW5kZXh9XFxcXH1gLCAnZ20nKSwgYCR7dmFsdWV9YClcbiAgICAgICAgICAgIGluZGV4ICs9IDFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgY3VycmVudCBzdHJpbmcgZm9yIHVzaW5nIGluIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4uXG4gICAgICogU3BlY2lhbCByZWd1bGFyIGV4cHJlc3Npb24gY2hhcnMgd2lsbCBiZSBlc2NhcGVkLlxuICAgICAqIEBwYXJhbSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nR2V0UmVndWxhckV4cHJlc3Npb25WYWxpZGF0ZWQoc3RyaW5nOnN0cmluZyk6c3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oW1xcXFx8LiokXitbXFxdKCk/XFwte31dKS9nLCAnXFxcXCQxJylcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gaXRzIGxvd2VyIGNhc2UgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gZm9ybWF0LlxuICAgICAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdMb3dlckNhc2Uoc3RyaW5nOnN0cmluZyk6c3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zdWJzdHJpbmcoMSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHMgZ2l2ZW4gbWFyayBzdHJpbmdzIGluIGdpdmVuIHRhcmdldCB3aXRoIGdpdmVuIG1hcmtlci5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gU3RyaW5nIHRvIHNlYXJjaCBmb3IgbWFya2VyLlxuICAgICAqIEBwYXJhbSBtYXJrIC0gU3RyaW5nIHRvIHNlYXJjaCBpbiB0YXJnZXQgZm9yLlxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSBIVE1MIHRlbXBsYXRlIHN0cmluZyB0byBtYXJrLlxuICAgICAqIEBwYXJhbSBjYXNlU2Vuc2l0aXZlIC0gSW5kaWNhdGVzIHdoZXRoZXIgY2FzZSB0YWtlcyBhIHJvbGUgZHVyaW5nXG4gICAgICogc2VhcmNoaW5nLlxuICAgICAqIEByZXR1cm5zIFByb2Nlc3NlZCByZXN1bHQuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZ01hcmsoXG4gICAgICAgIHRhcmdldDo/c3RyaW5nLCBtYXJrOj9zdHJpbmcsXG4gICAgICAgIG1hcmtlcjpzdHJpbmcgPSAnPHNwYW4gY2xhc3M9XCJ0b29scy1tYXJrXCI+ezF9PC9zcGFuPicsXG4gICAgICAgIGNhc2VTZW5zaXRpdmU6Ym9vbGVhbiA9IGZhbHNlXG4gICAgKTo/c3RyaW5nIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiBtYXJrKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQudHJpbSgpXG4gICAgICAgICAgICBtYXJrID0gbWFyay50cmltKClcbiAgICAgICAgICAgIGxldCBvZmZzZXQ6bnVtYmVyID0gMFxuICAgICAgICAgICAgbGV0IHNlYXJjaFRhcmdldDpzdHJpbmcgPSB0YXJnZXRcbiAgICAgICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICBzZWFyY2hUYXJnZXQgPSBzZWFyY2hUYXJnZXQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKVxuICAgICAgICAgICAgICAgIG1hcmsgPSBtYXJrLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXg6bnVtYmVyID0gc2VhcmNoVGFyZ2V0LmluZGV4T2YobWFyaywgb2Zmc2V0KVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgVG9vbHMuc3RyaW5nRm9ybWF0KFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLCB0YXJnZXQuc3Vic3RyKGluZGV4LCBtYXJrLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKSArIHRhcmdldC5zdWJzdHJpbmcoaW5kZXggKyBtYXJrLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoVGFyZ2V0ID0gdGFyZ2V0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gaW5kZXggKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIubGVuZ3RoIC0gJ3sxfScubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICkgKyBtYXJrLmxlbmd0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIG1kNSBoYXNoIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjYWxjdWxhdGUgbWQ1IGhhc2ggZm9yLlxuICAgICAqIEBwYXJhbSBvbmx5QXNjaWkgLSBTZXQgdG8gdHJ1ZSBpZiBnaXZlbiBpbnB1dCBoYXMgYXNjaWkgY2hhcmFjdGVycyBvbmx5XG4gICAgICogdG8gZ2V0IG1vcmUgcGVyZm9ybWFuY2UuXG4gICAgICogQHJldHVybnMgQ2FsY3VsYXRlZCBtZDUgaGFzaCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nTUQ1KHZhbHVlOnN0cmluZywgb25seUFzY2lpOmJvb2xlYW4gPSBmYWxzZSk6c3RyaW5nIHtcbiAgICAgICAgY29uc3QgaGV4Q2hhcmFjdGVyczpBcnJheTxzdHJpbmc+ID0gJzAxMjM0NTY3ODlhYmNkZWYnLnNwbGl0KCcnKVxuICAgICAgICAvLyByZWdpb24gc3ViIGhlbHBlclxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBtdWNoIGZhc3Rlciwgc28gaWYgcG9zc2libGUgd2UgdXNlIGl0LiBTb21lIElFc1xuICAgICAgICAgKiBhcmUgdGhlIG9ubHkgb25lcyBJIGtub3cgb2YgdGhhdCBuZWVkIHRoZSBpZGlvdGljIHNlY29uZCBmdW5jdGlvbixcbiAgICAgICAgICogZ2VuZXJhdGVkIGJ5IGFuIGlmIGNsYXVzZSBpbiB0aGUgZW5kLlxuICAgICAgICAgKiBAcGFyYW0gZmlyc3QgLSBGaXJzdCBvcGVyYW5kIHRvIGFkZC5cbiAgICAgICAgICogQHBhcmFtIHNlY29uZCAtIFNlY29uZCBvcGVyYW50IHRvIGFkZC5cbiAgICAgICAgICogQHJldHVybnMgVGhlIHN1bSBvZiBib3RoIGdpdmVuIG9wZXJhbmRzLlxuICAgICAgICAqL1xuICAgICAgICBsZXQgdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24gPSAoXG4gICAgICAgICAgICBmaXJzdDpudW1iZXIsIHNlY29uZDpudW1iZXJcbiAgICAgICAgKTpudW1iZXIgPT4gKGZpcnN0ICsgc2Vjb25kKSAmIDB4RkZGRkZGRkZcbiAgICAgICAgLy8gLyByZWdpb24gcHJpbWFyeSBmdW5jdGlvbnMgbmVlZGVkIGZvciB0aGUgYWxnb3JpdGhtXG4gICAgICAgIC8qXG4gICAgICAgICAqIEltcGxlbWVudHMgdGhlIGJhc2ljIG9wZXJhdGlvbiBmb3IgZWFjaCByb3VuZCBvZiB0aGUgYWxnb3JpdGhtLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY21uID0gKFxuICAgICAgICAgICAgcTpudW1iZXIsIGE6bnVtYmVyLCBiOm51bWJlciwgeDpudW1iZXIsIHM6bnVtYmVyLCB0Om51bWJlclxuICAgICAgICApOm51bWJlciA9PiB7XG4gICAgICAgICAgICBhID0gdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24oXG4gICAgICAgICAgICAgICAgdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24oYSwgcSksXG4gICAgICAgICAgICAgICAgdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24oeCwgdCkpXG4gICAgICAgICAgICByZXR1cm4gdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24oXG4gICAgICAgICAgICAgICAgKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJzdCBhbGdvcml0aG0gcGFydC5cbiAgICAgICAgICogQHBhcmFtIGEgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBjIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIGQgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0geCAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBzIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIHQgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcmV0dXJucyBSZXN1bHQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBmZiA9IChcbiAgICAgICAgICAgIGE6bnVtYmVyLCBiOm51bWJlciwgYzpudW1iZXIsIGQ6bnVtYmVyLCB4Om51bWJlciwgczpudW1iZXIsXG4gICAgICAgICAgICB0Om51bWJlclxuICAgICAgICApOm51bWJlciA9PiBjbW4oKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWNvbmQgYWxnb3JpdGhtIHBhcnQuXG4gICAgICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIGIgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gYyAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBkIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIHggLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gcyAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSB0IC0gT3BlcmFuZC5cbiAgICAgICAgICogQHJldHVybnMgUmVzdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZ2cgPSAoXG4gICAgICAgICAgICBhOm51bWJlciwgYjpudW1iZXIsIGM6bnVtYmVyLCBkOm51bWJlciwgeDpudW1iZXIsIHM6bnVtYmVyLFxuICAgICAgICAgICAgdDpudW1iZXJcbiAgICAgICAgKTpudW1iZXIgPT4gY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcmQgYWxnb3JpdGhtIHBhcnQuXG4gICAgICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIGIgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gYyAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBkIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIHggLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gcyAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSB0IC0gT3BlcmFuZC5cbiAgICAgICAgICogQHJldHVybnMgUmVzdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaGggPSAoXG4gICAgICAgICAgICBhOm51bWJlciwgYjpudW1iZXIsIGM6bnVtYmVyLCBkOm51bWJlciwgeDpudW1iZXIsIHM6bnVtYmVyLFxuICAgICAgICAgICAgdDpudW1iZXJcbiAgICAgICAgKTpudW1iZXIgPT4gY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdClcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvdXJ0aCBhbGdvcml0aG0gcGFydC5cbiAgICAgICAgICogQHBhcmFtIGEgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBjIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIGQgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcGFyYW0geCAtIE9wZXJhbmQuXG4gICAgICAgICAqIEBwYXJhbSBzIC0gT3BlcmFuZC5cbiAgICAgICAgICogQHBhcmFtIHQgLSBPcGVyYW5kLlxuICAgICAgICAgKiBAcmV0dXJucyBSZXN1bHQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpaSA9IChcbiAgICAgICAgICAgIGE6bnVtYmVyLCBiOm51bWJlciwgYzpudW1iZXIsIGQ6bnVtYmVyLCB4Om51bWJlciwgczpudW1iZXIsXG4gICAgICAgICAgICB0Om51bWJlclxuICAgICAgICApOm51bWJlciA9PiBjbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhbGwgMTYgbmVlZGVkIHN0ZXBzLlxuICAgICAgICAgKiBAcGFyYW0gc3RhdGUgLSBDdXJyZW50IHN0YXRlLlxuICAgICAgICAgKiBAcGFyYW0gYmxvY2tzIC0gQmxvY2tzIHRvIGN5Y2xlIHRocm91Z2guXG4gICAgICAgICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjeWNsZSA9IChzdGF0ZTpBcnJheTxhbnk+LCBibG9ja3M6QXJyYXk8YW55Pik6QXJyYXk8YW55PiA9PiB7XG4gICAgICAgICAgICBsZXQgYTphbnkgPSBzdGF0ZVswXVxuICAgICAgICAgICAgbGV0IGI6YW55ID0gc3RhdGVbMV1cbiAgICAgICAgICAgIGxldCBjOmFueSA9IHN0YXRlWzJdXG4gICAgICAgICAgICBsZXQgZDphbnkgPSBzdGF0ZVszXVxuICAgICAgICAgICAgLy8gcmVnaW9uIHJvdW5kIDFcbiAgICAgICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBibG9ja3NbMF0sIDcsIC02ODA4NzY5MzYpXG4gICAgICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywgYmxvY2tzWzFdLCAxMiwgLTM4OTU2NDU4NilcbiAgICAgICAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBibG9ja3NbMl0sIDE3LCA2MDYxMDU4MTkpXG4gICAgICAgICAgICBiID0gZmYoYiwgYywgZCwgYSwgYmxvY2tzWzNdLCAyMiwgLTEwNDQ1MjUzMzApXG5cbiAgICAgICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBibG9ja3NbNF0sIDcsIC0xNzY0MTg4OTcpXG4gICAgICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywgYmxvY2tzWzVdLCAxMiwgMTIwMDA4MDQyNilcbiAgICAgICAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBibG9ja3NbNl0sIDE3LCAtMTQ3MzIzMTM0MSlcbiAgICAgICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBibG9ja3NbN10sIDIyLCAtNDU3MDU5ODMpXG5cbiAgICAgICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBibG9ja3NbOF0sIDcsIDE3NzAwMzU0MTYpXG4gICAgICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywgYmxvY2tzWzldLCAxMiwgLTE5NTg0MTQ0MTcpXG4gICAgICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwgYmxvY2tzWzEwXSwgMTcsIC00MjA2MylcbiAgICAgICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBibG9ja3NbMTFdLCAyMiwgLTE5OTA0MDQxNjIpXG5cbiAgICAgICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBibG9ja3NbMTJdLCA3LCAxODA0NjAzNjgyKVxuICAgICAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJsb2Nrc1sxM10sIDEyLCAtNDAzNDExMDEpXG4gICAgICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwgYmxvY2tzWzE0XSwgMTcsIC0xNTAyMDAyMjkwKVxuICAgICAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJsb2Nrc1sxNV0sIDIyLCAxMjM2NTM1MzI5KVxuICAgICAgICAgICAgLy8gZW5kcmVnaW9uXG4gICAgICAgICAgICAvLyByZWdpb24gcm91bmQgMlxuICAgICAgICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJsb2Nrc1sxXSwgNSwgLTE2NTc5NjUxMClcbiAgICAgICAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBibG9ja3NbNl0sIDksIC0xMDY5NTAxNjMyKVxuICAgICAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJsb2Nrc1sxMV0sIDE0LCA2NDM3MTc3MTMpXG4gICAgICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwgYmxvY2tzWzBdLCAyMCwgLTM3Mzg5NzMwMilcblxuICAgICAgICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJsb2Nrc1s1XSwgNSwgLTcwMTU1ODY5MSlcbiAgICAgICAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBibG9ja3NbMTBdLCA5LCAzODAxNjA4MylcbiAgICAgICAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBibG9ja3NbMTVdLCAxNCwgLTY2MDQ3ODMzNSlcbiAgICAgICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBibG9ja3NbNF0sIDIwLCAtNDA1NTM3ODQ4KVxuXG4gICAgICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwgYmxvY2tzWzldLCA1LCA1Njg0NDY0MzgpXG4gICAgICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywgYmxvY2tzWzE0XSwgOSwgLTEwMTk4MDM2OTApXG4gICAgICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwgYmxvY2tzWzNdLCAxNCwgLTE4NzM2Mzk2MSlcbiAgICAgICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBibG9ja3NbOF0sIDIwLCAxMTYzNTMxNTAxKVxuXG4gICAgICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwgYmxvY2tzWzEzXSwgNSwgLTE0NDQ2ODE0NjcpXG4gICAgICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywgYmxvY2tzWzJdLCA5LCAtNTE0MDM3ODQpXG4gICAgICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwgYmxvY2tzWzddLCAxNCwgMTczNTMyODQ3MylcbiAgICAgICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBibG9ja3NbMTJdLCAyMCwgLTE5MjY2MDc3MzQpXG4gICAgICAgICAgICAvLyBlbmRyZWdpb25cbiAgICAgICAgICAgIC8vIHJlZ2lvbiByb3VuZCAzXG4gICAgICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwgYmxvY2tzWzVdLCA0LCAtMzc4NTU4KVxuICAgICAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJsb2Nrc1s4XSwgMTEsIC0yMDIyNTc0NDYzKVxuICAgICAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJsb2Nrc1sxMV0sIDE2LCAxODM5MDMwNTYyKVxuICAgICAgICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJsb2Nrc1sxNF0sIDIzLCAtMzUzMDk1NTYpXG5cbiAgICAgICAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBibG9ja3NbMV0sIDQsIC0xNTMwOTkyMDYwKVxuICAgICAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJsb2Nrc1s0XSwgMTEsIDEyNzI4OTMzNTMpXG4gICAgICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwgYmxvY2tzWzddLCAxNiwgLTE1NTQ5NzYzMilcbiAgICAgICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBibG9ja3NbMTBdLCAyMywgLTEwOTQ3MzA2NDApXG5cbiAgICAgICAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBibG9ja3NbMTNdLCA0LCA2ODEyNzkxNzQpXG4gICAgICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywgYmxvY2tzWzBdLCAxMSwgLTM1ODUzNzIyMilcbiAgICAgICAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBibG9ja3NbM10sIDE2LCAtNzIyNTIxOTc5KVxuICAgICAgICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJsb2Nrc1s2XSwgMjMsIDc2MDI5MTg5KVxuXG4gICAgICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwgYmxvY2tzWzldLCA0LCAtNjQwMzY0NDg3KVxuICAgICAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJsb2Nrc1sxMl0sIDExLCAtNDIxODE1ODM1KVxuICAgICAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJsb2Nrc1sxNV0sIDE2LCA1MzA3NDI1MjApXG4gICAgICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwgYmxvY2tzWzJdLCAyMywgLTk5NTMzODY1MSlcbiAgICAgICAgICAgIC8vIGVuZHJlZ2lvblxuICAgICAgICAgICAgLy8gcmVnaW9uIHJvdW5kIDRcbiAgICAgICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBibG9ja3NbMF0sIDYsIC0xOTg2MzA4NDQpXG4gICAgICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywgYmxvY2tzWzddLCAxMCwgMTEyNjg5MTQxNSlcbiAgICAgICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBibG9ja3NbMTRdLCAxNSwgLTE0MTYzNTQ5MDUpXG4gICAgICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwgYmxvY2tzWzVdLCAyMSwgLTU3NDM0MDU1KVxuXG4gICAgICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwgYmxvY2tzWzEyXSwgNiwgMTcwMDQ4NTU3MSlcbiAgICAgICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBibG9ja3NbM10sIDEwLCAtMTg5NDk4NjYwNilcbiAgICAgICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBibG9ja3NbMTBdLCAxNSwgLTEwNTE1MjMpXG4gICAgICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwgYmxvY2tzWzFdLCAyMSwgLTIwNTQ5MjI3OTkpXG5cbiAgICAgICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBibG9ja3NbOF0sIDYsIDE4NzMzMTMzNTkpXG4gICAgICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywgYmxvY2tzWzE1XSwgMTAsIC0zMDYxMTc0NClcbiAgICAgICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBibG9ja3NbNl0sIDE1LCAtMTU2MDE5ODM4MClcbiAgICAgICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBibG9ja3NbMTNdLCAyMSwgMTMwOTE1MTY0OSlcblxuICAgICAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJsb2Nrc1s0XSwgNiwgLTE0NTUyMzA3MClcbiAgICAgICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBibG9ja3NbMTFdLCAxMCwgLTExMjAyMTAzNzkpXG4gICAgICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwgYmxvY2tzWzJdLCAxNSwgNzE4Nzg3MjU5KVxuICAgICAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJsb2Nrc1s5XSwgMjEsIC0zNDM0ODU1NTEpXG4gICAgICAgICAgICAvLyBlbmRyZWdpb25cbiAgICAgICAgICAgIHN0YXRlWzBdID0gdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24oYSwgc3RhdGVbMF0pXG4gICAgICAgICAgICBzdGF0ZVsxXSA9IHVuc2lnbmVkTW9kdWxlMlBvd2VyT2YzMkFkZGl0aW9uKGIsIHN0YXRlWzFdKVxuICAgICAgICAgICAgc3RhdGVbMl0gPSB1bnNpZ25lZE1vZHVsZTJQb3dlck9mMzJBZGRpdGlvbihjLCBzdGF0ZVsyXSlcbiAgICAgICAgICAgIHN0YXRlWzNdID0gdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24oZCwgc3RhdGVbM10pXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuICAgICAgICAvLyAvIGVuZHJlZ2lvblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgZ2l2ZW4gY2hhcmFjdGVyIHRvIGl0cyBjb3JyZXNwb25kaW5nIGhleCBjb2RlXG4gICAgICAgICAqIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gY2hhcmFjdGVyIC0gQ2hhcmFjdGVyIHRvIGNvbnZlcnQuXG4gICAgICAgICAqIEByZXR1cm5zIENvbnZlcnRlZCBoZXggY29kZSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb252ZXJ0Q2hhcmFjdG9yVG9IZXhDb2RlID0gKGNoYXJhY3RlcjphbnkpOnN0cmluZyA9PiB7XG4gICAgICAgICAgICBsZXQgaGV4U3RyaW5nOnN0cmluZyA9ICcnXG4gICAgICAgICAgICBmb3IgKGxldCByb3VuZDpudW1iZXIgPSAwOyByb3VuZCA8IDQ7IHJvdW5kKyspXG4gICAgICAgICAgICAgICAgaGV4U3RyaW5nICs9IGhleENoYXJhY3RlcnNbKGNoYXJhY3RlciA+PiAoXG4gICAgICAgICAgICAgICAgICAgIHJvdW5kICogOCArIDRcbiAgICAgICAgICAgICAgICApKSAmIDB4MEZdICsgaGV4Q2hhcmFjdGVyc1soY2hhcmFjdGVyID4+IChyb3VuZCAqIDgpKSAmIDB4MEZdXG4gICAgICAgICAgICByZXR1cm4gaGV4U3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGdpdmVuIGJ5dGUgYXJyYXkgdG8gaXRzIGNvcnJlc3BvbmRpbmcgaGV4IGNvZGUgYXMgc3RyaW5nLlxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBBcnJheSBvZiBjaGFyYWN0ZXJzIHRvIGNvbnZlcnQuXG4gICAgICAgICAqIEByZXR1cm5zIENvbnZlcnRlZCBoZXggY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNvbnZlcnRUb0hleENvZGUgPSAodmFsdWU6QXJyYXk8YW55Pik6c3RyaW5nID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4Om51bWJlciA9IDA7IGluZGV4IDwgdmFsdWUubGVuZ3RoOyBpbmRleCsrKVxuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IGNvbnZlcnRDaGFyYWN0b3JUb0hleENvZGUodmFsdWVbaW5kZXhdKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmpvaW4oJycpXG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZXJlIG5lZWRzIHRvIGJlIHN1cHBvcnQgZm9yIHVuaWNvZGUgaGVyZSwgdW5sZXNzIHdlIHByZXRlbmQgdGhhdFxuICAgICAgICAgKiB3ZSBjYW4gcmVkZWZpbmUgdGhlIG1kNSBhbGdvcml0aG0gZm9yIG11bHRpLWJ5dGUgY2hhcmFjdGVyc1xuICAgICAgICAgKiAocGVyaGFwcyBieSBhZGRpbmcgZXZlcnkgZm91ciAxNi1iaXQgY2hhcmFjdGVycyBhbmQgc2hvcnRlbmluZyB0aGVcbiAgICAgICAgICogc3VtIHRvIDMyIGJpdHMpLiBPdGhlcndpc2UgSSBzdWdnZXN0IHBlcmZvcm1pbmcgbWQ1IGFzIGlmIGV2ZXJ5XG4gICAgICAgICAqIGNoYXJhY3RlciB3YXMgdHdvIGJ5dGVzLS1lLmcuLCAwMDQwIDAwMjUgPSBAJS0tYnV0IHRoZW4gaG93IHdpbGwgYW5cbiAgICAgICAgICogb3JkaW5hcnkgbWQ1IHN1bSBiZSBtYXRjaGVkPyBUaGVyZSBpcyBubyB3YXkgdG8gc3RhbmRhcmRpemUgdGV4dFxuICAgICAgICAgKiB0byBzb21ldGhpbmcgbGlrZSB1dGYtOCBiZWZvcmUgdHJhbnNmb3JtYXRpb247IHNwZWVkIGNvc3QgaXNcbiAgICAgICAgICogdXR0ZXJseSBwcm9oaWJpdGl2ZS4gVGhlIEphdmFTY3JpcHQgc3RhbmRhcmQgaXRzZWxmIG5lZWRzIHRvIGxvb2tcbiAgICAgICAgICogYXQgdGhpczogaXQgc2hvdWxkIHN0YXJ0IHByb3ZpZGluZyBhY2Nlc3MgdG8gc3RyaW5ncyBhcyBwcmVmb3JtZWRcbiAgICAgICAgICogdXRmLTggOC1iaXQgdW5zaWduZWQgdmFsdWUgYXJyYXlzLlxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBwcm9jZXNzIHdpdGggZWFjaCBibG9jay5cbiAgICAgICAgICogQHJldHVybnMgQ29udmVydGVkIGJ5dGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBoYW5kbGVCbG9jayA9ICh2YWx1ZTpzdHJpbmcpOkFycmF5PGFueT4gPT4ge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tzOkFycmF5PGFueT4gPSBbXVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXI6bnVtYmVyID0gMDsgYmxvY2tOdW1iZXIgPCA2NDsgYmxvY2tOdW1iZXIgKz0gNFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGJsb2Nrc1tibG9ja051bWJlciA+PiAyXSA9IHZhbHVlLmNoYXJDb2RlQXQoYmxvY2tOdW1iZXIpICsgKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jaGFyQ29kZUF0KGJsb2NrTnVtYmVyICsgMSkgPDwgOFxuICAgICAgICAgICAgICAgICkgKyAodmFsdWUuY2hhckNvZGVBdChibG9ja051bWJlciArIDIpIDw8IDE2KSArIChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2hhckNvZGVBdChibG9ja051bWJlciArIDMpIDw8IDI0KVxuICAgICAgICAgICAgcmV0dXJuIGJsb2Nrc1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZHJlZ2lvblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlcnMgdGhlIG1haW4gYWxnb3JpdGhtIHRvIGNhbGN1bGF0ZSB0aGUgbWQ1IHJlcHJlc2VudGF0aW9uIG9mXG4gICAgICAgICAqIGdpdmVuIHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdG8gY29udmVydCB0byBpdHMgbWQ1IHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBibG9ja3MuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBtYWluID0gKHZhbHVlOnN0cmluZyk6QXJyYXk8YW55PiA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGg6bnVtYmVyID0gdmFsdWUubGVuZ3RoXG4gICAgICAgICAgICBjb25zdCBzdGF0ZTpBcnJheTxhbnk+ID0gW1xuICAgICAgICAgICAgICAgIDE3MzI1ODQxOTMsIC0yNzE3MzM4NzksIC0xNzMyNTg0MTk0LCAyNzE3MzM4NzhdXG4gICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXI6bnVtYmVyXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gNjQ7IGJsb2NrTnVtYmVyIDw9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciArPSA2NFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGN5Y2xlKHN0YXRlLCBoYW5kbGVCbG9jayh2YWx1ZS5zdWJzdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyIC0gNjQsIGJsb2NrTnVtYmVyKSkpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhibG9ja051bWJlciAtIDY0KVxuICAgICAgICAgICAgY29uc3QgdGFpbDpBcnJheTxudW1iZXI+ID0gW1xuICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgICAgICAgICBmb3IgKGJsb2NrTnVtYmVyID0gMDsgYmxvY2tOdW1iZXIgPCB2YWx1ZS5sZW5ndGg7IGJsb2NrTnVtYmVyKyspXG4gICAgICAgICAgICAgICAgdGFpbFtibG9ja051bWJlciA+PiAyXSB8PSB2YWx1ZS5jaGFyQ29kZUF0KGJsb2NrTnVtYmVyKSA8PCAoKFxuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciAlIDRcbiAgICAgICAgICAgICAgICApIDw8IDMpXG4gICAgICAgICAgICB0YWlsW2Jsb2NrTnVtYmVyID4+IDJdIHw9IDB4ODAgPDwgKChibG9ja051bWJlciAlIDQpIDw8IDMpXG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiA1NSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlKHN0YXRlLCB0YWlsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4Om51bWJlciA9IDA7IGluZGV4IDwgMTY7IGluZGV4KyspXG4gICAgICAgICAgICAgICAgICAgIHRhaWxbaW5kZXhdID0gMFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFpbFsxNF0gPSBsZW5ndGggKiA4XG4gICAgICAgICAgICBjeWNsZShzdGF0ZSwgdGFpbClcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlZ2lvbiBmaW5hbCBjYWxsXG4gICAgICAgIGlmIChjb252ZXJ0VG9IZXhDb2RlKG1haW4oXG4gICAgICAgICAgICAnaGVsbG8nXG4gICAgICAgICkpICE9PSAnNWQ0MTQwMmFiYzRiMmE3NmI5NzE5ZDkxMTAxN2M1OTInKVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIG11Y2ggZmFzdGVyLCBzbyBpZiBwb3NzaWJsZSB3ZSB1c2UgaXQuIFNvbWUgSUVzXG4gICAgICAgICAgICAgKiBhcmUgdGhlIG9ubHkgb25lcyBJIGtub3cgb2YgdGhhdCBuZWVkIHRoZSBpZGlvdGljIHNlY29uZFxuICAgICAgICAgICAgICogZnVuY3Rpb24sIGdlbmVyYXRlZCBieSBhbiBpZiBjbGF1c2UgaW4gdGhlIGVuZC5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZmlyc3QgLSBGaXJzdCBvcGVyYW5kIHRvIGFkZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzZWNvbmQgLSBTZWNvbmQgb3BlcmFudCB0byBhZGQuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUaGUgc3VtIG9mIGJvdGggZ2l2ZW4gb3BlcmFuZHMuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdW5zaWduZWRNb2R1bGUyUG93ZXJPZjMyQWRkaXRpb24gPSAoXG4gICAgICAgICAgICAgICAgZmlyc3Q6bnVtYmVyLCBzZWNvbmQ6bnVtYmVyXG4gICAgICAgICAgICApOm51bWJlciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbHN3ID0gKGZpcnN0ICYgMHhGRkZGKSArIChzZWNvbmQgJiAweEZGRkYpXG4gICAgICAgICAgICAgICAgY29uc3QgbXN3ID0gKGZpcnN0ID4+IDE2KSArIChzZWNvbmQgPj4gMTYpICsgKGxzdyA+PiAxNilcbiAgICAgICAgICAgICAgICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKVxuICAgICAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb0hleENvZGUobWFpbigob25seUFzY2lpKSA/IHZhbHVlIDogdW5lc2NhcGUoXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSkpXG4gICAgICAgIC8vIGVuZHJlZ2lvblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIGdpdmVuIHBob25lIG51bWJlciBmb3IgYXV0b21hdGljIGRpYWxpbmcgbWVjaGFuaXNtcy5cbiAgICAgKiBAcGFyYW0gcGhvbmVOdW1iZXIgLSBOdW1iZXIgdG8gbm9ybWFsaXplLlxuICAgICAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdOb3JtYWxpemVQaG9uZU51bWJlcihwaG9uZU51bWJlcjo/c3RyaW5nfD9udW1iZXIpOnN0cmluZyB7XG4gICAgICAgIGlmICh0eXBlb2YgcGhvbmVOdW1iZXIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwaG9uZU51bWJlciA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gYCR7cGhvbmVOdW1iZXJ9YC5yZXBsYWNlKC9bXjAtOV0qXFwrLywgJzAwJykucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvW14wLTldKy9nLCAnJylcbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgZ2l2ZW4gcGhvbmUgbnVtYmVyLiBOT1RFOiBDdXJyZW50bHkgb25seSBzdXBwb3J0IGdlcm1hbiBwaG9uZVxuICAgICAqIG51bWJlcnMuXG4gICAgICogQHBhcmFtIHBob25lTnVtYmVyIC0gTnVtYmVyIHRvIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJucyBGb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdSZXByZXNlbnRQaG9uZU51bWJlcihwaG9uZU51bWJlcjo/c3RyaW5nfD9udW1iZXIpOnN0cmluZyB7XG4gICAgICAgIGlmIChbJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyhUb29scy5kZXRlcm1pbmVUeXBlKFxuICAgICAgICAgICAgcGhvbmVOdW1iZXJcbiAgICAgICAgKSkgJiYgcGhvbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIFJlcHJlc2VudCBjb3VudHJ5IGNvZGUgYW5kIGxlYWRpbmcgYXJlYSBjb2RlIHplcm8uXG4gICAgICAgICAgICBwaG9uZU51bWJlciA9IGAke3Bob25lTnVtYmVyfWAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvXigwMHxcXCspKFswLTldKyktKFswLTktXSspJC8sICcrJDIgKDApICQzJylcbiAgICAgICAgICAgIC8vIEFkZCBHZXJtYW4gY291bnRyeSBjb2RlIGlmIG5vdCBleGlzdHMuXG4gICAgICAgICAgICBwaG9uZU51bWJlciA9IHBob25lTnVtYmVyLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgL14wKFsxLTldWzAtOS1dKykkLywgJys0OSAoMCkgJDEnKVxuICAgICAgICAgICAgLy8gU2VwYXJhdGUgYXJlYSBjb2RlIGZyb20gYmFzZSBudW1iZXIuXG4gICAgICAgICAgICBwaG9uZU51bWJlciA9IHBob25lTnVtYmVyLnJlcGxhY2UoL14oW14tXSspLShbMC05LV0rKSQvLCAnJDEgLyAkMicpXG4gICAgICAgICAgICAvLyBQYXJ0aXRpb24gYmFzZSBudW1iZXIgaW4gb25lIHRyaXBsZSBhbmQgdHVwbGVzIG9yIHR1cGxlcyBvbmx5LlxuICAgICAgICAgICAgcmV0dXJuIHBob25lTnVtYmVyLnJlcGxhY2UoL14oLio/KShbMC05XSspKC0/WzAtOV0qKSQvLCAoXG4gICAgICAgICAgICAgICAgbWF0Y2g6c3RyaW5nLCBwcmVmaXg6c3RyaW5nLCBudW1iZXI6c3RyaW5nLCBzdWZmaXg6c3RyaW5nXG4gICAgICAgICAgICApOnN0cmluZyA9PiBwcmVmaXggKyAoXG4gICAgICAgICAgICAgICAgKG51bWJlci5sZW5ndGggJSAyID09PSAwKSA/IG51bWJlci5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvKFswLTldezJ9KS9nLCAnJDEgJ1xuICAgICAgICAgICAgICAgICkgOiBudW1iZXIucmVwbGFjZSgvXihbMC05XXszfSkoWzAtOV0rKSQvLCAoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoOnN0cmluZywgdHJpcGxlOnN0cmluZywgcmVzdDpzdHJpbmdcbiAgICAgICAgICAgICAgICApOnN0cmluZyA9PiBgJHt0cmlwbGV9IGAgKyByZXN0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC8oWzAtOV17Mn0pL2csICckMSAnXG4gICAgICAgICAgICAgICAgKS50cmltKCkpICsgc3VmZml4KS50cmltKCkpLnRyaW0oKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGFsbCBodG1sIHN5bWJvbHMgaW4gdGV4dCBub2RlcyBpbiBnaXZlbiBodG1sIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gaHRtbFN0cmluZyAtIEhUTUwgc3RyaW5nIHRvIGRlY29kZS5cbiAgICAgKiBAcmV0dXJucyBEZWNvZGVkIGh0bWwgc3RyaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmdEZWNvZGVIVE1MRW50aXRpZXMoaHRtbFN0cmluZzpzdHJpbmcpOj9zdHJpbmcge1xuICAgICAgICBpZiAoJ2RvY3VtZW50JyBpbiAkLmdsb2JhbCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dGFyZWFEb21Ob2RlID0gJC5nbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKVxuICAgICAgICAgICAgdGV4dGFyZWFEb21Ob2RlLmlubmVySFRNTCA9IGh0bWxTdHJpbmdcbiAgICAgICAgICAgIHJldHVybiB0ZXh0YXJlYURvbU5vZGUudmFsdWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRvbSBzZWxlY3RvciB0byBhIHByZWZpeGVkIGRvbSBzZWxlY3RvciBzdHJpbmcuXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIC0gQSBkb20gbm9kZSBzZWxlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHNlbGVjdG9yIHByZWZpeGVkLlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZURvbU5vZGVTZWxlY3RvcihzZWxlY3RvcjpzdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIGxldCBkb21Ob2RlU2VsZWN0b3JQcmVmaXg6c3RyaW5nID0gJydcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZG9tTm9kZVNlbGVjdG9yUHJlZml4KVxuICAgICAgICAgICAgZG9tTm9kZVNlbGVjdG9yUHJlZml4ID0gYCR7dGhpcy5fb3B0aW9ucy5kb21Ob2RlU2VsZWN0b3JQcmVmaXh9IGBcbiAgICAgICAgaWYgKCEoc2VsZWN0b3Iuc3RhcnRzV2l0aChkb21Ob2RlU2VsZWN0b3JQcmVmaXgpIHx8IHNlbGVjdG9yLnRyaW0oXG4gICAgICAgICkuc3RhcnRzV2l0aCgnPCcpKSlcbiAgICAgICAgICAgIHNlbGVjdG9yID0gZG9tTm9kZVNlbGVjdG9yUHJlZml4ICsgc2VsZWN0b3JcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnRyaW0oKVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIC8gcmVnaW9uIG51bWJlclxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiBvYmplY3QgaXMgamF2YSBzY3JpcHRzIG5hdGl2ZSBcIk51bWJlci5OYU5cIiBvYmplY3QuXG4gICAgICogQHBhcmFtIG9iamVjdCAtIE9iamVjdCB0byBDaGVjay5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyIG9yIG5vdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbnVtYmVySXNOb3RBTnVtYmVyKG9iamVjdDphbnkpOmJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gVG9vbHMuZGV0ZXJtaW5lVHlwZShvYmplY3QpID09PSAnbnVtYmVyJyAmJiBpc05hTihvYmplY3QpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdW5kcyBhIGdpdmVuIG51bWJlciBhY2N1cmF0ZSB0byBnaXZlbiBudW1iZXIgb2YgZGlnaXRzLlxuICAgICAqIEBwYXJhbSBudW1iZXIgLSBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSBkaWdpdHMgLSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciBjb21tYS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgbnVtYmVyUm91bmQobnVtYmVyOm51bWJlciwgZGlnaXRzOm51bWJlciA9IDApOm51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBkaWdpdHMpKSAvIE1hdGgucG93KDEwLCBkaWdpdHMpXG4gICAgfVxuICAgIC8vIC8gZW5kcmVnaW9uXG4gICAgLy8gLyByZWdpb24gZGF0YSB0cmFuc2ZlclxuICAgIC8qKlxuICAgICAqIFNlbmQgZ2l2ZW4gZGF0YSB0byBhIGdpdmVuIGlmcmFtZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gTmFtZSBvZiB0aGUgdGFyZ2V0IGlmcmFtZSBvciB0aGUgdGFyZ2V0IGlmcmFtZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIHVybCAtIFVSTCB0byBzZW5kIHRvIGRhdGEgdG8uXG4gICAgICogQHBhcmFtIGRhdGEgLSBEYXRhIGhvbGRpbmcgb2JqZWN0IHRvIHNlbmQgZGF0YSB0by5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdFR5cGUgLSBUaGUgZm9ybXMgYWN0aW9uIGF0dHJpYnV0ZSB2YWx1ZS4gSWYgbm90aGluZyBpc1xuICAgICAqIHByb3ZpZGVkIFwicG9zdFwiIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0LlxuICAgICAqIEBwYXJhbSByZW1vdmVBZnRlckxvYWQgLSBJbmRpY2F0ZXMgaWYgY3JlYXRlZCBpZnJhbWUgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKiByaWdodCBhZnRlciBsb2FkIGV2ZW50LiBPbmx5IHdvcmtzIGlmIGFuIGlmcmFtZSBvYmplY3QgaXMgZ2l2ZW4gaW5zdGVhZFxuICAgICAqIG9mIGEgc2ltcGxlIHRhcmdldCBuYW1lLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGdpdmVuIHRhcmdldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VuZFRvSUZyYW1lKFxuICAgICAgICB0YXJnZXQ6JERvbU5vZGV8c3RyaW5nLCB1cmw6c3RyaW5nLCBkYXRhOntba2V5OnN0cmluZ106YW55fSxcbiAgICAgICAgcmVxdWVzdFR5cGU6c3RyaW5nID0gJ3Bvc3QnLCByZW1vdmVBZnRlckxvYWQ6Ym9vbGVhbiA9IGZhbHNlXG4gICAgKTpzdHJpbmcge1xuICAgICAgICBjb25zdCB0YXJnZXROYW1lOnN0cmluZyA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDpcbiAgICAgICAgICAgIHRhcmdldC5hdHRyKCduYW1lJylcbiAgICAgICAgY29uc3QgJGZvcm1Eb21Ob2RlOiREb21Ob2RlID0gJCgnPGZvcm0+JykuYXR0cih7XG4gICAgICAgICAgICBhY3Rpb246IHVybCxcbiAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdFR5cGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldE5hbWVcbiAgICAgICAgfSlcbiAgICAgICAgZm9yIChjb25zdCBuYW1lOnN0cmluZyBpbiBkYXRhKVxuICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICAgICAgJGZvcm1Eb21Ob2RlLmFwcGVuZCgkKCc8aW5wdXQ+JykuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVtuYW1lXVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAkZm9ybURvbU5vZGUuc3VibWl0KCkucmVtb3ZlKClcbiAgICAgICAgaWYgKHJlbW92ZUFmdGVyTG9hZCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiAnb24nIGluIHRhcmdldClcbiAgICAgICAgICAgIC8vIElnbm9yZVR5cGVDaGVja1xuICAgICAgICAgICAgdGFyZ2V0Lm9uKCdsb2FkJywgKCk6JERvbU5vZGUgPT4gdGFyZ2V0LnJlbW92ZSgpKVxuICAgICAgICByZXR1cm4gdGFyZ2V0TmFtZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGdpdmVuIGRhdGEgdG8gYSB0ZW1wb3JhcnkgY3JlYXRlZCBpZnJhbWUuXG4gICAgICogQHBhcmFtIHVybCAtIFVSTCB0byBzZW5kIHRvIGRhdGEgdG8uXG4gICAgICogQHBhcmFtIGRhdGEgLSBEYXRhIGhvbGRpbmcgb2JqZWN0IHRvIHNlbmQgZGF0YSB0by5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdFR5cGUgLSBUaGUgZm9ybXMgYWN0aW9uIGF0dHJpYnV0ZSB2YWx1ZS4gSWYgbm90aGluZyBpc1xuICAgICAqIHByb3ZpZGVkIFwicG9zdFwiIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0LlxuICAgICAqIEBwYXJhbSByZW1vdmVBZnRlckxvYWQgLSBJbmRpY2F0ZXMgaWYgY3JlYXRlZCBpZnJhbWUgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKiByaWdodCBhZnRlciBsb2FkIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGR5bmFtaWNhbGx5IGNyZWF0ZWQgaWZyYW1lLlxuICAgICAqL1xuICAgIHNlbmRUb0V4dGVybmFsVVJMKFxuICAgICAgICB1cmw6c3RyaW5nLCBkYXRhOntba2V5OnN0cmluZ106YW55fSwgcmVxdWVzdFR5cGU6c3RyaW5nID0gJ3Bvc3QnLFxuICAgICAgICByZW1vdmVBZnRlckxvYWQ6Ym9vbGVhbiA9IHRydWVcbiAgICApOnN0cmluZyB7XG4gICAgICAgIGNvbnN0ICRpRnJhbWVEb21Ob2RlOiREb21Ob2RlID0gJCgnPGlmcmFtZT4nKS5hdHRyKFxuICAgICAgICAgICAgJ25hbWUnLCB0aGlzLmNvbnN0cnVjdG9yLl9uYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuX25hbWUuc3Vic3RyaW5nKDEpICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKVxuICAgICAgICApLmhpZGUoKVxuICAgICAgICB0aGlzLiRkb21Ob2RlLmFmdGVyKCRpRnJhbWVEb21Ob2RlKVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5zZW5kVG9JRnJhbWUoXG4gICAgICAgICAgICAkaUZyYW1lRG9tTm9kZSwgdXJsLCBkYXRhLCByZXF1ZXN0VHlwZSwgcmVtb3ZlQWZ0ZXJMb2FkKVxuICAgIH1cbiAgICAvLyAvIGVuZHJlZ2lvblxuICAgIC8vIGVuZHJlZ2lvblxuICAgIC8vIHJlZ2lvbiBwcm90ZWN0ZWRcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9yZXF1aXJlLWRlc2NyaXB0aW9uLWNvbXBsZXRlLXNlbnRlbmNlICovXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCBmb3IgYXR0YWNoIGV2ZW50IGhhbmRsZXIgbWV0aG9kcyBhbmQgdGhlaXIgZXZlbnQgaGFuZGxlclxuICAgICAqIHJlbW92ZSBwZW5kYW50cy5cbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyIC0gQXJndW1lbnRzIG9iamVjdCBnaXZlbiB0byBtZXRob2RzIGxpa2UgXCJiaW5kKClcIiBvclxuICAgICAqIFwidW5iaW5kKClcIi5cbiAgICAgKiBAcGFyYW0gcmVtb3ZlRXZlbnQgLSBJbmRpY2F0ZXMgaWYgXCJ1bmJpbmQoKVwiIG9yIFwiYmluZCgpXCIgd2FzIGdpdmVuLlxuICAgICAqIEBwYXJhbSBldmVudEZ1bmN0aW9uTmFtZSAtIE5hbWUgb2YgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zICQncyB3cmFwcGVkIGRvbSBub2RlLlxuICAgICAqL1xuICAgIF9iaW5kRXZlbnRIZWxwZXIoXG4gICAgICAgIHBhcmFtZXRlcjpBcnJheTxhbnk+LCByZW1vdmVFdmVudDpib29sZWFuID0gZmFsc2UsXG4gICAgICAgIGV2ZW50RnVuY3Rpb25OYW1lOnN0cmluZyA9ICdvbidcbiAgICApOiREb21Ob2RlIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb24tY29tcGxldGUtc2VudGVuY2UgKi9cbiAgICAgICAgY29uc3QgJGRvbU5vZGU6JERvbU5vZGUgPSAkKHBhcmFtZXRlclswXSlcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZGV0ZXJtaW5lVHlwZShcbiAgICAgICAgICAgIHBhcmFtZXRlclsxXVxuICAgICAgICApID09PSAnb2JqZWN0JyAmJiAhcmVtb3ZlRXZlbnQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnRUeXBlOnN0cmluZyBpbiBwYXJhbWV0ZXJbMV0pXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlclsxXS5oYXNPd25Qcm9wZXJ0eShldmVudFR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmVUeXBlQ2hlY2tcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tldmVudEZ1bmN0aW9uTmFtZV0oXG4gICAgICAgICAgICAgICAgICAgICAgICAkZG9tTm9kZSwgZXZlbnRUeXBlLCBwYXJhbWV0ZXJbMV1bZXZlbnRUeXBlXSlcbiAgICAgICAgICAgIHJldHVybiAkZG9tTm9kZVxuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlciA9IHRoaXMuY29uc3RydWN0b3IuYXJyYXlNYWtlKHBhcmFtZXRlcikuc2xpY2UoMSlcbiAgICAgICAgaWYgKHBhcmFtZXRlci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBwYXJhbWV0ZXIucHVzaCgnJylcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJbMF0uaW5jbHVkZXMoJy4nKSlcbiAgICAgICAgICAgIHBhcmFtZXRlclswXSArPSBgLiR7dGhpcy5jb25zdHJ1Y3Rvci5fbmFtZX1gXG4gICAgICAgIGlmIChyZW1vdmVFdmVudClcbiAgICAgICAgICAgIHJldHVybiAkZG9tTm9kZVtldmVudEZ1bmN0aW9uTmFtZV0uYXBwbHkoJGRvbU5vZGUsIHBhcmFtZXRlcilcbiAgICAgICAgcmV0dXJuICRkb21Ob2RlW2V2ZW50RnVuY3Rpb25OYW1lXS5hcHBseSgkZG9tTm9kZSwgcGFyYW1ldGVyKVxuICAgIH1cbiAgICAvLyBlbmRyZWdpb25cbn1cbi8vIGVuZHJlZ2lvblxuLy8gcmVnaW9uIGhhbmRsZSAkIGV4dGVuZGluZ1xuaWYgKCdmbicgaW4gJClcbiAgICAkLmZuLlRvb2xzID0gZnVuY3Rpb24oKTphbnkge1xuICAgICAgICByZXR1cm4gKG5ldyBUb29scygpKS5jb250cm9sbGVyKFRvb2xzLCBhcmd1bWVudHMsIHRoaXMpXG4gICAgfVxuJC5Ub29scyA9IGZ1bmN0aW9uKCk6YW55IHtcbiAgICByZXR1cm4gKG5ldyBUb29scygpKS5jb250cm9sbGVyKFRvb2xzLCBhcmd1bWVudHMpXG59XG4kLlRvb2xzLmNsYXNzID0gVG9vbHNcbi8vIC8gcmVnaW9uIHByb3AgZml4IGZvciBjb21tZW50cyBhbmQgdGV4dCBub2Rlc1xuaWYgKCdmbicgaW4gJCkge1xuICAgIGNvbnN0IG5hdGl2ZVByb3BGdW5jdGlvbiA9ICQuZm4ucHJvcFxuICAgIC8qKlxuICAgICAqIEpRdWVyeSdzIG5hdGl2ZSBwcm9wIGltcGxlbWVudGF0aW9uIGlnbm9yZXMgcHJvcGVydGllcyBmb3IgdGV4dCBub2RlcyxcbiAgICAgKiBjb21tZW50cyBhbmQgYXR0cmlidXRlIG5vZGVzLlxuICAgICAqIEBwYXJhbSBrZXkgLSBOYW1lIG9mIHByb3BlcnR5IHRvIHJldHJpZXZlIGZyb20gY3VycmVudCBkb20gbm9kZS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBzZXQgZm9yIGdpdmVuIHByb3BlcnR5IGJ5IG5hbWUuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB2YWx1ZSBpZiB1c2VkIGFzIGdldHRlciBvciBjdXJyZW50IGRvbSBub2RlIGlmIHVzZWQgYXNcbiAgICAgKiBzZXR0ZXIuXG4gICAgICovXG4gICAgJC5mbi5wcm9wID0gZnVuY3Rpb24oa2V5OnN0cmluZywgdmFsdWU6YW55KTphbnkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMgJiYgdGhpcy5sZW5ndGggJiYgW1xuICAgICAgICAgICAgJyN0ZXh0JywgJyNjb21tZW50J1xuICAgICAgICBdLmluY2x1ZGVzKHRoaXNbMF0ubm9kZU5hbWUpICYmIGtleSBpbiB0aGlzWzBdKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1swXVtrZXldXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXNbMF1ba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlUHJvcEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICB9XG59XG4vLyAvIGVuZHJlZ2lvblxuLy8gZW5kcmVnaW9uXG4vLyByZWdpb24gdmltIG1vZGxpbmVcbi8vIHZpbTogc2V0IHRhYnN0b3A9NCBzaGlmdHdpZHRoPTQgZXhwYW5kdGFiOlxuLy8gdmltOiBmb2xkbWV0aG9kPW1hcmtlciBmb2xkbWFya2VyPXJlZ2lvbixlbmRyZWdpb246XG4vLyBlbmRyZWdpb25cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGluZGV4LmpzXG4gKiovIiwidW5kZWZpbmVkXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogXG4gKiovIl0sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcURBO0FBQ0E7QUFDQTtBQXREQTtBQUNBO0FBcURBO0FBQ0E7QUNDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBREVBO0FBQUE7QUNBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBRENBO0FBQ0E7QUNFQTtBQUNBO0FBQ0E7QUEzQkE7QUFDQTtBQURBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FERUE7QUNFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDQTtBQTZHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVRBO0FBQ0E7QUEwQkE7QUFRQTtBQUFBO0FBQUE7QUFMQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFUQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQXpLQTtBQUNBO0FBQ0E7OztBQTJLQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFBQTs7OztBQUlBO0FBRUE7Ozs7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBOzs7O0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUVBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQXVIQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBUkE7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFKQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUxBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBOERBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFjQTs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFNQTtBQUNBOzs7Ozs7Ozs7QUFzQkE7Ozs7OztBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUhBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFaQTtBQWVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQTZDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQWFBO0FBRUE7QUFEQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFFQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUF5RUE7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBMnlEQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQXVEQTs7Ozs7Ozs7OztBQVdBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQXJyRkE7QUFDQTtBQUNBOzs7OztBQUtBO0FBRUE7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBSUE7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFKQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUdBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUE4SEE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7O0FBaUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7QUFQQTtBQVdBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFqQkE7QUFzQkE7QUFHQTtBQUdBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFpQ0E7QUFDQTtBQUVBO0FBS0E7OztBQXFCQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQVhBO0FBWUE7QUFBQTtBQUNBO0FBREE7QUFJQTs7O0FBbURBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7OztBQXVEQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7Ozs7QUFJQTtBQVJBO0FBVUE7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBOzs7QUFtREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFFQTtBQURBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQStEQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVNBO0FBRUE7QUFDQTtBQURBO0FBUUE7QUFDQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQTtBQUNBO0FBREE7QUFJQTtBQWRBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFLQTtBQUxBO0FBQUE7QUFLQTtBQUpBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQURBO0FBTUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUF4QkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQXlCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFLQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQXpCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFrRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBSUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFLQTtBQXRCQTtBQTRCQTtBQUNBOzs7Ozs7Ozs7OztBQVNBO0FBSUE7QUFGQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUVBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBRUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQURBO0FBSUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFxQkE7QUFNQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFUQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFFQTtBQUNBO0FBSUE7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFUQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWVBO0FBRUE7QUFLQTtBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQURBO0FBR0E7QUFDQTtBQUlBO0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBVEE7QUFZQTtBQWxCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFFQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBT0E7QUFFQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFFQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFiQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFFQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQVJBO0FBV0E7QUFmQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFFQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBL0NBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQStDQTtBQWhEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFIQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBcURBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFPQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFJQTtBQUNBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQWFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFFQTtBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBY0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQS9DQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBZ0RBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBaUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFTQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQVNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFHQTtBQUVBO0FBRUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVVBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBR0E7QUFDQTs7O0FBR0E7QUFHQTtBQUdBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFJQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFJQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFJQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFJQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFHQTtBQUhBO0FBUUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFKQTtBQU9BO0FBRUE7QUFDQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7OztBQVNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUFBO0FBTEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7OztBQStEQTtBQUNBO0FBQ0E7QUFDQTtBQWwrRkE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFOQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQUNBO0FBbEJBO0FBMENBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUF4RUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFpK0ZBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/YzNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/*!*****************************************************!*\
  !*** external "babel-runtime/core-js/get-iterator" ***!
  \*****************************************************/
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIj81NWEzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIlxuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/*!*******************************************************!*\
  !*** external "babel-runtime/core-js/json/stringify" ***!
  \*******************************************************/
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeVwiP2JmYTciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzRfXztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5XCJcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/*!********************************************!*\
  !*** external "babel-runtime/core-js/map" ***!
  \********************************************/
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXBcIj9hZWUwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81X187XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXBcIlxuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/*!****************************************************************!*\
  !*** external "babel-runtime/core-js/object/get-prototype-of" ***!
  \****************************************************************/
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiPzVlOWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCJcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/*!*******************************************************!*\
  !*** external "babel-runtime/helpers/classCallCheck" ***!
  \*******************************************************/
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiPzBhMGQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCJcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/*!****************************************************!*\
  !*** external "babel-runtime/helpers/createClass" ***!
  \****************************************************/
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiPzg5NjEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCJcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/*!******************************************************!*\
  !*** external "babel-runtime/helpers/slicedToArray" ***!
  \******************************************************/
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_9__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCI/MzVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOV9fO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheVwiXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/*!***********************************************!*\
  !*** external "babel-runtime/helpers/typeof" ***!
  \***********************************************/
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_10__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCI/ZGMxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTBfXztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ function(module, exports) {

	eval("if(typeof __WEBPACK_EXTERNAL_MODULE_11__ === 'undefined') {var e = new Error(\"Cannot find module \\\"jQuery\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_11__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj8wY2I4Il0sInNvdXJjZXNDb250ZW50IjpbImlmKHR5cGVvZiBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzExX18gPT09ICd1bmRlZmluZWQnKSB7dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFxcImpRdWVyeVxcXCJcIik7IGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJzsgdGhyb3cgZTt9XG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTFfXztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwialF1ZXJ5XCJcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;